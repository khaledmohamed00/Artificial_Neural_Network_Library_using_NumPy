
FREEARTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000416c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000010  00800060  0000416c  00004200  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002e6  00800070  00800070  00004210  2**0
                  ALLOC
  3 .stab         00005364  00000000  00000000  00004210  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000318e  00000000  00000000  00009574  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000c702  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  0000c842  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  0000c9b2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  0000e5fb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  0000f4e6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00010294  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  000103f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  00010681  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00010e4f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 ae 14 	jmp	0x295c	; 0x295c <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec e6       	ldi	r30, 0x6C	; 108
      68:	f1 e4       	ldi	r31, 0x41	; 65
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a0 37       	cpi	r26, 0x70	; 112
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a0 e7       	ldi	r26, 0x70	; 112
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a6 35       	cpi	r26, 0x56	; 86
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 03 0d 	call	0x1a06	; 0x1a06 <main>
      8a:	0c 94 b4 20 	jmp	0x4168	; 0x4168 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 5e 20 	jmp	0x40bc	; 0x40bc <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a5 e6       	ldi	r26, 0x65	; 101
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 7a 20 	jmp	0x40f4	; 0x40f4 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 6a 20 	jmp	0x40d4	; 0x40d4 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 86 20 	jmp	0x410c	; 0x410c <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 6a 20 	jmp	0x40d4	; 0x40d4 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 86 20 	jmp	0x410c	; 0x410c <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 5e 20 	jmp	0x40bc	; 0x40bc <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	85 e6       	ldi	r24, 0x65	; 101
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 7a 20 	jmp	0x40f4	; 0x40f4 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 6a 20 	jmp	0x40d4	; 0x40d4 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 86 20 	jmp	0x410c	; 0x410c <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 6a 20 	jmp	0x40d4	; 0x40d4 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 86 20 	jmp	0x410c	; 0x410c <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 6a 20 	jmp	0x40d4	; 0x40d4 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 86 20 	jmp	0x410c	; 0x410c <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 6e 20 	jmp	0x40dc	; 0x40dc <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 8a 20 	jmp	0x4114	; 0x4114 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <DIO_voidSetPinDirection>:
 *    its return type is void that means it has no return value
 *
********************************************************************************************/

extern void DIO_voidSetPinDirection(u8 Copy_u8PinNum, u8 Copy_u8PinValue )
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <DIO_voidSetPinDirection+0x6>
     b4c:	cd b7       	in	r28, 0x3d	; 61
     b4e:	de b7       	in	r29, 0x3e	; 62
     b50:	89 83       	std	Y+1, r24	; 0x01
     b52:	6a 83       	std	Y+2, r22	; 0x02
	if( (Copy_u8PinNum>=0 && Copy_u8PinNum<=31) &&  (Copy_u8PinValue==0 || Copy_u8PinValue==1) )
     b54:	89 81       	ldd	r24, Y+1	; 0x01
     b56:	80 32       	cpi	r24, 0x20	; 32
     b58:	08 f0       	brcs	.+2      	; 0xb5c <DIO_voidSetPinDirection+0x16>
     b5a:	cd c0       	rjmp	.+410    	; 0xcf6 <DIO_voidSetPinDirection+0x1b0>
     b5c:	8a 81       	ldd	r24, Y+2	; 0x02
     b5e:	88 23       	and	r24, r24
     b60:	21 f0       	breq	.+8      	; 0xb6a <DIO_voidSetPinDirection+0x24>
     b62:	8a 81       	ldd	r24, Y+2	; 0x02
     b64:	81 30       	cpi	r24, 0x01	; 1
     b66:	09 f0       	breq	.+2      	; 0xb6a <DIO_voidSetPinDirection+0x24>
     b68:	c6 c0       	rjmp	.+396    	; 0xcf6 <DIO_voidSetPinDirection+0x1b0>
	{
		//here is a switch case to specify which pin was passed to the function and assign the value to it
		if(Copy_u8PinNum/8==0)
     b6a:	89 81       	ldd	r24, Y+1	; 0x01
     b6c:	88 30       	cpi	r24, 0x08	; 8
     b6e:	70 f5       	brcc	.+92     	; 0xbcc <DIO_voidSetPinDirection+0x86>
		{
			assign_bit(DDRA,Copy_u8PinNum%8,Copy_u8PinValue);
     b70:	aa e3       	ldi	r26, 0x3A	; 58
     b72:	b0 e0       	ldi	r27, 0x00	; 0
     b74:	ea e3       	ldi	r30, 0x3A	; 58
     b76:	f0 e0       	ldi	r31, 0x00	; 0
     b78:	80 81       	ld	r24, Z
     b7a:	48 2f       	mov	r20, r24
     b7c:	89 81       	ldd	r24, Y+1	; 0x01
     b7e:	88 2f       	mov	r24, r24
     b80:	90 e0       	ldi	r25, 0x00	; 0
     b82:	9c 01       	movw	r18, r24
     b84:	27 70       	andi	r18, 0x07	; 7
     b86:	30 70       	andi	r19, 0x00	; 0
     b88:	81 e0       	ldi	r24, 0x01	; 1
     b8a:	90 e0       	ldi	r25, 0x00	; 0
     b8c:	02 c0       	rjmp	.+4      	; 0xb92 <DIO_voidSetPinDirection+0x4c>
     b8e:	88 0f       	add	r24, r24
     b90:	99 1f       	adc	r25, r25
     b92:	2a 95       	dec	r18
     b94:	e2 f7       	brpl	.-8      	; 0xb8e <DIO_voidSetPinDirection+0x48>
     b96:	80 95       	com	r24
     b98:	84 23       	and	r24, r20
     b9a:	8c 93       	st	X, r24
     b9c:	aa e3       	ldi	r26, 0x3A	; 58
     b9e:	b0 e0       	ldi	r27, 0x00	; 0
     ba0:	ea e3       	ldi	r30, 0x3A	; 58
     ba2:	f0 e0       	ldi	r31, 0x00	; 0
     ba4:	80 81       	ld	r24, Z
     ba6:	48 2f       	mov	r20, r24
     ba8:	8a 81       	ldd	r24, Y+2	; 0x02
     baa:	28 2f       	mov	r18, r24
     bac:	30 e0       	ldi	r19, 0x00	; 0
     bae:	89 81       	ldd	r24, Y+1	; 0x01
     bb0:	88 2f       	mov	r24, r24
     bb2:	90 e0       	ldi	r25, 0x00	; 0
     bb4:	87 70       	andi	r24, 0x07	; 7
     bb6:	90 70       	andi	r25, 0x00	; 0
     bb8:	b9 01       	movw	r22, r18
     bba:	02 c0       	rjmp	.+4      	; 0xbc0 <DIO_voidSetPinDirection+0x7a>
     bbc:	66 0f       	add	r22, r22
     bbe:	77 1f       	adc	r23, r23
     bc0:	8a 95       	dec	r24
     bc2:	e2 f7       	brpl	.-8      	; 0xbbc <DIO_voidSetPinDirection+0x76>
     bc4:	cb 01       	movw	r24, r22
     bc6:	84 2b       	or	r24, r20
     bc8:	8c 93       	st	X, r24
     bca:	95 c0       	rjmp	.+298    	; 0xcf6 <DIO_voidSetPinDirection+0x1b0>
		}
		else if(Copy_u8PinNum/8==1)
     bcc:	89 81       	ldd	r24, Y+1	; 0x01
     bce:	88 50       	subi	r24, 0x08	; 8
     bd0:	88 30       	cpi	r24, 0x08	; 8
     bd2:	70 f5       	brcc	.+92     	; 0xc30 <DIO_voidSetPinDirection+0xea>
		{
			assign_bit(DDRB,Copy_u8PinNum%8,Copy_u8PinValue);
     bd4:	a7 e3       	ldi	r26, 0x37	; 55
     bd6:	b0 e0       	ldi	r27, 0x00	; 0
     bd8:	e7 e3       	ldi	r30, 0x37	; 55
     bda:	f0 e0       	ldi	r31, 0x00	; 0
     bdc:	80 81       	ld	r24, Z
     bde:	48 2f       	mov	r20, r24
     be0:	89 81       	ldd	r24, Y+1	; 0x01
     be2:	88 2f       	mov	r24, r24
     be4:	90 e0       	ldi	r25, 0x00	; 0
     be6:	9c 01       	movw	r18, r24
     be8:	27 70       	andi	r18, 0x07	; 7
     bea:	30 70       	andi	r19, 0x00	; 0
     bec:	81 e0       	ldi	r24, 0x01	; 1
     bee:	90 e0       	ldi	r25, 0x00	; 0
     bf0:	02 c0       	rjmp	.+4      	; 0xbf6 <DIO_voidSetPinDirection+0xb0>
     bf2:	88 0f       	add	r24, r24
     bf4:	99 1f       	adc	r25, r25
     bf6:	2a 95       	dec	r18
     bf8:	e2 f7       	brpl	.-8      	; 0xbf2 <DIO_voidSetPinDirection+0xac>
     bfa:	80 95       	com	r24
     bfc:	84 23       	and	r24, r20
     bfe:	8c 93       	st	X, r24
     c00:	a7 e3       	ldi	r26, 0x37	; 55
     c02:	b0 e0       	ldi	r27, 0x00	; 0
     c04:	e7 e3       	ldi	r30, 0x37	; 55
     c06:	f0 e0       	ldi	r31, 0x00	; 0
     c08:	80 81       	ld	r24, Z
     c0a:	48 2f       	mov	r20, r24
     c0c:	8a 81       	ldd	r24, Y+2	; 0x02
     c0e:	28 2f       	mov	r18, r24
     c10:	30 e0       	ldi	r19, 0x00	; 0
     c12:	89 81       	ldd	r24, Y+1	; 0x01
     c14:	88 2f       	mov	r24, r24
     c16:	90 e0       	ldi	r25, 0x00	; 0
     c18:	87 70       	andi	r24, 0x07	; 7
     c1a:	90 70       	andi	r25, 0x00	; 0
     c1c:	b9 01       	movw	r22, r18
     c1e:	02 c0       	rjmp	.+4      	; 0xc24 <DIO_voidSetPinDirection+0xde>
     c20:	66 0f       	add	r22, r22
     c22:	77 1f       	adc	r23, r23
     c24:	8a 95       	dec	r24
     c26:	e2 f7       	brpl	.-8      	; 0xc20 <DIO_voidSetPinDirection+0xda>
     c28:	cb 01       	movw	r24, r22
     c2a:	84 2b       	or	r24, r20
     c2c:	8c 93       	st	X, r24
     c2e:	63 c0       	rjmp	.+198    	; 0xcf6 <DIO_voidSetPinDirection+0x1b0>
		}
		else if(Copy_u8PinNum/8==2)
     c30:	89 81       	ldd	r24, Y+1	; 0x01
     c32:	80 51       	subi	r24, 0x10	; 16
     c34:	88 30       	cpi	r24, 0x08	; 8
     c36:	70 f5       	brcc	.+92     	; 0xc94 <DIO_voidSetPinDirection+0x14e>
		{
			assign_bit(DDRC,Copy_u8PinNum%8,Copy_u8PinValue);
     c38:	a4 e3       	ldi	r26, 0x34	; 52
     c3a:	b0 e0       	ldi	r27, 0x00	; 0
     c3c:	e4 e3       	ldi	r30, 0x34	; 52
     c3e:	f0 e0       	ldi	r31, 0x00	; 0
     c40:	80 81       	ld	r24, Z
     c42:	48 2f       	mov	r20, r24
     c44:	89 81       	ldd	r24, Y+1	; 0x01
     c46:	88 2f       	mov	r24, r24
     c48:	90 e0       	ldi	r25, 0x00	; 0
     c4a:	9c 01       	movw	r18, r24
     c4c:	27 70       	andi	r18, 0x07	; 7
     c4e:	30 70       	andi	r19, 0x00	; 0
     c50:	81 e0       	ldi	r24, 0x01	; 1
     c52:	90 e0       	ldi	r25, 0x00	; 0
     c54:	02 c0       	rjmp	.+4      	; 0xc5a <DIO_voidSetPinDirection+0x114>
     c56:	88 0f       	add	r24, r24
     c58:	99 1f       	adc	r25, r25
     c5a:	2a 95       	dec	r18
     c5c:	e2 f7       	brpl	.-8      	; 0xc56 <DIO_voidSetPinDirection+0x110>
     c5e:	80 95       	com	r24
     c60:	84 23       	and	r24, r20
     c62:	8c 93       	st	X, r24
     c64:	a4 e3       	ldi	r26, 0x34	; 52
     c66:	b0 e0       	ldi	r27, 0x00	; 0
     c68:	e4 e3       	ldi	r30, 0x34	; 52
     c6a:	f0 e0       	ldi	r31, 0x00	; 0
     c6c:	80 81       	ld	r24, Z
     c6e:	48 2f       	mov	r20, r24
     c70:	8a 81       	ldd	r24, Y+2	; 0x02
     c72:	28 2f       	mov	r18, r24
     c74:	30 e0       	ldi	r19, 0x00	; 0
     c76:	89 81       	ldd	r24, Y+1	; 0x01
     c78:	88 2f       	mov	r24, r24
     c7a:	90 e0       	ldi	r25, 0x00	; 0
     c7c:	87 70       	andi	r24, 0x07	; 7
     c7e:	90 70       	andi	r25, 0x00	; 0
     c80:	b9 01       	movw	r22, r18
     c82:	02 c0       	rjmp	.+4      	; 0xc88 <DIO_voidSetPinDirection+0x142>
     c84:	66 0f       	add	r22, r22
     c86:	77 1f       	adc	r23, r23
     c88:	8a 95       	dec	r24
     c8a:	e2 f7       	brpl	.-8      	; 0xc84 <DIO_voidSetPinDirection+0x13e>
     c8c:	cb 01       	movw	r24, r22
     c8e:	84 2b       	or	r24, r20
     c90:	8c 93       	st	X, r24
     c92:	31 c0       	rjmp	.+98     	; 0xcf6 <DIO_voidSetPinDirection+0x1b0>
		}
		else if(Copy_u8PinNum/8==3)
     c94:	89 81       	ldd	r24, Y+1	; 0x01
     c96:	88 51       	subi	r24, 0x18	; 24
     c98:	88 30       	cpi	r24, 0x08	; 8
     c9a:	68 f5       	brcc	.+90     	; 0xcf6 <DIO_voidSetPinDirection+0x1b0>
		{
			assign_bit(DDRD,Copy_u8PinNum%8,Copy_u8PinValue);
     c9c:	a1 e3       	ldi	r26, 0x31	; 49
     c9e:	b0 e0       	ldi	r27, 0x00	; 0
     ca0:	e1 e3       	ldi	r30, 0x31	; 49
     ca2:	f0 e0       	ldi	r31, 0x00	; 0
     ca4:	80 81       	ld	r24, Z
     ca6:	48 2f       	mov	r20, r24
     ca8:	89 81       	ldd	r24, Y+1	; 0x01
     caa:	88 2f       	mov	r24, r24
     cac:	90 e0       	ldi	r25, 0x00	; 0
     cae:	9c 01       	movw	r18, r24
     cb0:	27 70       	andi	r18, 0x07	; 7
     cb2:	30 70       	andi	r19, 0x00	; 0
     cb4:	81 e0       	ldi	r24, 0x01	; 1
     cb6:	90 e0       	ldi	r25, 0x00	; 0
     cb8:	02 c0       	rjmp	.+4      	; 0xcbe <DIO_voidSetPinDirection+0x178>
     cba:	88 0f       	add	r24, r24
     cbc:	99 1f       	adc	r25, r25
     cbe:	2a 95       	dec	r18
     cc0:	e2 f7       	brpl	.-8      	; 0xcba <DIO_voidSetPinDirection+0x174>
     cc2:	80 95       	com	r24
     cc4:	84 23       	and	r24, r20
     cc6:	8c 93       	st	X, r24
     cc8:	a1 e3       	ldi	r26, 0x31	; 49
     cca:	b0 e0       	ldi	r27, 0x00	; 0
     ccc:	e1 e3       	ldi	r30, 0x31	; 49
     cce:	f0 e0       	ldi	r31, 0x00	; 0
     cd0:	80 81       	ld	r24, Z
     cd2:	48 2f       	mov	r20, r24
     cd4:	8a 81       	ldd	r24, Y+2	; 0x02
     cd6:	28 2f       	mov	r18, r24
     cd8:	30 e0       	ldi	r19, 0x00	; 0
     cda:	89 81       	ldd	r24, Y+1	; 0x01
     cdc:	88 2f       	mov	r24, r24
     cde:	90 e0       	ldi	r25, 0x00	; 0
     ce0:	87 70       	andi	r24, 0x07	; 7
     ce2:	90 70       	andi	r25, 0x00	; 0
     ce4:	b9 01       	movw	r22, r18
     ce6:	02 c0       	rjmp	.+4      	; 0xcec <DIO_voidSetPinDirection+0x1a6>
     ce8:	66 0f       	add	r22, r22
     cea:	77 1f       	adc	r23, r23
     cec:	8a 95       	dec	r24
     cee:	e2 f7       	brpl	.-8      	; 0xce8 <DIO_voidSetPinDirection+0x1a2>
     cf0:	cb 01       	movw	r24, r22
     cf2:	84 2b       	or	r24, r20
     cf4:	8c 93       	st	X, r24
		}
	}
}
     cf6:	0f 90       	pop	r0
     cf8:	0f 90       	pop	r0
     cfa:	cf 91       	pop	r28
     cfc:	df 91       	pop	r29
     cfe:	08 95       	ret

00000d00 <DIO_voidSetPortDirection>:
 *
********************************************************************************************/


extern void DIO_voidSetPortDirection(u8 Copy_u8PortID, u8 Copy_u8PortValue)
{
     d00:	df 93       	push	r29
     d02:	cf 93       	push	r28
     d04:	00 d0       	rcall	.+0      	; 0xd06 <DIO_voidSetPortDirection+0x6>
     d06:	cd b7       	in	r28, 0x3d	; 61
     d08:	de b7       	in	r29, 0x3e	; 62
     d0a:	89 83       	std	Y+1, r24	; 0x01
     d0c:	6a 83       	std	Y+2, r22	; 0x02
	if(Copy_u8PortID==PORTA_ID)
     d0e:	89 81       	ldd	r24, Y+1	; 0x01
     d10:	88 23       	and	r24, r24
     d12:	29 f4       	brne	.+10     	; 0xd1e <DIO_voidSetPortDirection+0x1e>
	{
		DDRA=Copy_u8PortValue;
     d14:	ea e3       	ldi	r30, 0x3A	; 58
     d16:	f0 e0       	ldi	r31, 0x00	; 0
     d18:	8a 81       	ldd	r24, Y+2	; 0x02
     d1a:	80 83       	st	Z, r24
     d1c:	17 c0       	rjmp	.+46     	; 0xd4c <DIO_voidSetPortDirection+0x4c>
	}
	else if (Copy_u8PortID==PORTB_ID)
     d1e:	89 81       	ldd	r24, Y+1	; 0x01
     d20:	81 30       	cpi	r24, 0x01	; 1
     d22:	29 f4       	brne	.+10     	; 0xd2e <DIO_voidSetPortDirection+0x2e>
	{
		DDRB=Copy_u8PortValue;
     d24:	e7 e3       	ldi	r30, 0x37	; 55
     d26:	f0 e0       	ldi	r31, 0x00	; 0
     d28:	8a 81       	ldd	r24, Y+2	; 0x02
     d2a:	80 83       	st	Z, r24
     d2c:	0f c0       	rjmp	.+30     	; 0xd4c <DIO_voidSetPortDirection+0x4c>
	}
	else if (Copy_u8PortID==PORTC_ID)
     d2e:	89 81       	ldd	r24, Y+1	; 0x01
     d30:	82 30       	cpi	r24, 0x02	; 2
     d32:	29 f4       	brne	.+10     	; 0xd3e <DIO_voidSetPortDirection+0x3e>
	{
		DDRC=Copy_u8PortValue;
     d34:	e4 e3       	ldi	r30, 0x34	; 52
     d36:	f0 e0       	ldi	r31, 0x00	; 0
     d38:	8a 81       	ldd	r24, Y+2	; 0x02
     d3a:	80 83       	st	Z, r24
     d3c:	07 c0       	rjmp	.+14     	; 0xd4c <DIO_voidSetPortDirection+0x4c>
	}
	else if (Copy_u8PortID==PORTD_ID)
     d3e:	89 81       	ldd	r24, Y+1	; 0x01
     d40:	83 30       	cpi	r24, 0x03	; 3
     d42:	21 f4       	brne	.+8      	; 0xd4c <DIO_voidSetPortDirection+0x4c>
	{
		DDRD=Copy_u8PortValue;
     d44:	e1 e3       	ldi	r30, 0x31	; 49
     d46:	f0 e0       	ldi	r31, 0x00	; 0
     d48:	8a 81       	ldd	r24, Y+2	; 0x02
     d4a:	80 83       	st	Z, r24
	}
	else
	{

	}
}
     d4c:	0f 90       	pop	r0
     d4e:	0f 90       	pop	r0
     d50:	cf 91       	pop	r28
     d52:	df 91       	pop	r29
     d54:	08 95       	ret

00000d56 <DIO_voidWritePinValue>:
 *
 *
********************************************************************************************/

extern void DIO_voidWritePinValue(u8 Copy_u8PinNum, u8 Copy_u8PinValue)
{
     d56:	df 93       	push	r29
     d58:	cf 93       	push	r28
     d5a:	00 d0       	rcall	.+0      	; 0xd5c <DIO_voidWritePinValue+0x6>
     d5c:	cd b7       	in	r28, 0x3d	; 61
     d5e:	de b7       	in	r29, 0x3e	; 62
     d60:	89 83       	std	Y+1, r24	; 0x01
     d62:	6a 83       	std	Y+2, r22	; 0x02
	*the 1st one is the number of the PIN
	*the 2nd one is the value that needed to be assigned to the pre-specified PIN
	*	its return type is void that means it has no return value
	*/

	if( (Copy_u8PinNum>=0 && Copy_u8PinNum<=31) &&  (Copy_u8PinValue==0 || Copy_u8PinValue==1) )
     d64:	89 81       	ldd	r24, Y+1	; 0x01
     d66:	80 32       	cpi	r24, 0x20	; 32
     d68:	08 f0       	brcs	.+2      	; 0xd6c <DIO_voidWritePinValue+0x16>
     d6a:	cd c0       	rjmp	.+410    	; 0xf06 <DIO_voidWritePinValue+0x1b0>
     d6c:	8a 81       	ldd	r24, Y+2	; 0x02
     d6e:	88 23       	and	r24, r24
     d70:	21 f0       	breq	.+8      	; 0xd7a <DIO_voidWritePinValue+0x24>
     d72:	8a 81       	ldd	r24, Y+2	; 0x02
     d74:	81 30       	cpi	r24, 0x01	; 1
     d76:	09 f0       	breq	.+2      	; 0xd7a <DIO_voidWritePinValue+0x24>
     d78:	c6 c0       	rjmp	.+396    	; 0xf06 <DIO_voidWritePinValue+0x1b0>
	{
		//the switch case to specify which pin was selected by the user
		if((Copy_u8PinNum/8)==0)
     d7a:	89 81       	ldd	r24, Y+1	; 0x01
     d7c:	88 30       	cpi	r24, 0x08	; 8
     d7e:	70 f5       	brcc	.+92     	; 0xddc <DIO_voidWritePinValue+0x86>
		{
			assign_bit(PORTA,Copy_u8PinNum%8,Copy_u8PinValue);
     d80:	ab e3       	ldi	r26, 0x3B	; 59
     d82:	b0 e0       	ldi	r27, 0x00	; 0
     d84:	eb e3       	ldi	r30, 0x3B	; 59
     d86:	f0 e0       	ldi	r31, 0x00	; 0
     d88:	80 81       	ld	r24, Z
     d8a:	48 2f       	mov	r20, r24
     d8c:	89 81       	ldd	r24, Y+1	; 0x01
     d8e:	88 2f       	mov	r24, r24
     d90:	90 e0       	ldi	r25, 0x00	; 0
     d92:	9c 01       	movw	r18, r24
     d94:	27 70       	andi	r18, 0x07	; 7
     d96:	30 70       	andi	r19, 0x00	; 0
     d98:	81 e0       	ldi	r24, 0x01	; 1
     d9a:	90 e0       	ldi	r25, 0x00	; 0
     d9c:	02 c0       	rjmp	.+4      	; 0xda2 <DIO_voidWritePinValue+0x4c>
     d9e:	88 0f       	add	r24, r24
     da0:	99 1f       	adc	r25, r25
     da2:	2a 95       	dec	r18
     da4:	e2 f7       	brpl	.-8      	; 0xd9e <DIO_voidWritePinValue+0x48>
     da6:	80 95       	com	r24
     da8:	84 23       	and	r24, r20
     daa:	8c 93       	st	X, r24
     dac:	ab e3       	ldi	r26, 0x3B	; 59
     dae:	b0 e0       	ldi	r27, 0x00	; 0
     db0:	eb e3       	ldi	r30, 0x3B	; 59
     db2:	f0 e0       	ldi	r31, 0x00	; 0
     db4:	80 81       	ld	r24, Z
     db6:	48 2f       	mov	r20, r24
     db8:	8a 81       	ldd	r24, Y+2	; 0x02
     dba:	28 2f       	mov	r18, r24
     dbc:	30 e0       	ldi	r19, 0x00	; 0
     dbe:	89 81       	ldd	r24, Y+1	; 0x01
     dc0:	88 2f       	mov	r24, r24
     dc2:	90 e0       	ldi	r25, 0x00	; 0
     dc4:	87 70       	andi	r24, 0x07	; 7
     dc6:	90 70       	andi	r25, 0x00	; 0
     dc8:	b9 01       	movw	r22, r18
     dca:	02 c0       	rjmp	.+4      	; 0xdd0 <DIO_voidWritePinValue+0x7a>
     dcc:	66 0f       	add	r22, r22
     dce:	77 1f       	adc	r23, r23
     dd0:	8a 95       	dec	r24
     dd2:	e2 f7       	brpl	.-8      	; 0xdcc <DIO_voidWritePinValue+0x76>
     dd4:	cb 01       	movw	r24, r22
     dd6:	84 2b       	or	r24, r20
     dd8:	8c 93       	st	X, r24
     dda:	95 c0       	rjmp	.+298    	; 0xf06 <DIO_voidWritePinValue+0x1b0>
		}
		else if((Copy_u8PinNum/8)==1)
     ddc:	89 81       	ldd	r24, Y+1	; 0x01
     dde:	88 50       	subi	r24, 0x08	; 8
     de0:	88 30       	cpi	r24, 0x08	; 8
     de2:	70 f5       	brcc	.+92     	; 0xe40 <DIO_voidWritePinValue+0xea>
		{
			assign_bit(PORTB,Copy_u8PinNum%8,Copy_u8PinValue);
     de4:	a8 e3       	ldi	r26, 0x38	; 56
     de6:	b0 e0       	ldi	r27, 0x00	; 0
     de8:	e8 e3       	ldi	r30, 0x38	; 56
     dea:	f0 e0       	ldi	r31, 0x00	; 0
     dec:	80 81       	ld	r24, Z
     dee:	48 2f       	mov	r20, r24
     df0:	89 81       	ldd	r24, Y+1	; 0x01
     df2:	88 2f       	mov	r24, r24
     df4:	90 e0       	ldi	r25, 0x00	; 0
     df6:	9c 01       	movw	r18, r24
     df8:	27 70       	andi	r18, 0x07	; 7
     dfa:	30 70       	andi	r19, 0x00	; 0
     dfc:	81 e0       	ldi	r24, 0x01	; 1
     dfe:	90 e0       	ldi	r25, 0x00	; 0
     e00:	02 c0       	rjmp	.+4      	; 0xe06 <DIO_voidWritePinValue+0xb0>
     e02:	88 0f       	add	r24, r24
     e04:	99 1f       	adc	r25, r25
     e06:	2a 95       	dec	r18
     e08:	e2 f7       	brpl	.-8      	; 0xe02 <DIO_voidWritePinValue+0xac>
     e0a:	80 95       	com	r24
     e0c:	84 23       	and	r24, r20
     e0e:	8c 93       	st	X, r24
     e10:	a8 e3       	ldi	r26, 0x38	; 56
     e12:	b0 e0       	ldi	r27, 0x00	; 0
     e14:	e8 e3       	ldi	r30, 0x38	; 56
     e16:	f0 e0       	ldi	r31, 0x00	; 0
     e18:	80 81       	ld	r24, Z
     e1a:	48 2f       	mov	r20, r24
     e1c:	8a 81       	ldd	r24, Y+2	; 0x02
     e1e:	28 2f       	mov	r18, r24
     e20:	30 e0       	ldi	r19, 0x00	; 0
     e22:	89 81       	ldd	r24, Y+1	; 0x01
     e24:	88 2f       	mov	r24, r24
     e26:	90 e0       	ldi	r25, 0x00	; 0
     e28:	87 70       	andi	r24, 0x07	; 7
     e2a:	90 70       	andi	r25, 0x00	; 0
     e2c:	b9 01       	movw	r22, r18
     e2e:	02 c0       	rjmp	.+4      	; 0xe34 <DIO_voidWritePinValue+0xde>
     e30:	66 0f       	add	r22, r22
     e32:	77 1f       	adc	r23, r23
     e34:	8a 95       	dec	r24
     e36:	e2 f7       	brpl	.-8      	; 0xe30 <DIO_voidWritePinValue+0xda>
     e38:	cb 01       	movw	r24, r22
     e3a:	84 2b       	or	r24, r20
     e3c:	8c 93       	st	X, r24
     e3e:	63 c0       	rjmp	.+198    	; 0xf06 <DIO_voidWritePinValue+0x1b0>
		}
		else if((Copy_u8PinNum)/8==2)
     e40:	89 81       	ldd	r24, Y+1	; 0x01
     e42:	80 51       	subi	r24, 0x10	; 16
     e44:	88 30       	cpi	r24, 0x08	; 8
     e46:	70 f5       	brcc	.+92     	; 0xea4 <DIO_voidWritePinValue+0x14e>
		{
			assign_bit(PORTC,Copy_u8PinNum%8,Copy_u8PinValue);
     e48:	a5 e3       	ldi	r26, 0x35	; 53
     e4a:	b0 e0       	ldi	r27, 0x00	; 0
     e4c:	e5 e3       	ldi	r30, 0x35	; 53
     e4e:	f0 e0       	ldi	r31, 0x00	; 0
     e50:	80 81       	ld	r24, Z
     e52:	48 2f       	mov	r20, r24
     e54:	89 81       	ldd	r24, Y+1	; 0x01
     e56:	88 2f       	mov	r24, r24
     e58:	90 e0       	ldi	r25, 0x00	; 0
     e5a:	9c 01       	movw	r18, r24
     e5c:	27 70       	andi	r18, 0x07	; 7
     e5e:	30 70       	andi	r19, 0x00	; 0
     e60:	81 e0       	ldi	r24, 0x01	; 1
     e62:	90 e0       	ldi	r25, 0x00	; 0
     e64:	02 c0       	rjmp	.+4      	; 0xe6a <DIO_voidWritePinValue+0x114>
     e66:	88 0f       	add	r24, r24
     e68:	99 1f       	adc	r25, r25
     e6a:	2a 95       	dec	r18
     e6c:	e2 f7       	brpl	.-8      	; 0xe66 <DIO_voidWritePinValue+0x110>
     e6e:	80 95       	com	r24
     e70:	84 23       	and	r24, r20
     e72:	8c 93       	st	X, r24
     e74:	a5 e3       	ldi	r26, 0x35	; 53
     e76:	b0 e0       	ldi	r27, 0x00	; 0
     e78:	e5 e3       	ldi	r30, 0x35	; 53
     e7a:	f0 e0       	ldi	r31, 0x00	; 0
     e7c:	80 81       	ld	r24, Z
     e7e:	48 2f       	mov	r20, r24
     e80:	8a 81       	ldd	r24, Y+2	; 0x02
     e82:	28 2f       	mov	r18, r24
     e84:	30 e0       	ldi	r19, 0x00	; 0
     e86:	89 81       	ldd	r24, Y+1	; 0x01
     e88:	88 2f       	mov	r24, r24
     e8a:	90 e0       	ldi	r25, 0x00	; 0
     e8c:	87 70       	andi	r24, 0x07	; 7
     e8e:	90 70       	andi	r25, 0x00	; 0
     e90:	b9 01       	movw	r22, r18
     e92:	02 c0       	rjmp	.+4      	; 0xe98 <DIO_voidWritePinValue+0x142>
     e94:	66 0f       	add	r22, r22
     e96:	77 1f       	adc	r23, r23
     e98:	8a 95       	dec	r24
     e9a:	e2 f7       	brpl	.-8      	; 0xe94 <DIO_voidWritePinValue+0x13e>
     e9c:	cb 01       	movw	r24, r22
     e9e:	84 2b       	or	r24, r20
     ea0:	8c 93       	st	X, r24
     ea2:	31 c0       	rjmp	.+98     	; 0xf06 <DIO_voidWritePinValue+0x1b0>
		}
		else if((Copy_u8PinNum/8)==3)
     ea4:	89 81       	ldd	r24, Y+1	; 0x01
     ea6:	88 51       	subi	r24, 0x18	; 24
     ea8:	88 30       	cpi	r24, 0x08	; 8
     eaa:	68 f5       	brcc	.+90     	; 0xf06 <DIO_voidWritePinValue+0x1b0>
		{
			assign_bit(PORTD,Copy_u8PinNum%8,Copy_u8PinValue);
     eac:	a2 e3       	ldi	r26, 0x32	; 50
     eae:	b0 e0       	ldi	r27, 0x00	; 0
     eb0:	e2 e3       	ldi	r30, 0x32	; 50
     eb2:	f0 e0       	ldi	r31, 0x00	; 0
     eb4:	80 81       	ld	r24, Z
     eb6:	48 2f       	mov	r20, r24
     eb8:	89 81       	ldd	r24, Y+1	; 0x01
     eba:	88 2f       	mov	r24, r24
     ebc:	90 e0       	ldi	r25, 0x00	; 0
     ebe:	9c 01       	movw	r18, r24
     ec0:	27 70       	andi	r18, 0x07	; 7
     ec2:	30 70       	andi	r19, 0x00	; 0
     ec4:	81 e0       	ldi	r24, 0x01	; 1
     ec6:	90 e0       	ldi	r25, 0x00	; 0
     ec8:	02 c0       	rjmp	.+4      	; 0xece <DIO_voidWritePinValue+0x178>
     eca:	88 0f       	add	r24, r24
     ecc:	99 1f       	adc	r25, r25
     ece:	2a 95       	dec	r18
     ed0:	e2 f7       	brpl	.-8      	; 0xeca <DIO_voidWritePinValue+0x174>
     ed2:	80 95       	com	r24
     ed4:	84 23       	and	r24, r20
     ed6:	8c 93       	st	X, r24
     ed8:	a2 e3       	ldi	r26, 0x32	; 50
     eda:	b0 e0       	ldi	r27, 0x00	; 0
     edc:	e2 e3       	ldi	r30, 0x32	; 50
     ede:	f0 e0       	ldi	r31, 0x00	; 0
     ee0:	80 81       	ld	r24, Z
     ee2:	48 2f       	mov	r20, r24
     ee4:	8a 81       	ldd	r24, Y+2	; 0x02
     ee6:	28 2f       	mov	r18, r24
     ee8:	30 e0       	ldi	r19, 0x00	; 0
     eea:	89 81       	ldd	r24, Y+1	; 0x01
     eec:	88 2f       	mov	r24, r24
     eee:	90 e0       	ldi	r25, 0x00	; 0
     ef0:	87 70       	andi	r24, 0x07	; 7
     ef2:	90 70       	andi	r25, 0x00	; 0
     ef4:	b9 01       	movw	r22, r18
     ef6:	02 c0       	rjmp	.+4      	; 0xefc <DIO_voidWritePinValue+0x1a6>
     ef8:	66 0f       	add	r22, r22
     efa:	77 1f       	adc	r23, r23
     efc:	8a 95       	dec	r24
     efe:	e2 f7       	brpl	.-8      	; 0xef8 <DIO_voidWritePinValue+0x1a2>
     f00:	cb 01       	movw	r24, r22
     f02:	84 2b       	or	r24, r20
     f04:	8c 93       	st	X, r24
		}
	}

}
     f06:	0f 90       	pop	r0
     f08:	0f 90       	pop	r0
     f0a:	cf 91       	pop	r28
     f0c:	df 91       	pop	r29
     f0e:	08 95       	ret

00000f10 <DIO_voidWritePortValue>:

/***********************************************************************/

extern void DIO_voidWritePortValue(u8 Copy_u8PortID, u8 Copy_u8PortValue)
{
     f10:	df 93       	push	r29
     f12:	cf 93       	push	r28
     f14:	00 d0       	rcall	.+0      	; 0xf16 <DIO_voidWritePortValue+0x6>
     f16:	cd b7       	in	r28, 0x3d	; 61
     f18:	de b7       	in	r29, 0x3e	; 62
     f1a:	89 83       	std	Y+1, r24	; 0x01
     f1c:	6a 83       	std	Y+2, r22	; 0x02
	if(Copy_u8PortID==PORTA_ID)
     f1e:	89 81       	ldd	r24, Y+1	; 0x01
     f20:	88 23       	and	r24, r24
     f22:	29 f4       	brne	.+10     	; 0xf2e <DIO_voidWritePortValue+0x1e>
	{
		PORTA=Copy_u8PortValue;
     f24:	eb e3       	ldi	r30, 0x3B	; 59
     f26:	f0 e0       	ldi	r31, 0x00	; 0
     f28:	8a 81       	ldd	r24, Y+2	; 0x02
     f2a:	80 83       	st	Z, r24
     f2c:	17 c0       	rjmp	.+46     	; 0xf5c <DIO_voidWritePortValue+0x4c>
	}
	else if (Copy_u8PortID==PORTB_ID)
     f2e:	89 81       	ldd	r24, Y+1	; 0x01
     f30:	81 30       	cpi	r24, 0x01	; 1
     f32:	29 f4       	brne	.+10     	; 0xf3e <DIO_voidWritePortValue+0x2e>
	{
		PORTB=Copy_u8PortValue;
     f34:	e8 e3       	ldi	r30, 0x38	; 56
     f36:	f0 e0       	ldi	r31, 0x00	; 0
     f38:	8a 81       	ldd	r24, Y+2	; 0x02
     f3a:	80 83       	st	Z, r24
     f3c:	0f c0       	rjmp	.+30     	; 0xf5c <DIO_voidWritePortValue+0x4c>
	}
	else if (Copy_u8PortID==PORTC_ID)
     f3e:	89 81       	ldd	r24, Y+1	; 0x01
     f40:	82 30       	cpi	r24, 0x02	; 2
     f42:	29 f4       	brne	.+10     	; 0xf4e <DIO_voidWritePortValue+0x3e>
	{
		PORTC=Copy_u8PortValue;
     f44:	e5 e3       	ldi	r30, 0x35	; 53
     f46:	f0 e0       	ldi	r31, 0x00	; 0
     f48:	8a 81       	ldd	r24, Y+2	; 0x02
     f4a:	80 83       	st	Z, r24
     f4c:	07 c0       	rjmp	.+14     	; 0xf5c <DIO_voidWritePortValue+0x4c>
	}
	else if (Copy_u8PortID==PORTD_ID)
     f4e:	89 81       	ldd	r24, Y+1	; 0x01
     f50:	83 30       	cpi	r24, 0x03	; 3
     f52:	21 f4       	brne	.+8      	; 0xf5c <DIO_voidWritePortValue+0x4c>
	{
		PORTD=Copy_u8PortValue;
     f54:	e2 e3       	ldi	r30, 0x32	; 50
     f56:	f0 e0       	ldi	r31, 0x00	; 0
     f58:	8a 81       	ldd	r24, Y+2	; 0x02
     f5a:	80 83       	st	Z, r24
	}
	else
	{

	}
}
     f5c:	0f 90       	pop	r0
     f5e:	0f 90       	pop	r0
     f60:	cf 91       	pop	r28
     f62:	df 91       	pop	r29
     f64:	08 95       	ret

00000f66 <DIO_u8ReadPinValue>:

//=======================================================================================
extern u8 DIO_u8ReadPinValue(u8 Copy_u8PinNum)
{
     f66:	df 93       	push	r29
     f68:	cf 93       	push	r28
     f6a:	00 d0       	rcall	.+0      	; 0xf6c <DIO_u8ReadPinValue+0x6>
     f6c:	cd b7       	in	r28, 0x3d	; 61
     f6e:	de b7       	in	r29, 0x3e	; 62
     f70:	8a 83       	std	Y+2, r24	; 0x02
		*	its return type is u8 that means it has a return value with data type (u8)
		*/

	//a u8 variable to store the read value and return it
	u8 Local_u8ReturnValue;
	if( Copy_u8PinNum>=0 && Copy_u8PinNum<=31)
     f72:	8a 81       	ldd	r24, Y+2	; 0x02
     f74:	80 32       	cpi	r24, 0x20	; 32
     f76:	08 f0       	brcs	.+2      	; 0xf7a <DIO_u8ReadPinValue+0x14>
     f78:	9a c0       	rjmp	.+308    	; 0x10ae <DIO_u8ReadPinValue+0x148>
		{
			if(Copy_u8PinNum/8==0)
     f7a:	8a 81       	ldd	r24, Y+2	; 0x02
     f7c:	88 30       	cpi	r24, 0x08	; 8
     f7e:	18 f5       	brcc	.+70     	; 0xfc6 <DIO_u8ReadPinValue+0x60>
			{
				Local_u8ReturnValue=get_bit(PINA,Copy_u8PinNum%8);
     f80:	e9 e3       	ldi	r30, 0x39	; 57
     f82:	f0 e0       	ldi	r31, 0x00	; 0
     f84:	80 81       	ld	r24, Z
     f86:	48 2f       	mov	r20, r24
     f88:	50 e0       	ldi	r21, 0x00	; 0
     f8a:	8a 81       	ldd	r24, Y+2	; 0x02
     f8c:	88 2f       	mov	r24, r24
     f8e:	90 e0       	ldi	r25, 0x00	; 0
     f90:	9c 01       	movw	r18, r24
     f92:	27 70       	andi	r18, 0x07	; 7
     f94:	30 70       	andi	r19, 0x00	; 0
     f96:	81 e0       	ldi	r24, 0x01	; 1
     f98:	90 e0       	ldi	r25, 0x00	; 0
     f9a:	02 c0       	rjmp	.+4      	; 0xfa0 <DIO_u8ReadPinValue+0x3a>
     f9c:	88 0f       	add	r24, r24
     f9e:	99 1f       	adc	r25, r25
     fa0:	2a 95       	dec	r18
     fa2:	e2 f7       	brpl	.-8      	; 0xf9c <DIO_u8ReadPinValue+0x36>
     fa4:	9a 01       	movw	r18, r20
     fa6:	28 23       	and	r18, r24
     fa8:	39 23       	and	r19, r25
     faa:	8a 81       	ldd	r24, Y+2	; 0x02
     fac:	88 2f       	mov	r24, r24
     fae:	90 e0       	ldi	r25, 0x00	; 0
     fb0:	87 70       	andi	r24, 0x07	; 7
     fb2:	90 70       	andi	r25, 0x00	; 0
     fb4:	a9 01       	movw	r20, r18
     fb6:	02 c0       	rjmp	.+4      	; 0xfbc <DIO_u8ReadPinValue+0x56>
     fb8:	55 95       	asr	r21
     fba:	47 95       	ror	r20
     fbc:	8a 95       	dec	r24
     fbe:	e2 f7       	brpl	.-8      	; 0xfb8 <DIO_u8ReadPinValue+0x52>
     fc0:	ca 01       	movw	r24, r20
     fc2:	89 83       	std	Y+1, r24	; 0x01
     fc4:	74 c0       	rjmp	.+232    	; 0x10ae <DIO_u8ReadPinValue+0x148>
			}
			else if(Copy_u8PinNum/8==1)
     fc6:	8a 81       	ldd	r24, Y+2	; 0x02
     fc8:	88 50       	subi	r24, 0x08	; 8
     fca:	88 30       	cpi	r24, 0x08	; 8
     fcc:	18 f5       	brcc	.+70     	; 0x1014 <DIO_u8ReadPinValue+0xae>
			{
				Local_u8ReturnValue=get_bit(PINB,Copy_u8PinNum%8);
     fce:	e6 e3       	ldi	r30, 0x36	; 54
     fd0:	f0 e0       	ldi	r31, 0x00	; 0
     fd2:	80 81       	ld	r24, Z
     fd4:	48 2f       	mov	r20, r24
     fd6:	50 e0       	ldi	r21, 0x00	; 0
     fd8:	8a 81       	ldd	r24, Y+2	; 0x02
     fda:	88 2f       	mov	r24, r24
     fdc:	90 e0       	ldi	r25, 0x00	; 0
     fde:	9c 01       	movw	r18, r24
     fe0:	27 70       	andi	r18, 0x07	; 7
     fe2:	30 70       	andi	r19, 0x00	; 0
     fe4:	81 e0       	ldi	r24, 0x01	; 1
     fe6:	90 e0       	ldi	r25, 0x00	; 0
     fe8:	02 c0       	rjmp	.+4      	; 0xfee <DIO_u8ReadPinValue+0x88>
     fea:	88 0f       	add	r24, r24
     fec:	99 1f       	adc	r25, r25
     fee:	2a 95       	dec	r18
     ff0:	e2 f7       	brpl	.-8      	; 0xfea <DIO_u8ReadPinValue+0x84>
     ff2:	9a 01       	movw	r18, r20
     ff4:	28 23       	and	r18, r24
     ff6:	39 23       	and	r19, r25
     ff8:	8a 81       	ldd	r24, Y+2	; 0x02
     ffa:	88 2f       	mov	r24, r24
     ffc:	90 e0       	ldi	r25, 0x00	; 0
     ffe:	87 70       	andi	r24, 0x07	; 7
    1000:	90 70       	andi	r25, 0x00	; 0
    1002:	a9 01       	movw	r20, r18
    1004:	02 c0       	rjmp	.+4      	; 0x100a <DIO_u8ReadPinValue+0xa4>
    1006:	55 95       	asr	r21
    1008:	47 95       	ror	r20
    100a:	8a 95       	dec	r24
    100c:	e2 f7       	brpl	.-8      	; 0x1006 <DIO_u8ReadPinValue+0xa0>
    100e:	ca 01       	movw	r24, r20
    1010:	89 83       	std	Y+1, r24	; 0x01
    1012:	4d c0       	rjmp	.+154    	; 0x10ae <DIO_u8ReadPinValue+0x148>
			}
			else if(Copy_u8PinNum/8==2)
    1014:	8a 81       	ldd	r24, Y+2	; 0x02
    1016:	80 51       	subi	r24, 0x10	; 16
    1018:	88 30       	cpi	r24, 0x08	; 8
    101a:	18 f5       	brcc	.+70     	; 0x1062 <DIO_u8ReadPinValue+0xfc>
			{
				Local_u8ReturnValue=get_bit(PINC,Copy_u8PinNum%8);
    101c:	e3 e3       	ldi	r30, 0x33	; 51
    101e:	f0 e0       	ldi	r31, 0x00	; 0
    1020:	80 81       	ld	r24, Z
    1022:	48 2f       	mov	r20, r24
    1024:	50 e0       	ldi	r21, 0x00	; 0
    1026:	8a 81       	ldd	r24, Y+2	; 0x02
    1028:	88 2f       	mov	r24, r24
    102a:	90 e0       	ldi	r25, 0x00	; 0
    102c:	9c 01       	movw	r18, r24
    102e:	27 70       	andi	r18, 0x07	; 7
    1030:	30 70       	andi	r19, 0x00	; 0
    1032:	81 e0       	ldi	r24, 0x01	; 1
    1034:	90 e0       	ldi	r25, 0x00	; 0
    1036:	02 c0       	rjmp	.+4      	; 0x103c <DIO_u8ReadPinValue+0xd6>
    1038:	88 0f       	add	r24, r24
    103a:	99 1f       	adc	r25, r25
    103c:	2a 95       	dec	r18
    103e:	e2 f7       	brpl	.-8      	; 0x1038 <DIO_u8ReadPinValue+0xd2>
    1040:	9a 01       	movw	r18, r20
    1042:	28 23       	and	r18, r24
    1044:	39 23       	and	r19, r25
    1046:	8a 81       	ldd	r24, Y+2	; 0x02
    1048:	88 2f       	mov	r24, r24
    104a:	90 e0       	ldi	r25, 0x00	; 0
    104c:	87 70       	andi	r24, 0x07	; 7
    104e:	90 70       	andi	r25, 0x00	; 0
    1050:	a9 01       	movw	r20, r18
    1052:	02 c0       	rjmp	.+4      	; 0x1058 <DIO_u8ReadPinValue+0xf2>
    1054:	55 95       	asr	r21
    1056:	47 95       	ror	r20
    1058:	8a 95       	dec	r24
    105a:	e2 f7       	brpl	.-8      	; 0x1054 <DIO_u8ReadPinValue+0xee>
    105c:	ca 01       	movw	r24, r20
    105e:	89 83       	std	Y+1, r24	; 0x01
    1060:	26 c0       	rjmp	.+76     	; 0x10ae <DIO_u8ReadPinValue+0x148>
			}
			else if(Copy_u8PinNum/8==3)
    1062:	8a 81       	ldd	r24, Y+2	; 0x02
    1064:	88 51       	subi	r24, 0x18	; 24
    1066:	88 30       	cpi	r24, 0x08	; 8
    1068:	10 f5       	brcc	.+68     	; 0x10ae <DIO_u8ReadPinValue+0x148>
			{
				Local_u8ReturnValue=get_bit(PIND,Copy_u8PinNum%8);
    106a:	e0 e3       	ldi	r30, 0x30	; 48
    106c:	f0 e0       	ldi	r31, 0x00	; 0
    106e:	80 81       	ld	r24, Z
    1070:	48 2f       	mov	r20, r24
    1072:	50 e0       	ldi	r21, 0x00	; 0
    1074:	8a 81       	ldd	r24, Y+2	; 0x02
    1076:	88 2f       	mov	r24, r24
    1078:	90 e0       	ldi	r25, 0x00	; 0
    107a:	9c 01       	movw	r18, r24
    107c:	27 70       	andi	r18, 0x07	; 7
    107e:	30 70       	andi	r19, 0x00	; 0
    1080:	81 e0       	ldi	r24, 0x01	; 1
    1082:	90 e0       	ldi	r25, 0x00	; 0
    1084:	02 c0       	rjmp	.+4      	; 0x108a <DIO_u8ReadPinValue+0x124>
    1086:	88 0f       	add	r24, r24
    1088:	99 1f       	adc	r25, r25
    108a:	2a 95       	dec	r18
    108c:	e2 f7       	brpl	.-8      	; 0x1086 <DIO_u8ReadPinValue+0x120>
    108e:	9a 01       	movw	r18, r20
    1090:	28 23       	and	r18, r24
    1092:	39 23       	and	r19, r25
    1094:	8a 81       	ldd	r24, Y+2	; 0x02
    1096:	88 2f       	mov	r24, r24
    1098:	90 e0       	ldi	r25, 0x00	; 0
    109a:	87 70       	andi	r24, 0x07	; 7
    109c:	90 70       	andi	r25, 0x00	; 0
    109e:	a9 01       	movw	r20, r18
    10a0:	02 c0       	rjmp	.+4      	; 0x10a6 <DIO_u8ReadPinValue+0x140>
    10a2:	55 95       	asr	r21
    10a4:	47 95       	ror	r20
    10a6:	8a 95       	dec	r24
    10a8:	e2 f7       	brpl	.-8      	; 0x10a2 <DIO_u8ReadPinValue+0x13c>
    10aa:	ca 01       	movw	r24, r20
    10ac:	89 83       	std	Y+1, r24	; 0x01
			}
		}

	//return the output of the selected pin
	return Local_u8ReturnValue;
    10ae:	89 81       	ldd	r24, Y+1	; 0x01
}
    10b0:	0f 90       	pop	r0
    10b2:	0f 90       	pop	r0
    10b4:	cf 91       	pop	r28
    10b6:	df 91       	pop	r29
    10b8:	08 95       	ret

000010ba <DIO_u8ReadPortValue>:

/*******************************************************************************************/
extern u8 DIO_u8ReadPortValue(u8 Copy_u8PortID)
{
    10ba:	df 93       	push	r29
    10bc:	cf 93       	push	r28
    10be:	00 d0       	rcall	.+0      	; 0x10c0 <DIO_u8ReadPortValue+0x6>
    10c0:	cd b7       	in	r28, 0x3d	; 61
    10c2:	de b7       	in	r29, 0x3e	; 62
    10c4:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_u8PortID==PORTA_ID)
    10c6:	89 81       	ldd	r24, Y+1	; 0x01
    10c8:	88 23       	and	r24, r24
    10ca:	29 f4       	brne	.+10     	; 0x10d6 <DIO_u8ReadPortValue+0x1c>
	{
		return PINA;
    10cc:	e9 e3       	ldi	r30, 0x39	; 57
    10ce:	f0 e0       	ldi	r31, 0x00	; 0
    10d0:	80 81       	ld	r24, Z
    10d2:	8a 83       	std	Y+2, r24	; 0x02
    10d4:	1a c0       	rjmp	.+52     	; 0x110a <DIO_u8ReadPortValue+0x50>
	}
	else if (Copy_u8PortID==PORTB_ID)
    10d6:	89 81       	ldd	r24, Y+1	; 0x01
    10d8:	81 30       	cpi	r24, 0x01	; 1
    10da:	29 f4       	brne	.+10     	; 0x10e6 <DIO_u8ReadPortValue+0x2c>
	{
		return PINB;
    10dc:	e6 e3       	ldi	r30, 0x36	; 54
    10de:	f0 e0       	ldi	r31, 0x00	; 0
    10e0:	80 81       	ld	r24, Z
    10e2:	8a 83       	std	Y+2, r24	; 0x02
    10e4:	12 c0       	rjmp	.+36     	; 0x110a <DIO_u8ReadPortValue+0x50>
	}
	else if (Copy_u8PortID==PORTC_ID)
    10e6:	89 81       	ldd	r24, Y+1	; 0x01
    10e8:	82 30       	cpi	r24, 0x02	; 2
    10ea:	29 f4       	brne	.+10     	; 0x10f6 <DIO_u8ReadPortValue+0x3c>
	{
		return PINC;
    10ec:	e3 e3       	ldi	r30, 0x33	; 51
    10ee:	f0 e0       	ldi	r31, 0x00	; 0
    10f0:	80 81       	ld	r24, Z
    10f2:	8a 83       	std	Y+2, r24	; 0x02
    10f4:	0a c0       	rjmp	.+20     	; 0x110a <DIO_u8ReadPortValue+0x50>
	}
	else if (Copy_u8PortID==PORTD_ID)
    10f6:	89 81       	ldd	r24, Y+1	; 0x01
    10f8:	83 30       	cpi	r24, 0x03	; 3
    10fa:	29 f4       	brne	.+10     	; 0x1106 <DIO_u8ReadPortValue+0x4c>
	{
		return PIND;
    10fc:	e0 e3       	ldi	r30, 0x30	; 48
    10fe:	f0 e0       	ldi	r31, 0x00	; 0
    1100:	80 81       	ld	r24, Z
    1102:	8a 83       	std	Y+2, r24	; 0x02
    1104:	02 c0       	rjmp	.+4      	; 0x110a <DIO_u8ReadPortValue+0x50>
	}
	else
	{
	}
	return -1;
    1106:	8f ef       	ldi	r24, 0xFF	; 255
    1108:	8a 83       	std	Y+2, r24	; 0x02
    110a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    110c:	0f 90       	pop	r0
    110e:	0f 90       	pop	r0
    1110:	cf 91       	pop	r28
    1112:	df 91       	pop	r29
    1114:	08 95       	ret

00001116 <LCD_voidInit>:
#include "DIO.h"
#include "LCD.h"
#include "FreeRTOS.h"

extern void LCD_voidInit(void)
{
    1116:	df 93       	push	r29
    1118:	cf 93       	push	r28
    111a:	cd b7       	in	r28, 0x3d	; 61
    111c:	de b7       	in	r29, 0x3e	; 62
    111e:	e8 97       	sbiw	r28, 0x38	; 56
    1120:	0f b6       	in	r0, 0x3f	; 63
    1122:	f8 94       	cli
    1124:	de bf       	out	0x3e, r29	; 62
    1126:	0f be       	out	0x3f, r0	; 63
    1128:	cd bf       	out	0x3d, r28	; 61

	//RS pin
	DIO_voidSetPinDirection(LCD_RS,DIO_u8PinOp);
    112a:	80 e0       	ldi	r24, 0x00	; 0
    112c:	61 e0       	ldi	r22, 0x01	; 1
    112e:	0e 94 a3 05 	call	0xb46	; 0xb46 <DIO_voidSetPinDirection>
	//RW pin
	DIO_voidSetPinDirection(LCD_RW,DIO_u8PinOp);
    1132:	81 e0       	ldi	r24, 0x01	; 1
    1134:	61 e0       	ldi	r22, 0x01	; 1
    1136:	0e 94 a3 05 	call	0xb46	; 0xb46 <DIO_voidSetPinDirection>
	//En pin
	DIO_voidSetPinDirection(LCD_E,DIO_u8PinOp);
    113a:	82 e0       	ldi	r24, 0x02	; 2
    113c:	61 e0       	ldi	r22, 0x01	; 1
    113e:	0e 94 a3 05 	call	0xb46	; 0xb46 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(LCD_D4,DIO_u8PinOp);
	DIO_voidSetPinDirection(LCD_D5,DIO_u8PinOp);
	DIO_voidSetPinDirection(LCD_D6,DIO_u8PinOp);
	DIO_voidSetPinDirection(LCD_D7,DIO_u8PinOp);
*/
	DIO_voidSetPortDirection(LCD_Data_Port,255);
    1142:	82 e0       	ldi	r24, 0x02	; 2
    1144:	6f ef       	ldi	r22, 0xFF	; 255
    1146:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_voidSetPortDirection>
    114a:	80 e0       	ldi	r24, 0x00	; 0
    114c:	90 e0       	ldi	r25, 0x00	; 0
    114e:	a8 e4       	ldi	r26, 0x48	; 72
    1150:	b2 e4       	ldi	r27, 0x42	; 66
    1152:	8d ab       	std	Y+53, r24	; 0x35
    1154:	9e ab       	std	Y+54, r25	; 0x36
    1156:	af ab       	std	Y+55, r26	; 0x37
    1158:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    115a:	6d a9       	ldd	r22, Y+53	; 0x35
    115c:	7e a9       	ldd	r23, Y+54	; 0x36
    115e:	8f a9       	ldd	r24, Y+55	; 0x37
    1160:	98 ad       	ldd	r25, Y+56	; 0x38
    1162:	20 e0       	ldi	r18, 0x00	; 0
    1164:	30 e8       	ldi	r19, 0x80	; 128
    1166:	4b e3       	ldi	r20, 0x3B	; 59
    1168:	55 e4       	ldi	r21, 0x45	; 69
    116a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    116e:	dc 01       	movw	r26, r24
    1170:	cb 01       	movw	r24, r22
    1172:	89 ab       	std	Y+49, r24	; 0x31
    1174:	9a ab       	std	Y+50, r25	; 0x32
    1176:	ab ab       	std	Y+51, r26	; 0x33
    1178:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    117a:	69 a9       	ldd	r22, Y+49	; 0x31
    117c:	7a a9       	ldd	r23, Y+50	; 0x32
    117e:	8b a9       	ldd	r24, Y+51	; 0x33
    1180:	9c a9       	ldd	r25, Y+52	; 0x34
    1182:	20 e0       	ldi	r18, 0x00	; 0
    1184:	30 e0       	ldi	r19, 0x00	; 0
    1186:	40 e8       	ldi	r20, 0x80	; 128
    1188:	5f e3       	ldi	r21, 0x3F	; 63
    118a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    118e:	88 23       	and	r24, r24
    1190:	2c f4       	brge	.+10     	; 0x119c <LCD_voidInit+0x86>
		__ticks = 1;
    1192:	81 e0       	ldi	r24, 0x01	; 1
    1194:	90 e0       	ldi	r25, 0x00	; 0
    1196:	98 ab       	std	Y+48, r25	; 0x30
    1198:	8f a7       	std	Y+47, r24	; 0x2f
    119a:	3f c0       	rjmp	.+126    	; 0x121a <LCD_voidInit+0x104>
	else if (__tmp > 65535)
    119c:	69 a9       	ldd	r22, Y+49	; 0x31
    119e:	7a a9       	ldd	r23, Y+50	; 0x32
    11a0:	8b a9       	ldd	r24, Y+51	; 0x33
    11a2:	9c a9       	ldd	r25, Y+52	; 0x34
    11a4:	20 e0       	ldi	r18, 0x00	; 0
    11a6:	3f ef       	ldi	r19, 0xFF	; 255
    11a8:	4f e7       	ldi	r20, 0x7F	; 127
    11aa:	57 e4       	ldi	r21, 0x47	; 71
    11ac:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    11b0:	18 16       	cp	r1, r24
    11b2:	4c f5       	brge	.+82     	; 0x1206 <LCD_voidInit+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    11b4:	6d a9       	ldd	r22, Y+53	; 0x35
    11b6:	7e a9       	ldd	r23, Y+54	; 0x36
    11b8:	8f a9       	ldd	r24, Y+55	; 0x37
    11ba:	98 ad       	ldd	r25, Y+56	; 0x38
    11bc:	20 e0       	ldi	r18, 0x00	; 0
    11be:	30 e0       	ldi	r19, 0x00	; 0
    11c0:	40 e2       	ldi	r20, 0x20	; 32
    11c2:	51 e4       	ldi	r21, 0x41	; 65
    11c4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    11c8:	dc 01       	movw	r26, r24
    11ca:	cb 01       	movw	r24, r22
    11cc:	bc 01       	movw	r22, r24
    11ce:	cd 01       	movw	r24, r26
    11d0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    11d4:	dc 01       	movw	r26, r24
    11d6:	cb 01       	movw	r24, r22
    11d8:	98 ab       	std	Y+48, r25	; 0x30
    11da:	8f a7       	std	Y+47, r24	; 0x2f
    11dc:	0f c0       	rjmp	.+30     	; 0x11fc <LCD_voidInit+0xe6>
    11de:	8c e2       	ldi	r24, 0x2C	; 44
    11e0:	91 e0       	ldi	r25, 0x01	; 1
    11e2:	9e a7       	std	Y+46, r25	; 0x2e
    11e4:	8d a7       	std	Y+45, r24	; 0x2d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    11e6:	8d a5       	ldd	r24, Y+45	; 0x2d
    11e8:	9e a5       	ldd	r25, Y+46	; 0x2e
    11ea:	01 97       	sbiw	r24, 0x01	; 1
    11ec:	f1 f7       	brne	.-4      	; 0x11ea <LCD_voidInit+0xd4>
    11ee:	9e a7       	std	Y+46, r25	; 0x2e
    11f0:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    11f2:	8f a5       	ldd	r24, Y+47	; 0x2f
    11f4:	98 a9       	ldd	r25, Y+48	; 0x30
    11f6:	01 97       	sbiw	r24, 0x01	; 1
    11f8:	98 ab       	std	Y+48, r25	; 0x30
    11fa:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    11fc:	8f a5       	ldd	r24, Y+47	; 0x2f
    11fe:	98 a9       	ldd	r25, Y+48	; 0x30
    1200:	00 97       	sbiw	r24, 0x00	; 0
    1202:	69 f7       	brne	.-38     	; 0x11de <LCD_voidInit+0xc8>
    1204:	14 c0       	rjmp	.+40     	; 0x122e <LCD_voidInit+0x118>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1206:	69 a9       	ldd	r22, Y+49	; 0x31
    1208:	7a a9       	ldd	r23, Y+50	; 0x32
    120a:	8b a9       	ldd	r24, Y+51	; 0x33
    120c:	9c a9       	ldd	r25, Y+52	; 0x34
    120e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1212:	dc 01       	movw	r26, r24
    1214:	cb 01       	movw	r24, r22
    1216:	98 ab       	std	Y+48, r25	; 0x30
    1218:	8f a7       	std	Y+47, r24	; 0x2f
    121a:	8f a5       	ldd	r24, Y+47	; 0x2f
    121c:	98 a9       	ldd	r25, Y+48	; 0x30
    121e:	9c a7       	std	Y+44, r25	; 0x2c
    1220:	8b a7       	std	Y+43, r24	; 0x2b
    1222:	8b a5       	ldd	r24, Y+43	; 0x2b
    1224:	9c a5       	ldd	r25, Y+44	; 0x2c
    1226:	01 97       	sbiw	r24, 0x01	; 1
    1228:	f1 f7       	brne	.-4      	; 0x1226 <LCD_voidInit+0x110>
    122a:	9c a7       	std	Y+44, r25	; 0x2c
    122c:	8b a7       	std	Y+43, r24	; 0x2b
//	DIO_voidSetPortDirection(LCD_Data_Port,255);

	//1) wait for 4.5 ms => delay 50 ms
	_delay_ms(50);
	//write command 0b00111000; 	DB3(0:one line && 1:two lines)
	LCD_voidWriteCommand(0b00111000);
    122e:	88 e3       	ldi	r24, 0x38	; 56
    1230:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_voidWriteCommand>
    1234:	80 e0       	ldi	r24, 0x00	; 0
    1236:	90 e0       	ldi	r25, 0x00	; 0
    1238:	a0 e8       	ldi	r26, 0x80	; 128
    123a:	bf e3       	ldi	r27, 0x3F	; 63
    123c:	8f a3       	std	Y+39, r24	; 0x27
    123e:	98 a7       	std	Y+40, r25	; 0x28
    1240:	a9 a7       	std	Y+41, r26	; 0x29
    1242:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1244:	6f a1       	ldd	r22, Y+39	; 0x27
    1246:	78 a5       	ldd	r23, Y+40	; 0x28
    1248:	89 a5       	ldd	r24, Y+41	; 0x29
    124a:	9a a5       	ldd	r25, Y+42	; 0x2a
    124c:	20 e0       	ldi	r18, 0x00	; 0
    124e:	30 e8       	ldi	r19, 0x80	; 128
    1250:	4b e3       	ldi	r20, 0x3B	; 59
    1252:	55 e4       	ldi	r21, 0x45	; 69
    1254:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1258:	dc 01       	movw	r26, r24
    125a:	cb 01       	movw	r24, r22
    125c:	8b a3       	std	Y+35, r24	; 0x23
    125e:	9c a3       	std	Y+36, r25	; 0x24
    1260:	ad a3       	std	Y+37, r26	; 0x25
    1262:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1264:	6b a1       	ldd	r22, Y+35	; 0x23
    1266:	7c a1       	ldd	r23, Y+36	; 0x24
    1268:	8d a1       	ldd	r24, Y+37	; 0x25
    126a:	9e a1       	ldd	r25, Y+38	; 0x26
    126c:	20 e0       	ldi	r18, 0x00	; 0
    126e:	30 e0       	ldi	r19, 0x00	; 0
    1270:	40 e8       	ldi	r20, 0x80	; 128
    1272:	5f e3       	ldi	r21, 0x3F	; 63
    1274:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1278:	88 23       	and	r24, r24
    127a:	2c f4       	brge	.+10     	; 0x1286 <LCD_voidInit+0x170>
		__ticks = 1;
    127c:	81 e0       	ldi	r24, 0x01	; 1
    127e:	90 e0       	ldi	r25, 0x00	; 0
    1280:	9a a3       	std	Y+34, r25	; 0x22
    1282:	89 a3       	std	Y+33, r24	; 0x21
    1284:	3f c0       	rjmp	.+126    	; 0x1304 <LCD_voidInit+0x1ee>
	else if (__tmp > 65535)
    1286:	6b a1       	ldd	r22, Y+35	; 0x23
    1288:	7c a1       	ldd	r23, Y+36	; 0x24
    128a:	8d a1       	ldd	r24, Y+37	; 0x25
    128c:	9e a1       	ldd	r25, Y+38	; 0x26
    128e:	20 e0       	ldi	r18, 0x00	; 0
    1290:	3f ef       	ldi	r19, 0xFF	; 255
    1292:	4f e7       	ldi	r20, 0x7F	; 127
    1294:	57 e4       	ldi	r21, 0x47	; 71
    1296:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    129a:	18 16       	cp	r1, r24
    129c:	4c f5       	brge	.+82     	; 0x12f0 <LCD_voidInit+0x1da>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    129e:	6f a1       	ldd	r22, Y+39	; 0x27
    12a0:	78 a5       	ldd	r23, Y+40	; 0x28
    12a2:	89 a5       	ldd	r24, Y+41	; 0x29
    12a4:	9a a5       	ldd	r25, Y+42	; 0x2a
    12a6:	20 e0       	ldi	r18, 0x00	; 0
    12a8:	30 e0       	ldi	r19, 0x00	; 0
    12aa:	40 e2       	ldi	r20, 0x20	; 32
    12ac:	51 e4       	ldi	r21, 0x41	; 65
    12ae:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    12b2:	dc 01       	movw	r26, r24
    12b4:	cb 01       	movw	r24, r22
    12b6:	bc 01       	movw	r22, r24
    12b8:	cd 01       	movw	r24, r26
    12ba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    12be:	dc 01       	movw	r26, r24
    12c0:	cb 01       	movw	r24, r22
    12c2:	9a a3       	std	Y+34, r25	; 0x22
    12c4:	89 a3       	std	Y+33, r24	; 0x21
    12c6:	0f c0       	rjmp	.+30     	; 0x12e6 <LCD_voidInit+0x1d0>
    12c8:	8c e2       	ldi	r24, 0x2C	; 44
    12ca:	91 e0       	ldi	r25, 0x01	; 1
    12cc:	98 a3       	std	Y+32, r25	; 0x20
    12ce:	8f 8f       	std	Y+31, r24	; 0x1f
    12d0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    12d2:	98 a1       	ldd	r25, Y+32	; 0x20
    12d4:	01 97       	sbiw	r24, 0x01	; 1
    12d6:	f1 f7       	brne	.-4      	; 0x12d4 <LCD_voidInit+0x1be>
    12d8:	98 a3       	std	Y+32, r25	; 0x20
    12da:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    12dc:	89 a1       	ldd	r24, Y+33	; 0x21
    12de:	9a a1       	ldd	r25, Y+34	; 0x22
    12e0:	01 97       	sbiw	r24, 0x01	; 1
    12e2:	9a a3       	std	Y+34, r25	; 0x22
    12e4:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    12e6:	89 a1       	ldd	r24, Y+33	; 0x21
    12e8:	9a a1       	ldd	r25, Y+34	; 0x22
    12ea:	00 97       	sbiw	r24, 0x00	; 0
    12ec:	69 f7       	brne	.-38     	; 0x12c8 <LCD_voidInit+0x1b2>
    12ee:	14 c0       	rjmp	.+40     	; 0x1318 <LCD_voidInit+0x202>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    12f0:	6b a1       	ldd	r22, Y+35	; 0x23
    12f2:	7c a1       	ldd	r23, Y+36	; 0x24
    12f4:	8d a1       	ldd	r24, Y+37	; 0x25
    12f6:	9e a1       	ldd	r25, Y+38	; 0x26
    12f8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    12fc:	dc 01       	movw	r26, r24
    12fe:	cb 01       	movw	r24, r22
    1300:	9a a3       	std	Y+34, r25	; 0x22
    1302:	89 a3       	std	Y+33, r24	; 0x21
    1304:	89 a1       	ldd	r24, Y+33	; 0x21
    1306:	9a a1       	ldd	r25, Y+34	; 0x22
    1308:	9e 8f       	std	Y+30, r25	; 0x1e
    130a:	8d 8f       	std	Y+29, r24	; 0x1d
    130c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    130e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1310:	01 97       	sbiw	r24, 0x01	; 1
    1312:	f1 f7       	brne	.-4      	; 0x1310 <LCD_voidInit+0x1fa>
    1314:	9e 8f       	std	Y+30, r25	; 0x1e
    1316:	8d 8f       	std	Y+29, r24	; 0x1d
	//DElay 1ms
	_delay_ms(1);
	//write command 0b00001100
	LCD_voidWriteCommand(0b00001110);
    1318:	8e e0       	ldi	r24, 0x0E	; 14
    131a:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_voidWriteCommand>
    131e:	80 e0       	ldi	r24, 0x00	; 0
    1320:	90 e0       	ldi	r25, 0x00	; 0
    1322:	a0 e8       	ldi	r26, 0x80	; 128
    1324:	bf e3       	ldi	r27, 0x3F	; 63
    1326:	89 8f       	std	Y+25, r24	; 0x19
    1328:	9a 8f       	std	Y+26, r25	; 0x1a
    132a:	ab 8f       	std	Y+27, r26	; 0x1b
    132c:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    132e:	69 8d       	ldd	r22, Y+25	; 0x19
    1330:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1332:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1334:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1336:	20 e0       	ldi	r18, 0x00	; 0
    1338:	30 e8       	ldi	r19, 0x80	; 128
    133a:	4b e3       	ldi	r20, 0x3B	; 59
    133c:	55 e4       	ldi	r21, 0x45	; 69
    133e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1342:	dc 01       	movw	r26, r24
    1344:	cb 01       	movw	r24, r22
    1346:	8d 8b       	std	Y+21, r24	; 0x15
    1348:	9e 8b       	std	Y+22, r25	; 0x16
    134a:	af 8b       	std	Y+23, r26	; 0x17
    134c:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    134e:	6d 89       	ldd	r22, Y+21	; 0x15
    1350:	7e 89       	ldd	r23, Y+22	; 0x16
    1352:	8f 89       	ldd	r24, Y+23	; 0x17
    1354:	98 8d       	ldd	r25, Y+24	; 0x18
    1356:	20 e0       	ldi	r18, 0x00	; 0
    1358:	30 e0       	ldi	r19, 0x00	; 0
    135a:	40 e8       	ldi	r20, 0x80	; 128
    135c:	5f e3       	ldi	r21, 0x3F	; 63
    135e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1362:	88 23       	and	r24, r24
    1364:	2c f4       	brge	.+10     	; 0x1370 <LCD_voidInit+0x25a>
		__ticks = 1;
    1366:	81 e0       	ldi	r24, 0x01	; 1
    1368:	90 e0       	ldi	r25, 0x00	; 0
    136a:	9c 8b       	std	Y+20, r25	; 0x14
    136c:	8b 8b       	std	Y+19, r24	; 0x13
    136e:	3f c0       	rjmp	.+126    	; 0x13ee <LCD_voidInit+0x2d8>
	else if (__tmp > 65535)
    1370:	6d 89       	ldd	r22, Y+21	; 0x15
    1372:	7e 89       	ldd	r23, Y+22	; 0x16
    1374:	8f 89       	ldd	r24, Y+23	; 0x17
    1376:	98 8d       	ldd	r25, Y+24	; 0x18
    1378:	20 e0       	ldi	r18, 0x00	; 0
    137a:	3f ef       	ldi	r19, 0xFF	; 255
    137c:	4f e7       	ldi	r20, 0x7F	; 127
    137e:	57 e4       	ldi	r21, 0x47	; 71
    1380:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1384:	18 16       	cp	r1, r24
    1386:	4c f5       	brge	.+82     	; 0x13da <LCD_voidInit+0x2c4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1388:	69 8d       	ldd	r22, Y+25	; 0x19
    138a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    138c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    138e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1390:	20 e0       	ldi	r18, 0x00	; 0
    1392:	30 e0       	ldi	r19, 0x00	; 0
    1394:	40 e2       	ldi	r20, 0x20	; 32
    1396:	51 e4       	ldi	r21, 0x41	; 65
    1398:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    139c:	dc 01       	movw	r26, r24
    139e:	cb 01       	movw	r24, r22
    13a0:	bc 01       	movw	r22, r24
    13a2:	cd 01       	movw	r24, r26
    13a4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    13a8:	dc 01       	movw	r26, r24
    13aa:	cb 01       	movw	r24, r22
    13ac:	9c 8b       	std	Y+20, r25	; 0x14
    13ae:	8b 8b       	std	Y+19, r24	; 0x13
    13b0:	0f c0       	rjmp	.+30     	; 0x13d0 <LCD_voidInit+0x2ba>
    13b2:	8c e2       	ldi	r24, 0x2C	; 44
    13b4:	91 e0       	ldi	r25, 0x01	; 1
    13b6:	9a 8b       	std	Y+18, r25	; 0x12
    13b8:	89 8b       	std	Y+17, r24	; 0x11
    13ba:	89 89       	ldd	r24, Y+17	; 0x11
    13bc:	9a 89       	ldd	r25, Y+18	; 0x12
    13be:	01 97       	sbiw	r24, 0x01	; 1
    13c0:	f1 f7       	brne	.-4      	; 0x13be <LCD_voidInit+0x2a8>
    13c2:	9a 8b       	std	Y+18, r25	; 0x12
    13c4:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    13c6:	8b 89       	ldd	r24, Y+19	; 0x13
    13c8:	9c 89       	ldd	r25, Y+20	; 0x14
    13ca:	01 97       	sbiw	r24, 0x01	; 1
    13cc:	9c 8b       	std	Y+20, r25	; 0x14
    13ce:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    13d0:	8b 89       	ldd	r24, Y+19	; 0x13
    13d2:	9c 89       	ldd	r25, Y+20	; 0x14
    13d4:	00 97       	sbiw	r24, 0x00	; 0
    13d6:	69 f7       	brne	.-38     	; 0x13b2 <LCD_voidInit+0x29c>
    13d8:	14 c0       	rjmp	.+40     	; 0x1402 <LCD_voidInit+0x2ec>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    13da:	6d 89       	ldd	r22, Y+21	; 0x15
    13dc:	7e 89       	ldd	r23, Y+22	; 0x16
    13de:	8f 89       	ldd	r24, Y+23	; 0x17
    13e0:	98 8d       	ldd	r25, Y+24	; 0x18
    13e2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    13e6:	dc 01       	movw	r26, r24
    13e8:	cb 01       	movw	r24, r22
    13ea:	9c 8b       	std	Y+20, r25	; 0x14
    13ec:	8b 8b       	std	Y+19, r24	; 0x13
    13ee:	8b 89       	ldd	r24, Y+19	; 0x13
    13f0:	9c 89       	ldd	r25, Y+20	; 0x14
    13f2:	98 8b       	std	Y+16, r25	; 0x10
    13f4:	8f 87       	std	Y+15, r24	; 0x0f
    13f6:	8f 85       	ldd	r24, Y+15	; 0x0f
    13f8:	98 89       	ldd	r25, Y+16	; 0x10
    13fa:	01 97       	sbiw	r24, 0x01	; 1
    13fc:	f1 f7       	brne	.-4      	; 0x13fa <LCD_voidInit+0x2e4>
    13fe:	98 8b       	std	Y+16, r25	; 0x10
    1400:	8f 87       	std	Y+15, r24	; 0x0f
	//delay 1ms
	_delay_ms(1);
	//write command 0b00000001
	LCD_voidWriteCommand(0b00000001);
    1402:	81 e0       	ldi	r24, 0x01	; 1
    1404:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_voidWriteCommand>
    1408:	80 e0       	ldi	r24, 0x00	; 0
    140a:	90 e0       	ldi	r25, 0x00	; 0
    140c:	a0 e0       	ldi	r26, 0x00	; 0
    140e:	b0 e4       	ldi	r27, 0x40	; 64
    1410:	8b 87       	std	Y+11, r24	; 0x0b
    1412:	9c 87       	std	Y+12, r25	; 0x0c
    1414:	ad 87       	std	Y+13, r26	; 0x0d
    1416:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1418:	6b 85       	ldd	r22, Y+11	; 0x0b
    141a:	7c 85       	ldd	r23, Y+12	; 0x0c
    141c:	8d 85       	ldd	r24, Y+13	; 0x0d
    141e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1420:	20 e0       	ldi	r18, 0x00	; 0
    1422:	30 e8       	ldi	r19, 0x80	; 128
    1424:	4b e3       	ldi	r20, 0x3B	; 59
    1426:	55 e4       	ldi	r21, 0x45	; 69
    1428:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    142c:	dc 01       	movw	r26, r24
    142e:	cb 01       	movw	r24, r22
    1430:	8f 83       	std	Y+7, r24	; 0x07
    1432:	98 87       	std	Y+8, r25	; 0x08
    1434:	a9 87       	std	Y+9, r26	; 0x09
    1436:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1438:	6f 81       	ldd	r22, Y+7	; 0x07
    143a:	78 85       	ldd	r23, Y+8	; 0x08
    143c:	89 85       	ldd	r24, Y+9	; 0x09
    143e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1440:	20 e0       	ldi	r18, 0x00	; 0
    1442:	30 e0       	ldi	r19, 0x00	; 0
    1444:	40 e8       	ldi	r20, 0x80	; 128
    1446:	5f e3       	ldi	r21, 0x3F	; 63
    1448:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    144c:	88 23       	and	r24, r24
    144e:	2c f4       	brge	.+10     	; 0x145a <LCD_voidInit+0x344>
		__ticks = 1;
    1450:	81 e0       	ldi	r24, 0x01	; 1
    1452:	90 e0       	ldi	r25, 0x00	; 0
    1454:	9e 83       	std	Y+6, r25	; 0x06
    1456:	8d 83       	std	Y+5, r24	; 0x05
    1458:	3f c0       	rjmp	.+126    	; 0x14d8 <LCD_voidInit+0x3c2>
	else if (__tmp > 65535)
    145a:	6f 81       	ldd	r22, Y+7	; 0x07
    145c:	78 85       	ldd	r23, Y+8	; 0x08
    145e:	89 85       	ldd	r24, Y+9	; 0x09
    1460:	9a 85       	ldd	r25, Y+10	; 0x0a
    1462:	20 e0       	ldi	r18, 0x00	; 0
    1464:	3f ef       	ldi	r19, 0xFF	; 255
    1466:	4f e7       	ldi	r20, 0x7F	; 127
    1468:	57 e4       	ldi	r21, 0x47	; 71
    146a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    146e:	18 16       	cp	r1, r24
    1470:	4c f5       	brge	.+82     	; 0x14c4 <LCD_voidInit+0x3ae>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1472:	6b 85       	ldd	r22, Y+11	; 0x0b
    1474:	7c 85       	ldd	r23, Y+12	; 0x0c
    1476:	8d 85       	ldd	r24, Y+13	; 0x0d
    1478:	9e 85       	ldd	r25, Y+14	; 0x0e
    147a:	20 e0       	ldi	r18, 0x00	; 0
    147c:	30 e0       	ldi	r19, 0x00	; 0
    147e:	40 e2       	ldi	r20, 0x20	; 32
    1480:	51 e4       	ldi	r21, 0x41	; 65
    1482:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1486:	dc 01       	movw	r26, r24
    1488:	cb 01       	movw	r24, r22
    148a:	bc 01       	movw	r22, r24
    148c:	cd 01       	movw	r24, r26
    148e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1492:	dc 01       	movw	r26, r24
    1494:	cb 01       	movw	r24, r22
    1496:	9e 83       	std	Y+6, r25	; 0x06
    1498:	8d 83       	std	Y+5, r24	; 0x05
    149a:	0f c0       	rjmp	.+30     	; 0x14ba <LCD_voidInit+0x3a4>
    149c:	8c e2       	ldi	r24, 0x2C	; 44
    149e:	91 e0       	ldi	r25, 0x01	; 1
    14a0:	9c 83       	std	Y+4, r25	; 0x04
    14a2:	8b 83       	std	Y+3, r24	; 0x03
    14a4:	8b 81       	ldd	r24, Y+3	; 0x03
    14a6:	9c 81       	ldd	r25, Y+4	; 0x04
    14a8:	01 97       	sbiw	r24, 0x01	; 1
    14aa:	f1 f7       	brne	.-4      	; 0x14a8 <LCD_voidInit+0x392>
    14ac:	9c 83       	std	Y+4, r25	; 0x04
    14ae:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    14b0:	8d 81       	ldd	r24, Y+5	; 0x05
    14b2:	9e 81       	ldd	r25, Y+6	; 0x06
    14b4:	01 97       	sbiw	r24, 0x01	; 1
    14b6:	9e 83       	std	Y+6, r25	; 0x06
    14b8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    14ba:	8d 81       	ldd	r24, Y+5	; 0x05
    14bc:	9e 81       	ldd	r25, Y+6	; 0x06
    14be:	00 97       	sbiw	r24, 0x00	; 0
    14c0:	69 f7       	brne	.-38     	; 0x149c <LCD_voidInit+0x386>
    14c2:	14 c0       	rjmp	.+40     	; 0x14ec <LCD_voidInit+0x3d6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    14c4:	6f 81       	ldd	r22, Y+7	; 0x07
    14c6:	78 85       	ldd	r23, Y+8	; 0x08
    14c8:	89 85       	ldd	r24, Y+9	; 0x09
    14ca:	9a 85       	ldd	r25, Y+10	; 0x0a
    14cc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    14d0:	dc 01       	movw	r26, r24
    14d2:	cb 01       	movw	r24, r22
    14d4:	9e 83       	std	Y+6, r25	; 0x06
    14d6:	8d 83       	std	Y+5, r24	; 0x05
    14d8:	8d 81       	ldd	r24, Y+5	; 0x05
    14da:	9e 81       	ldd	r25, Y+6	; 0x06
    14dc:	9a 83       	std	Y+2, r25	; 0x02
    14de:	89 83       	std	Y+1, r24	; 0x01
    14e0:	89 81       	ldd	r24, Y+1	; 0x01
    14e2:	9a 81       	ldd	r25, Y+2	; 0x02
    14e4:	01 97       	sbiw	r24, 0x01	; 1
    14e6:	f1 f7       	brne	.-4      	; 0x14e4 <LCD_voidInit+0x3ce>
    14e8:	9a 83       	std	Y+2, r25	; 0x02
    14ea:	89 83       	std	Y+1, r24	; 0x01
	//delay 2ms
	_delay_ms(2);
}
    14ec:	e8 96       	adiw	r28, 0x38	; 56
    14ee:	0f b6       	in	r0, 0x3f	; 63
    14f0:	f8 94       	cli
    14f2:	de bf       	out	0x3e, r29	; 62
    14f4:	0f be       	out	0x3f, r0	; 63
    14f6:	cd bf       	out	0x3d, r28	; 61
    14f8:	cf 91       	pop	r28
    14fa:	df 91       	pop	r29
    14fc:	08 95       	ret

000014fe <LCD_voidWriteCommand>:
 *
 *
 **********************************************************************
 */
extern void LCD_voidWriteCommand(u8 Command)
{
    14fe:	df 93       	push	r29
    1500:	cf 93       	push	r28
    1502:	cd b7       	in	r28, 0x3d	; 61
    1504:	de b7       	in	r29, 0x3e	; 62
    1506:	2f 97       	sbiw	r28, 0x0f	; 15
    1508:	0f b6       	in	r0, 0x3f	; 63
    150a:	f8 94       	cli
    150c:	de bf       	out	0x3e, r29	; 62
    150e:	0f be       	out	0x3f, r0	; 63
    1510:	cd bf       	out	0x3d, r28	; 61
    1512:	8f 87       	std	Y+15, r24	; 0x0f
	// RS=0
	DIO_voidWritePinValue(LCD_RS,DIO_u8LOW);
    1514:	80 e0       	ldi	r24, 0x00	; 0
    1516:	60 e0       	ldi	r22, 0x00	; 0
    1518:	0e 94 ab 06 	call	0xd56	; 0xd56 <DIO_voidWritePinValue>

	//RW=0
	DIO_voidWritePinValue(LCD_RW,DIO_u8LOW);
    151c:	81 e0       	ldi	r24, 0x01	; 1
    151e:	60 e0       	ldi	r22, 0x00	; 0
    1520:	0e 94 ab 06 	call	0xd56	; 0xd56 <DIO_voidWritePinValue>

	//DataBus = command
	DIO_voidWritePortValue(LCD_Data_Port,Command);
    1524:	82 e0       	ldi	r24, 0x02	; 2
    1526:	6f 85       	ldd	r22, Y+15	; 0x0f
    1528:	0e 94 88 07 	call	0xf10	; 0xf10 <DIO_voidWritePortValue>

	//E=1
	DIO_voidWritePinValue(LCD_E,DIO_u8HIGH);
    152c:	82 e0       	ldi	r24, 0x02	; 2
    152e:	61 e0       	ldi	r22, 0x01	; 1
    1530:	0e 94 ab 06 	call	0xd56	; 0xd56 <DIO_voidWritePinValue>
    1534:	80 e0       	ldi	r24, 0x00	; 0
    1536:	90 e0       	ldi	r25, 0x00	; 0
    1538:	a0 e0       	ldi	r26, 0x00	; 0
    153a:	b0 e4       	ldi	r27, 0x40	; 64
    153c:	8b 87       	std	Y+11, r24	; 0x0b
    153e:	9c 87       	std	Y+12, r25	; 0x0c
    1540:	ad 87       	std	Y+13, r26	; 0x0d
    1542:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1544:	6b 85       	ldd	r22, Y+11	; 0x0b
    1546:	7c 85       	ldd	r23, Y+12	; 0x0c
    1548:	8d 85       	ldd	r24, Y+13	; 0x0d
    154a:	9e 85       	ldd	r25, Y+14	; 0x0e
    154c:	20 e0       	ldi	r18, 0x00	; 0
    154e:	30 e8       	ldi	r19, 0x80	; 128
    1550:	4b e3       	ldi	r20, 0x3B	; 59
    1552:	55 e4       	ldi	r21, 0x45	; 69
    1554:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1558:	dc 01       	movw	r26, r24
    155a:	cb 01       	movw	r24, r22
    155c:	8f 83       	std	Y+7, r24	; 0x07
    155e:	98 87       	std	Y+8, r25	; 0x08
    1560:	a9 87       	std	Y+9, r26	; 0x09
    1562:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1564:	6f 81       	ldd	r22, Y+7	; 0x07
    1566:	78 85       	ldd	r23, Y+8	; 0x08
    1568:	89 85       	ldd	r24, Y+9	; 0x09
    156a:	9a 85       	ldd	r25, Y+10	; 0x0a
    156c:	20 e0       	ldi	r18, 0x00	; 0
    156e:	30 e0       	ldi	r19, 0x00	; 0
    1570:	40 e8       	ldi	r20, 0x80	; 128
    1572:	5f e3       	ldi	r21, 0x3F	; 63
    1574:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1578:	88 23       	and	r24, r24
    157a:	2c f4       	brge	.+10     	; 0x1586 <LCD_voidWriteCommand+0x88>
		__ticks = 1;
    157c:	81 e0       	ldi	r24, 0x01	; 1
    157e:	90 e0       	ldi	r25, 0x00	; 0
    1580:	9e 83       	std	Y+6, r25	; 0x06
    1582:	8d 83       	std	Y+5, r24	; 0x05
    1584:	3f c0       	rjmp	.+126    	; 0x1604 <LCD_voidWriteCommand+0x106>
	else if (__tmp > 65535)
    1586:	6f 81       	ldd	r22, Y+7	; 0x07
    1588:	78 85       	ldd	r23, Y+8	; 0x08
    158a:	89 85       	ldd	r24, Y+9	; 0x09
    158c:	9a 85       	ldd	r25, Y+10	; 0x0a
    158e:	20 e0       	ldi	r18, 0x00	; 0
    1590:	3f ef       	ldi	r19, 0xFF	; 255
    1592:	4f e7       	ldi	r20, 0x7F	; 127
    1594:	57 e4       	ldi	r21, 0x47	; 71
    1596:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    159a:	18 16       	cp	r1, r24
    159c:	4c f5       	brge	.+82     	; 0x15f0 <LCD_voidWriteCommand+0xf2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    159e:	6b 85       	ldd	r22, Y+11	; 0x0b
    15a0:	7c 85       	ldd	r23, Y+12	; 0x0c
    15a2:	8d 85       	ldd	r24, Y+13	; 0x0d
    15a4:	9e 85       	ldd	r25, Y+14	; 0x0e
    15a6:	20 e0       	ldi	r18, 0x00	; 0
    15a8:	30 e0       	ldi	r19, 0x00	; 0
    15aa:	40 e2       	ldi	r20, 0x20	; 32
    15ac:	51 e4       	ldi	r21, 0x41	; 65
    15ae:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    15b2:	dc 01       	movw	r26, r24
    15b4:	cb 01       	movw	r24, r22
    15b6:	bc 01       	movw	r22, r24
    15b8:	cd 01       	movw	r24, r26
    15ba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    15be:	dc 01       	movw	r26, r24
    15c0:	cb 01       	movw	r24, r22
    15c2:	9e 83       	std	Y+6, r25	; 0x06
    15c4:	8d 83       	std	Y+5, r24	; 0x05
    15c6:	0f c0       	rjmp	.+30     	; 0x15e6 <LCD_voidWriteCommand+0xe8>
    15c8:	8c e2       	ldi	r24, 0x2C	; 44
    15ca:	91 e0       	ldi	r25, 0x01	; 1
    15cc:	9c 83       	std	Y+4, r25	; 0x04
    15ce:	8b 83       	std	Y+3, r24	; 0x03
    15d0:	8b 81       	ldd	r24, Y+3	; 0x03
    15d2:	9c 81       	ldd	r25, Y+4	; 0x04
    15d4:	01 97       	sbiw	r24, 0x01	; 1
    15d6:	f1 f7       	brne	.-4      	; 0x15d4 <LCD_voidWriteCommand+0xd6>
    15d8:	9c 83       	std	Y+4, r25	; 0x04
    15da:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    15dc:	8d 81       	ldd	r24, Y+5	; 0x05
    15de:	9e 81       	ldd	r25, Y+6	; 0x06
    15e0:	01 97       	sbiw	r24, 0x01	; 1
    15e2:	9e 83       	std	Y+6, r25	; 0x06
    15e4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    15e6:	8d 81       	ldd	r24, Y+5	; 0x05
    15e8:	9e 81       	ldd	r25, Y+6	; 0x06
    15ea:	00 97       	sbiw	r24, 0x00	; 0
    15ec:	69 f7       	brne	.-38     	; 0x15c8 <LCD_voidWriteCommand+0xca>
    15ee:	14 c0       	rjmp	.+40     	; 0x1618 <LCD_voidWriteCommand+0x11a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    15f0:	6f 81       	ldd	r22, Y+7	; 0x07
    15f2:	78 85       	ldd	r23, Y+8	; 0x08
    15f4:	89 85       	ldd	r24, Y+9	; 0x09
    15f6:	9a 85       	ldd	r25, Y+10	; 0x0a
    15f8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    15fc:	dc 01       	movw	r26, r24
    15fe:	cb 01       	movw	r24, r22
    1600:	9e 83       	std	Y+6, r25	; 0x06
    1602:	8d 83       	std	Y+5, r24	; 0x05
    1604:	8d 81       	ldd	r24, Y+5	; 0x05
    1606:	9e 81       	ldd	r25, Y+6	; 0x06
    1608:	9a 83       	std	Y+2, r25	; 0x02
    160a:	89 83       	std	Y+1, r24	; 0x01
    160c:	89 81       	ldd	r24, Y+1	; 0x01
    160e:	9a 81       	ldd	r25, Y+2	; 0x02
    1610:	01 97       	sbiw	r24, 0x01	; 1
    1612:	f1 f7       	brne	.-4      	; 0x1610 <LCD_voidWriteCommand+0x112>
    1614:	9a 83       	std	Y+2, r25	; 0x02
    1616:	89 83       	std	Y+1, r24	; 0x01

	//Delay 2ms
	_delay_ms(2);

	//E=0
	DIO_voidWritePinValue(LCD_E,DIO_u8LOW);
    1618:	82 e0       	ldi	r24, 0x02	; 2
    161a:	60 e0       	ldi	r22, 0x00	; 0
    161c:	0e 94 ab 06 	call	0xd56	; 0xd56 <DIO_voidWritePinValue>
}
    1620:	2f 96       	adiw	r28, 0x0f	; 15
    1622:	0f b6       	in	r0, 0x3f	; 63
    1624:	f8 94       	cli
    1626:	de bf       	out	0x3e, r29	; 62
    1628:	0f be       	out	0x3f, r0	; 63
    162a:	cd bf       	out	0x3d, r28	; 61
    162c:	cf 91       	pop	r28
    162e:	df 91       	pop	r29
    1630:	08 95       	ret

00001632 <LCD_voidDisplayData>:
 *
 *
 **********************************************************************
 */
extern void LCD_voidDisplayData(u8 Data)
{
    1632:	df 93       	push	r29
    1634:	cf 93       	push	r28
    1636:	0f 92       	push	r0
    1638:	cd b7       	in	r28, 0x3d	; 61
    163a:	de b7       	in	r29, 0x3e	; 62
    163c:	89 83       	std	Y+1, r24	; 0x01
	// RS=1
	DIO_voidWritePinValue(LCD_RS,DIO_u8HIGH);
    163e:	80 e0       	ldi	r24, 0x00	; 0
    1640:	61 e0       	ldi	r22, 0x01	; 1
    1642:	0e 94 ab 06 	call	0xd56	; 0xd56 <DIO_voidWritePinValue>

	//RW=0
	DIO_voidWritePinValue(LCD_RW,DIO_u8LOW);
    1646:	81 e0       	ldi	r24, 0x01	; 1
    1648:	60 e0       	ldi	r22, 0x00	; 0
    164a:	0e 94 ab 06 	call	0xd56	; 0xd56 <DIO_voidWritePinValue>

	//DataBus = Data
	DIO_voidWritePortValue(LCD_Data_Port,Data);
    164e:	82 e0       	ldi	r24, 0x02	; 2
    1650:	69 81       	ldd	r22, Y+1	; 0x01
    1652:	0e 94 88 07 	call	0xf10	; 0xf10 <DIO_voidWritePortValue>

	//E=1
	DIO_voidWritePinValue(LCD_E,DIO_u8HIGH);
    1656:	82 e0       	ldi	r24, 0x02	; 2
    1658:	61 e0       	ldi	r22, 0x01	; 1
    165a:	0e 94 ab 06 	call	0xd56	; 0xd56 <DIO_voidWritePinValue>

	vTaskDelay(2);
    165e:	82 e0       	ldi	r24, 0x02	; 2
    1660:	90 e0       	ldi	r25, 0x00	; 0
    1662:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <vTaskDelay>

//	//Delay 2ms
//	_delay_ms(2);

	//E=0
	DIO_voidWritePinValue(LCD_E,DIO_u8LOW);
    1666:	82 e0       	ldi	r24, 0x02	; 2
    1668:	60 e0       	ldi	r22, 0x00	; 0
    166a:	0e 94 ab 06 	call	0xd56	; 0xd56 <DIO_voidWritePinValue>
}
    166e:	0f 90       	pop	r0
    1670:	cf 91       	pop	r28
    1672:	df 91       	pop	r29
    1674:	08 95       	ret

00001676 <LCD_voidGoToPos>:
 *
 *
 **********************************************************************
 */
extern void LCD_voidGoToPos(u8 Copy_u8RowNum,u8 Copy_u8ColNum)
{
    1676:	df 93       	push	r29
    1678:	cf 93       	push	r28
    167a:	00 d0       	rcall	.+0      	; 0x167c <LCD_voidGoToPos+0x6>
    167c:	cd b7       	in	r28, 0x3d	; 61
    167e:	de b7       	in	r29, 0x3e	; 62
    1680:	89 83       	std	Y+1, r24	; 0x01
    1682:	6a 83       	std	Y+2, r22	; 0x02

	LCD_voidWriteCommand(0b10000000);
    1684:	80 e8       	ldi	r24, 0x80	; 128
    1686:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_voidWriteCommand>
	if(Copy_u8RowNum==1)
    168a:	89 81       	ldd	r24, Y+1	; 0x01
    168c:	81 30       	cpi	r24, 0x01	; 1
    168e:	59 f4       	brne	.+22     	; 0x16a6 <LCD_voidGoToPos+0x30>
	{
		if (Copy_u8ColNum>0 && Copy_u8ColNum <=16)
    1690:	8a 81       	ldd	r24, Y+2	; 0x02
    1692:	88 23       	and	r24, r24
    1694:	a9 f0       	breq	.+42     	; 0x16c0 <LCD_voidGoToPos+0x4a>
    1696:	8a 81       	ldd	r24, Y+2	; 0x02
    1698:	81 31       	cpi	r24, 0x11	; 17
    169a:	90 f4       	brcc	.+36     	; 0x16c0 <LCD_voidGoToPos+0x4a>
		{
			LCD_voidWriteCommand(127+Copy_u8ColNum);
    169c:	8a 81       	ldd	r24, Y+2	; 0x02
    169e:	81 58       	subi	r24, 0x81	; 129
    16a0:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_voidWriteCommand>
    16a4:	0d c0       	rjmp	.+26     	; 0x16c0 <LCD_voidGoToPos+0x4a>
		}
	}
	else if (Copy_u8RowNum==2)
    16a6:	89 81       	ldd	r24, Y+1	; 0x01
    16a8:	82 30       	cpi	r24, 0x02	; 2
    16aa:	51 f4       	brne	.+20     	; 0x16c0 <LCD_voidGoToPos+0x4a>
	{
		if (Copy_u8ColNum>0 && Copy_u8ColNum <=16)
    16ac:	8a 81       	ldd	r24, Y+2	; 0x02
    16ae:	88 23       	and	r24, r24
    16b0:	39 f0       	breq	.+14     	; 0x16c0 <LCD_voidGoToPos+0x4a>
    16b2:	8a 81       	ldd	r24, Y+2	; 0x02
    16b4:	81 31       	cpi	r24, 0x11	; 17
    16b6:	20 f4       	brcc	.+8      	; 0x16c0 <LCD_voidGoToPos+0x4a>
		{
			LCD_voidWriteCommand(191+Copy_u8ColNum);
    16b8:	8a 81       	ldd	r24, Y+2	; 0x02
    16ba:	81 54       	subi	r24, 0x41	; 65
    16bc:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_voidWriteCommand>
		}
	}

}
    16c0:	0f 90       	pop	r0
    16c2:	0f 90       	pop	r0
    16c4:	cf 91       	pop	r28
    16c6:	df 91       	pop	r29
    16c8:	08 95       	ret

000016ca <LCD_voidWriteChar>:


//========================================================================================
extern void LCD_voidWriteChar(u8 Copy_u8RowNum,u8 Copy_u8ColNum,u8 Copy_u8Char)
{
    16ca:	df 93       	push	r29
    16cc:	cf 93       	push	r28
    16ce:	00 d0       	rcall	.+0      	; 0x16d0 <LCD_voidWriteChar+0x6>
    16d0:	0f 92       	push	r0
    16d2:	cd b7       	in	r28, 0x3d	; 61
    16d4:	de b7       	in	r29, 0x3e	; 62
    16d6:	89 83       	std	Y+1, r24	; 0x01
    16d8:	6a 83       	std	Y+2, r22	; 0x02
    16da:	4b 83       	std	Y+3, r20	; 0x03
	LCD_voidGoToPos(Copy_u8RowNum,Copy_u8ColNum);
    16dc:	89 81       	ldd	r24, Y+1	; 0x01
    16de:	6a 81       	ldd	r22, Y+2	; 0x02
    16e0:	0e 94 3b 0b 	call	0x1676	; 0x1676 <LCD_voidGoToPos>
	LCD_voidDisplayData(Copy_u8Char);
    16e4:	8b 81       	ldd	r24, Y+3	; 0x03
    16e6:	0e 94 19 0b 	call	0x1632	; 0x1632 <LCD_voidDisplayData>
}
    16ea:	0f 90       	pop	r0
    16ec:	0f 90       	pop	r0
    16ee:	0f 90       	pop	r0
    16f0:	cf 91       	pop	r28
    16f2:	df 91       	pop	r29
    16f4:	08 95       	ret

000016f6 <LCD_voidWriteCharr>:
//=========================================================================================
extern void LCD_voidWriteCharr(u8 Copy_u8Char)
{
    16f6:	df 93       	push	r29
    16f8:	cf 93       	push	r28
    16fa:	0f 92       	push	r0
    16fc:	cd b7       	in	r28, 0x3d	; 61
    16fe:	de b7       	in	r29, 0x3e	; 62
    1700:	89 83       	std	Y+1, r24	; 0x01
	LCD_voidDisplayData(Copy_u8Char);
    1702:	89 81       	ldd	r24, Y+1	; 0x01
    1704:	0e 94 19 0b 	call	0x1632	; 0x1632 <LCD_voidDisplayData>
}
    1708:	0f 90       	pop	r0
    170a:	cf 91       	pop	r28
    170c:	df 91       	pop	r29
    170e:	08 95       	ret

00001710 <LCD_voidWriteSentence>:
//=========================================================================================
extern void LCD_voidWriteSentence(u8 Copy_u8RowNum,u8 Copy_u8ColNum,u8 *Copy_u8CharArr)
{
    1710:	df 93       	push	r29
    1712:	cf 93       	push	r28
    1714:	00 d0       	rcall	.+0      	; 0x1716 <LCD_voidWriteSentence+0x6>
    1716:	00 d0       	rcall	.+0      	; 0x1718 <LCD_voidWriteSentence+0x8>
    1718:	0f 92       	push	r0
    171a:	cd b7       	in	r28, 0x3d	; 61
    171c:	de b7       	in	r29, 0x3e	; 62
    171e:	8a 83       	std	Y+2, r24	; 0x02
    1720:	6b 83       	std	Y+3, r22	; 0x03
    1722:	5d 83       	std	Y+5, r21	; 0x05
    1724:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8Counter;
	LCD_voidGoToPos(Copy_u8RowNum,Copy_u8ColNum);
    1726:	8a 81       	ldd	r24, Y+2	; 0x02
    1728:	6b 81       	ldd	r22, Y+3	; 0x03
    172a:	0e 94 3b 0b 	call	0x1676	; 0x1676 <LCD_voidGoToPos>
	for (Local_u8Counter=0;Copy_u8CharArr[Local_u8Counter]!='\0';Local_u8Counter++)
    172e:	19 82       	std	Y+1, r1	; 0x01
    1730:	0e c0       	rjmp	.+28     	; 0x174e <LCD_voidWriteSentence+0x3e>
	{
		LCD_voidDisplayData(Copy_u8CharArr[Local_u8Counter]);
    1732:	89 81       	ldd	r24, Y+1	; 0x01
    1734:	28 2f       	mov	r18, r24
    1736:	30 e0       	ldi	r19, 0x00	; 0
    1738:	8c 81       	ldd	r24, Y+4	; 0x04
    173a:	9d 81       	ldd	r25, Y+5	; 0x05
    173c:	fc 01       	movw	r30, r24
    173e:	e2 0f       	add	r30, r18
    1740:	f3 1f       	adc	r31, r19
    1742:	80 81       	ld	r24, Z
    1744:	0e 94 19 0b 	call	0x1632	; 0x1632 <LCD_voidDisplayData>
//=========================================================================================
extern void LCD_voidWriteSentence(u8 Copy_u8RowNum,u8 Copy_u8ColNum,u8 *Copy_u8CharArr)
{
	u8 Local_u8Counter;
	LCD_voidGoToPos(Copy_u8RowNum,Copy_u8ColNum);
	for (Local_u8Counter=0;Copy_u8CharArr[Local_u8Counter]!='\0';Local_u8Counter++)
    1748:	89 81       	ldd	r24, Y+1	; 0x01
    174a:	8f 5f       	subi	r24, 0xFF	; 255
    174c:	89 83       	std	Y+1, r24	; 0x01
    174e:	89 81       	ldd	r24, Y+1	; 0x01
    1750:	28 2f       	mov	r18, r24
    1752:	30 e0       	ldi	r19, 0x00	; 0
    1754:	8c 81       	ldd	r24, Y+4	; 0x04
    1756:	9d 81       	ldd	r25, Y+5	; 0x05
    1758:	fc 01       	movw	r30, r24
    175a:	e2 0f       	add	r30, r18
    175c:	f3 1f       	adc	r31, r19
    175e:	80 81       	ld	r24, Z
    1760:	88 23       	and	r24, r24
    1762:	39 f7       	brne	.-50     	; 0x1732 <LCD_voidWriteSentence+0x22>
	{
		LCD_voidDisplayData(Copy_u8CharArr[Local_u8Counter]);

	}

}
    1764:	0f 90       	pop	r0
    1766:	0f 90       	pop	r0
    1768:	0f 90       	pop	r0
    176a:	0f 90       	pop	r0
    176c:	0f 90       	pop	r0
    176e:	cf 91       	pop	r28
    1770:	df 91       	pop	r29
    1772:	08 95       	ret

00001774 <LCD_voidWriteSentencee>:
//=======================================================================================

extern void LCD_voidWriteSentencee(u8 *Copy_u8CharArr)
{
    1774:	df 93       	push	r29
    1776:	cf 93       	push	r28
    1778:	00 d0       	rcall	.+0      	; 0x177a <LCD_voidWriteSentencee+0x6>
    177a:	0f 92       	push	r0
    177c:	cd b7       	in	r28, 0x3d	; 61
    177e:	de b7       	in	r29, 0x3e	; 62
    1780:	9b 83       	std	Y+3, r25	; 0x03
    1782:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8Counter;
	for(Local_u8Counter=0;Copy_u8CharArr[Local_u8Counter]!='\0';Local_u8Counter++)
    1784:	19 82       	std	Y+1, r1	; 0x01
    1786:	0e c0       	rjmp	.+28     	; 0x17a4 <LCD_voidWriteSentencee+0x30>
	{
		LCD_voidDisplayData(Copy_u8CharArr[Local_u8Counter]);
    1788:	89 81       	ldd	r24, Y+1	; 0x01
    178a:	28 2f       	mov	r18, r24
    178c:	30 e0       	ldi	r19, 0x00	; 0
    178e:	8a 81       	ldd	r24, Y+2	; 0x02
    1790:	9b 81       	ldd	r25, Y+3	; 0x03
    1792:	fc 01       	movw	r30, r24
    1794:	e2 0f       	add	r30, r18
    1796:	f3 1f       	adc	r31, r19
    1798:	80 81       	ld	r24, Z
    179a:	0e 94 19 0b 	call	0x1632	; 0x1632 <LCD_voidDisplayData>
//=======================================================================================

extern void LCD_voidWriteSentencee(u8 *Copy_u8CharArr)
{
	u8 Local_u8Counter;
	for(Local_u8Counter=0;Copy_u8CharArr[Local_u8Counter]!='\0';Local_u8Counter++)
    179e:	89 81       	ldd	r24, Y+1	; 0x01
    17a0:	8f 5f       	subi	r24, 0xFF	; 255
    17a2:	89 83       	std	Y+1, r24	; 0x01
    17a4:	89 81       	ldd	r24, Y+1	; 0x01
    17a6:	28 2f       	mov	r18, r24
    17a8:	30 e0       	ldi	r19, 0x00	; 0
    17aa:	8a 81       	ldd	r24, Y+2	; 0x02
    17ac:	9b 81       	ldd	r25, Y+3	; 0x03
    17ae:	fc 01       	movw	r30, r24
    17b0:	e2 0f       	add	r30, r18
    17b2:	f3 1f       	adc	r31, r19
    17b4:	80 81       	ld	r24, Z
    17b6:	88 23       	and	r24, r24
    17b8:	39 f7       	brne	.-50     	; 0x1788 <LCD_voidWriteSentencee+0x14>
	{
		LCD_voidDisplayData(Copy_u8CharArr[Local_u8Counter]);

	}

}
    17ba:	0f 90       	pop	r0
    17bc:	0f 90       	pop	r0
    17be:	0f 90       	pop	r0
    17c0:	cf 91       	pop	r28
    17c2:	df 91       	pop	r29
    17c4:	08 95       	ret

000017c6 <LCD_DispalyNumber>:
//=======================================================================================
extern void LCD_DispalyNumber(u32 x)
{
    17c6:	ef 92       	push	r14
    17c8:	ff 92       	push	r15
    17ca:	0f 93       	push	r16
    17cc:	1f 93       	push	r17
    17ce:	df 93       	push	r29
    17d0:	cf 93       	push	r28
    17d2:	cd b7       	in	r28, 0x3d	; 61
    17d4:	de b7       	in	r29, 0x3e	; 62
    17d6:	28 97       	sbiw	r28, 0x08	; 8
    17d8:	0f b6       	in	r0, 0x3f	; 63
    17da:	f8 94       	cli
    17dc:	de bf       	out	0x3e, r29	; 62
    17de:	0f be       	out	0x3f, r0	; 63
    17e0:	cd bf       	out	0x3d, r28	; 61
    17e2:	6d 83       	std	Y+5, r22	; 0x05
    17e4:	7e 83       	std	Y+6, r23	; 0x06
    17e6:	8f 83       	std	Y+7, r24	; 0x07
    17e8:	98 87       	std	Y+8, r25	; 0x08
	u32 y = 1;
    17ea:	81 e0       	ldi	r24, 0x01	; 1
    17ec:	90 e0       	ldi	r25, 0x00	; 0
    17ee:	a0 e0       	ldi	r26, 0x00	; 0
    17f0:	b0 e0       	ldi	r27, 0x00	; 0
    17f2:	89 83       	std	Y+1, r24	; 0x01
    17f4:	9a 83       	std	Y+2, r25	; 0x02
    17f6:	ab 83       	std	Y+3, r26	; 0x03
    17f8:	bc 83       	std	Y+4, r27	; 0x04
	if (x == 0)
    17fa:	8d 81       	ldd	r24, Y+5	; 0x05
    17fc:	9e 81       	ldd	r25, Y+6	; 0x06
    17fe:	af 81       	ldd	r26, Y+7	; 0x07
    1800:	b8 85       	ldd	r27, Y+8	; 0x08
    1802:	00 97       	sbiw	r24, 0x00	; 0
    1804:	a1 05       	cpc	r26, r1
    1806:	b1 05       	cpc	r27, r1
    1808:	d1 f5       	brne	.+116    	; 0x187e <LCD_DispalyNumber+0xb8>
	{
		LCD_voidDisplayData('0');
    180a:	80 e3       	ldi	r24, 0x30	; 48
    180c:	0e 94 19 0b 	call	0x1632	; 0x1632 <LCD_voidDisplayData>
    1810:	36 c0       	rjmp	.+108    	; 0x187e <LCD_DispalyNumber+0xb8>
	if (x < 0) {
		LCD_voidDisplayData('-');
		x *= -1;
	}
	while (x != 0) {
		y = ((y * 10) + (x % 10));
    1812:	89 81       	ldd	r24, Y+1	; 0x01
    1814:	9a 81       	ldd	r25, Y+2	; 0x02
    1816:	ab 81       	ldd	r26, Y+3	; 0x03
    1818:	bc 81       	ldd	r27, Y+4	; 0x04
    181a:	2a e0       	ldi	r18, 0x0A	; 10
    181c:	30 e0       	ldi	r19, 0x00	; 0
    181e:	40 e0       	ldi	r20, 0x00	; 0
    1820:	50 e0       	ldi	r21, 0x00	; 0
    1822:	bc 01       	movw	r22, r24
    1824:	cd 01       	movw	r24, r26
    1826:	0e 94 1d 20 	call	0x403a	; 0x403a <__mulsi3>
    182a:	7b 01       	movw	r14, r22
    182c:	8c 01       	movw	r16, r24
    182e:	8d 81       	ldd	r24, Y+5	; 0x05
    1830:	9e 81       	ldd	r25, Y+6	; 0x06
    1832:	af 81       	ldd	r26, Y+7	; 0x07
    1834:	b8 85       	ldd	r27, Y+8	; 0x08
    1836:	2a e0       	ldi	r18, 0x0A	; 10
    1838:	30 e0       	ldi	r19, 0x00	; 0
    183a:	40 e0       	ldi	r20, 0x00	; 0
    183c:	50 e0       	ldi	r21, 0x00	; 0
    183e:	bc 01       	movw	r22, r24
    1840:	cd 01       	movw	r24, r26
    1842:	0e 94 3c 20 	call	0x4078	; 0x4078 <__udivmodsi4>
    1846:	dc 01       	movw	r26, r24
    1848:	cb 01       	movw	r24, r22
    184a:	8e 0d       	add	r24, r14
    184c:	9f 1d       	adc	r25, r15
    184e:	a0 1f       	adc	r26, r16
    1850:	b1 1f       	adc	r27, r17
    1852:	89 83       	std	Y+1, r24	; 0x01
    1854:	9a 83       	std	Y+2, r25	; 0x02
    1856:	ab 83       	std	Y+3, r26	; 0x03
    1858:	bc 83       	std	Y+4, r27	; 0x04
		x = (x / 10);
    185a:	8d 81       	ldd	r24, Y+5	; 0x05
    185c:	9e 81       	ldd	r25, Y+6	; 0x06
    185e:	af 81       	ldd	r26, Y+7	; 0x07
    1860:	b8 85       	ldd	r27, Y+8	; 0x08
    1862:	2a e0       	ldi	r18, 0x0A	; 10
    1864:	30 e0       	ldi	r19, 0x00	; 0
    1866:	40 e0       	ldi	r20, 0x00	; 0
    1868:	50 e0       	ldi	r21, 0x00	; 0
    186a:	bc 01       	movw	r22, r24
    186c:	cd 01       	movw	r24, r26
    186e:	0e 94 3c 20 	call	0x4078	; 0x4078 <__udivmodsi4>
    1872:	da 01       	movw	r26, r20
    1874:	c9 01       	movw	r24, r18
    1876:	8d 83       	std	Y+5, r24	; 0x05
    1878:	9e 83       	std	Y+6, r25	; 0x06
    187a:	af 83       	std	Y+7, r26	; 0x07
    187c:	b8 87       	std	Y+8, r27	; 0x08
	}
	if (x < 0) {
		LCD_voidDisplayData('-');
		x *= -1;
	}
	while (x != 0) {
    187e:	8d 81       	ldd	r24, Y+5	; 0x05
    1880:	9e 81       	ldd	r25, Y+6	; 0x06
    1882:	af 81       	ldd	r26, Y+7	; 0x07
    1884:	b8 85       	ldd	r27, Y+8	; 0x08
    1886:	00 97       	sbiw	r24, 0x00	; 0
    1888:	a1 05       	cpc	r26, r1
    188a:	b1 05       	cpc	r27, r1
    188c:	11 f6       	brne	.-124    	; 0x1812 <LCD_DispalyNumber+0x4c>
    188e:	23 c0       	rjmp	.+70     	; 0x18d6 <LCD_DispalyNumber+0x110>
		y = ((y * 10) + (x % 10));
		x = (x / 10);
	}
	while (y != 1) {
		LCD_voidDisplayData((y % 10) + 48);
    1890:	89 81       	ldd	r24, Y+1	; 0x01
    1892:	9a 81       	ldd	r25, Y+2	; 0x02
    1894:	ab 81       	ldd	r26, Y+3	; 0x03
    1896:	bc 81       	ldd	r27, Y+4	; 0x04
    1898:	2a e0       	ldi	r18, 0x0A	; 10
    189a:	30 e0       	ldi	r19, 0x00	; 0
    189c:	40 e0       	ldi	r20, 0x00	; 0
    189e:	50 e0       	ldi	r21, 0x00	; 0
    18a0:	bc 01       	movw	r22, r24
    18a2:	cd 01       	movw	r24, r26
    18a4:	0e 94 3c 20 	call	0x4078	; 0x4078 <__udivmodsi4>
    18a8:	dc 01       	movw	r26, r24
    18aa:	cb 01       	movw	r24, r22
    18ac:	80 5d       	subi	r24, 0xD0	; 208
    18ae:	0e 94 19 0b 	call	0x1632	; 0x1632 <LCD_voidDisplayData>
		y = (y / 10);
    18b2:	89 81       	ldd	r24, Y+1	; 0x01
    18b4:	9a 81       	ldd	r25, Y+2	; 0x02
    18b6:	ab 81       	ldd	r26, Y+3	; 0x03
    18b8:	bc 81       	ldd	r27, Y+4	; 0x04
    18ba:	2a e0       	ldi	r18, 0x0A	; 10
    18bc:	30 e0       	ldi	r19, 0x00	; 0
    18be:	40 e0       	ldi	r20, 0x00	; 0
    18c0:	50 e0       	ldi	r21, 0x00	; 0
    18c2:	bc 01       	movw	r22, r24
    18c4:	cd 01       	movw	r24, r26
    18c6:	0e 94 3c 20 	call	0x4078	; 0x4078 <__udivmodsi4>
    18ca:	da 01       	movw	r26, r20
    18cc:	c9 01       	movw	r24, r18
    18ce:	89 83       	std	Y+1, r24	; 0x01
    18d0:	9a 83       	std	Y+2, r25	; 0x02
    18d2:	ab 83       	std	Y+3, r26	; 0x03
    18d4:	bc 83       	std	Y+4, r27	; 0x04
	}
	while (x != 0) {
		y = ((y * 10) + (x % 10));
		x = (x / 10);
	}
	while (y != 1) {
    18d6:	89 81       	ldd	r24, Y+1	; 0x01
    18d8:	9a 81       	ldd	r25, Y+2	; 0x02
    18da:	ab 81       	ldd	r26, Y+3	; 0x03
    18dc:	bc 81       	ldd	r27, Y+4	; 0x04
    18de:	81 30       	cpi	r24, 0x01	; 1
    18e0:	91 05       	cpc	r25, r1
    18e2:	a1 05       	cpc	r26, r1
    18e4:	b1 05       	cpc	r27, r1
    18e6:	a1 f6       	brne	.-88     	; 0x1890 <LCD_DispalyNumber+0xca>
		LCD_voidDisplayData((y % 10) + 48);
		y = (y / 10);
	}
}
    18e8:	28 96       	adiw	r28, 0x08	; 8
    18ea:	0f b6       	in	r0, 0x3f	; 63
    18ec:	f8 94       	cli
    18ee:	de bf       	out	0x3e, r29	; 62
    18f0:	0f be       	out	0x3f, r0	; 63
    18f2:	cd bf       	out	0x3d, r28	; 61
    18f4:	cf 91       	pop	r28
    18f6:	df 91       	pop	r29
    18f8:	1f 91       	pop	r17
    18fa:	0f 91       	pop	r16
    18fc:	ff 90       	pop	r15
    18fe:	ef 90       	pop	r14
    1900:	08 95       	ret

00001902 <LCD_Write1>:
#include "LCD.h"
#include "task.h"

//================= [Tasks] ===============
void LCD_Write1( void *pvParameters)
{
    1902:	df 93       	push	r29
    1904:	cf 93       	push	r28
    1906:	00 d0       	rcall	.+0      	; 0x1908 <LCD_Write1+0x6>
    1908:	00 d0       	rcall	.+0      	; 0x190a <LCD_Write1+0x8>
    190a:	cd b7       	in	r28, 0x3d	; 61
    190c:	de b7       	in	r29, 0x3e	; 62
    190e:	9c 83       	std	Y+4, r25	; 0x04
    1910:	8b 83       	std	Y+3, r24	; 0x03
	portTickType StartTime = xTaskGetTickCount();
    1912:	0e 94 04 1c 	call	0x3808	; 0x3808 <xTaskGetTickCount>
    1916:	9a 83       	std	Y+2, r25	; 0x02
    1918:	89 83       	std	Y+1, r24	; 0x01
		while(1)
	{

		LCD_voidDisplayData('W');
    191a:	87 e5       	ldi	r24, 0x57	; 87
    191c:	0e 94 19 0b 	call	0x1632	; 0x1632 <LCD_voidDisplayData>
		vTaskDelayUntil(&StartTime,500); //OS Delay
    1920:	ce 01       	movw	r24, r28
    1922:	01 96       	adiw	r24, 0x01	; 1
    1924:	64 ef       	ldi	r22, 0xF4	; 244
    1926:	71 e0       	ldi	r23, 0x01	; 1
    1928:	0e 94 82 1a 	call	0x3504	; 0x3504 <vTaskDelayUntil>
    192c:	f6 cf       	rjmp	.-20     	; 0x191a <LCD_Write1+0x18>

0000192e <Blink_500ms_task>:
	}
}
//================= [Tasks] ===============
void Blink_500ms_task( void *pvParameters)
{
    192e:	df 93       	push	r29
    1930:	cf 93       	push	r28
    1932:	00 d0       	rcall	.+0      	; 0x1934 <Blink_500ms_task+0x6>
    1934:	cd b7       	in	r28, 0x3d	; 61
    1936:	de b7       	in	r29, 0x3e	; 62
    1938:	9a 83       	std	Y+2, r25	; 0x02
    193a:	89 83       	std	Y+1, r24	; 0x01
	DDRA |=(1<<0); //PA.0 is output
    193c:	aa e3       	ldi	r26, 0x3A	; 58
    193e:	b0 e0       	ldi	r27, 0x00	; 0
    1940:	ea e3       	ldi	r30, 0x3A	; 58
    1942:	f0 e0       	ldi	r31, 0x00	; 0
    1944:	80 81       	ld	r24, Z
    1946:	81 60       	ori	r24, 0x01	; 1
    1948:	8c 93       	st	X, r24
	
	while(1)
	{
		
		PORTA ^= (1<<0); //toggle PA.0
    194a:	ab e3       	ldi	r26, 0x3B	; 59
    194c:	b0 e0       	ldi	r27, 0x00	; 0
    194e:	eb e3       	ldi	r30, 0x3B	; 59
    1950:	f0 e0       	ldi	r31, 0x00	; 0
    1952:	90 81       	ld	r25, Z
    1954:	81 e0       	ldi	r24, 0x01	; 1
    1956:	89 27       	eor	r24, r25
    1958:	8c 93       	st	X, r24
		vTaskDelay(500); //OS Delay
    195a:	84 ef       	ldi	r24, 0xF4	; 244
    195c:	91 e0       	ldi	r25, 0x01	; 1
    195e:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <vTaskDelay>
    1962:	f3 cf       	rjmp	.-26     	; 0x194a <Blink_500ms_task+0x1c>

00001964 <Blink_1000ms_task>:
	}
}
//--------------------------------------------------
void Blink_1000ms_task( void *pvParameters)
{
    1964:	df 93       	push	r29
    1966:	cf 93       	push	r28
    1968:	00 d0       	rcall	.+0      	; 0x196a <Blink_1000ms_task+0x6>
    196a:	cd b7       	in	r28, 0x3d	; 61
    196c:	de b7       	in	r29, 0x3e	; 62
    196e:	9a 83       	std	Y+2, r25	; 0x02
    1970:	89 83       	std	Y+1, r24	; 0x01
	DDRB |=(1<<0); //PB.0 is output
    1972:	a7 e3       	ldi	r26, 0x37	; 55
    1974:	b0 e0       	ldi	r27, 0x00	; 0
    1976:	e7 e3       	ldi	r30, 0x37	; 55
    1978:	f0 e0       	ldi	r31, 0x00	; 0
    197a:	80 81       	ld	r24, Z
    197c:	81 60       	ori	r24, 0x01	; 1
    197e:	8c 93       	st	X, r24

	while(1)
	{

		PORTB ^= (1<<0); //toggle PB.0
    1980:	a8 e3       	ldi	r26, 0x38	; 56
    1982:	b0 e0       	ldi	r27, 0x00	; 0
    1984:	e8 e3       	ldi	r30, 0x38	; 56
    1986:	f0 e0       	ldi	r31, 0x00	; 0
    1988:	90 81       	ld	r25, Z
    198a:	81 e0       	ldi	r24, 0x01	; 1
    198c:	89 27       	eor	r24, r25
    198e:	8c 93       	st	X, r24
		vTaskDelay(1000); //OS Delay
    1990:	88 ee       	ldi	r24, 0xE8	; 232
    1992:	93 e0       	ldi	r25, 0x03	; 3
    1994:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <vTaskDelay>
    1998:	f3 cf       	rjmp	.-26     	; 0x1980 <Blink_1000ms_task+0x1c>

0000199a <Blink_1500ms_task>:
	}
}
//---------------------------------------------
void Blink_1500ms_task( void *pvParameters)
{
    199a:	df 93       	push	r29
    199c:	cf 93       	push	r28
    199e:	00 d0       	rcall	.+0      	; 0x19a0 <Blink_1500ms_task+0x6>
    19a0:	cd b7       	in	r28, 0x3d	; 61
    19a2:	de b7       	in	r29, 0x3e	; 62
    19a4:	9a 83       	std	Y+2, r25	; 0x02
    19a6:	89 83       	std	Y+1, r24	; 0x01
	DDRC |=(1<<0); //PA.0 is output
    19a8:	a4 e3       	ldi	r26, 0x34	; 52
    19aa:	b0 e0       	ldi	r27, 0x00	; 0
    19ac:	e4 e3       	ldi	r30, 0x34	; 52
    19ae:	f0 e0       	ldi	r31, 0x00	; 0
    19b0:	80 81       	ld	r24, Z
    19b2:	81 60       	ori	r24, 0x01	; 1
    19b4:	8c 93       	st	X, r24

	while(1)
	{

		PORTC ^= (1<<0); //toggle PA.0
    19b6:	a5 e3       	ldi	r26, 0x35	; 53
    19b8:	b0 e0       	ldi	r27, 0x00	; 0
    19ba:	e5 e3       	ldi	r30, 0x35	; 53
    19bc:	f0 e0       	ldi	r31, 0x00	; 0
    19be:	90 81       	ld	r25, Z
    19c0:	81 e0       	ldi	r24, 0x01	; 1
    19c2:	89 27       	eor	r24, r25
    19c4:	8c 93       	st	X, r24
		vTaskDelay(1500); //OS Delay
    19c6:	8c ed       	ldi	r24, 0xDC	; 220
    19c8:	95 e0       	ldi	r25, 0x05	; 5
    19ca:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <vTaskDelay>
    19ce:	f3 cf       	rjmp	.-26     	; 0x19b6 <Blink_1500ms_task+0x1c>

000019d0 <Blink_2000ms_task>:
	}
}
//--------------------------------------------------
void Blink_2000ms_task( void *pvParameters)
{
    19d0:	df 93       	push	r29
    19d2:	cf 93       	push	r28
    19d4:	00 d0       	rcall	.+0      	; 0x19d6 <Blink_2000ms_task+0x6>
    19d6:	cd b7       	in	r28, 0x3d	; 61
    19d8:	de b7       	in	r29, 0x3e	; 62
    19da:	9a 83       	std	Y+2, r25	; 0x02
    19dc:	89 83       	std	Y+1, r24	; 0x01
	DDRD |=(1<<0); //PB.0 is output
    19de:	a1 e3       	ldi	r26, 0x31	; 49
    19e0:	b0 e0       	ldi	r27, 0x00	; 0
    19e2:	e1 e3       	ldi	r30, 0x31	; 49
    19e4:	f0 e0       	ldi	r31, 0x00	; 0
    19e6:	80 81       	ld	r24, Z
    19e8:	81 60       	ori	r24, 0x01	; 1
    19ea:	8c 93       	st	X, r24
	
	while(1)
	{
		
		PORTD ^= (1<<0); //toggle PB.0
    19ec:	a2 e3       	ldi	r26, 0x32	; 50
    19ee:	b0 e0       	ldi	r27, 0x00	; 0
    19f0:	e2 e3       	ldi	r30, 0x32	; 50
    19f2:	f0 e0       	ldi	r31, 0x00	; 0
    19f4:	90 81       	ld	r25, Z
    19f6:	81 e0       	ldi	r24, 0x01	; 1
    19f8:	89 27       	eor	r24, r25
    19fa:	8c 93       	st	X, r24
		vTaskDelay(2000); //OS Delay
    19fc:	80 ed       	ldi	r24, 0xD0	; 208
    19fe:	97 e0       	ldi	r25, 0x07	; 7
    1a00:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <vTaskDelay>
    1a04:	f3 cf       	rjmp	.-26     	; 0x19ec <Blink_2000ms_task+0x1c>

00001a06 <main>:

//================= [Main] ====================
#include <avr/io.h>

int main(void)
{
    1a06:	af 92       	push	r10
    1a08:	bf 92       	push	r11
    1a0a:	cf 92       	push	r12
    1a0c:	df 92       	push	r13
    1a0e:	ef 92       	push	r14
    1a10:	ff 92       	push	r15
    1a12:	0f 93       	push	r16
    1a14:	df 93       	push	r29
    1a16:	cf 93       	push	r28
    1a18:	cd b7       	in	r28, 0x3d	; 61
    1a1a:	de b7       	in	r29, 0x3e	; 62
	// Create Tasks
	xTaskCreate( Blink_500ms_task,NULL, configMINIMAL_STACK_SIZE, NULL, 2, NULL );
    1a1c:	87 e9       	ldi	r24, 0x97	; 151
    1a1e:	9c e0       	ldi	r25, 0x0C	; 12
    1a20:	60 e0       	ldi	r22, 0x00	; 0
    1a22:	70 e0       	ldi	r23, 0x00	; 0
    1a24:	45 e5       	ldi	r20, 0x55	; 85
    1a26:	50 e0       	ldi	r21, 0x00	; 0
    1a28:	20 e0       	ldi	r18, 0x00	; 0
    1a2a:	30 e0       	ldi	r19, 0x00	; 0
    1a2c:	02 e0       	ldi	r16, 0x02	; 2
    1a2e:	ee 24       	eor	r14, r14
    1a30:	ff 24       	eor	r15, r15
    1a32:	cc 24       	eor	r12, r12
    1a34:	dd 24       	eor	r13, r13
    1a36:	aa 24       	eor	r10, r10
    1a38:	bb 24       	eor	r11, r11
    1a3a:	0e 94 32 19 	call	0x3264	; 0x3264 <xTaskGenericCreate>
	xTaskCreate( Blink_1000ms_task,NULL, configMINIMAL_STACK_SIZE, NULL, 2, NULL );
    1a3e:	82 eb       	ldi	r24, 0xB2	; 178
    1a40:	9c e0       	ldi	r25, 0x0C	; 12
    1a42:	60 e0       	ldi	r22, 0x00	; 0
    1a44:	70 e0       	ldi	r23, 0x00	; 0
    1a46:	45 e5       	ldi	r20, 0x55	; 85
    1a48:	50 e0       	ldi	r21, 0x00	; 0
    1a4a:	20 e0       	ldi	r18, 0x00	; 0
    1a4c:	30 e0       	ldi	r19, 0x00	; 0
    1a4e:	02 e0       	ldi	r16, 0x02	; 2
    1a50:	ee 24       	eor	r14, r14
    1a52:	ff 24       	eor	r15, r15
    1a54:	cc 24       	eor	r12, r12
    1a56:	dd 24       	eor	r13, r13
    1a58:	aa 24       	eor	r10, r10
    1a5a:	bb 24       	eor	r11, r11
    1a5c:	0e 94 32 19 	call	0x3264	; 0x3264 <xTaskGenericCreate>
	xTaskCreate( Blink_1500ms_task,NULL, configMINIMAL_STACK_SIZE, NULL, 2, NULL );
    1a60:	8d ec       	ldi	r24, 0xCD	; 205
    1a62:	9c e0       	ldi	r25, 0x0C	; 12
    1a64:	60 e0       	ldi	r22, 0x00	; 0
    1a66:	70 e0       	ldi	r23, 0x00	; 0
    1a68:	45 e5       	ldi	r20, 0x55	; 85
    1a6a:	50 e0       	ldi	r21, 0x00	; 0
    1a6c:	20 e0       	ldi	r18, 0x00	; 0
    1a6e:	30 e0       	ldi	r19, 0x00	; 0
    1a70:	02 e0       	ldi	r16, 0x02	; 2
    1a72:	ee 24       	eor	r14, r14
    1a74:	ff 24       	eor	r15, r15
    1a76:	cc 24       	eor	r12, r12
    1a78:	dd 24       	eor	r13, r13
    1a7a:	aa 24       	eor	r10, r10
    1a7c:	bb 24       	eor	r11, r11
    1a7e:	0e 94 32 19 	call	0x3264	; 0x3264 <xTaskGenericCreate>
	xTaskCreate( Blink_2000ms_task,NULL, configMINIMAL_STACK_SIZE, NULL, 2, NULL );
    1a82:	88 ee       	ldi	r24, 0xE8	; 232
    1a84:	9c e0       	ldi	r25, 0x0C	; 12
    1a86:	60 e0       	ldi	r22, 0x00	; 0
    1a88:	70 e0       	ldi	r23, 0x00	; 0
    1a8a:	45 e5       	ldi	r20, 0x55	; 85
    1a8c:	50 e0       	ldi	r21, 0x00	; 0
    1a8e:	20 e0       	ldi	r18, 0x00	; 0
    1a90:	30 e0       	ldi	r19, 0x00	; 0
    1a92:	02 e0       	ldi	r16, 0x02	; 2
    1a94:	ee 24       	eor	r14, r14
    1a96:	ff 24       	eor	r15, r15
    1a98:	cc 24       	eor	r12, r12
    1a9a:	dd 24       	eor	r13, r13
    1a9c:	aa 24       	eor	r10, r10
    1a9e:	bb 24       	eor	r11, r11
    1aa0:	0e 94 32 19 	call	0x3264	; 0x3264 <xTaskGenericCreate>

	// Start FreeRTOS
	vTaskStartScheduler();
    1aa4:	0e 94 2b 1b 	call	0x3656	; 0x3656 <vTaskStartScheduler>
    1aa8:	80 e0       	ldi	r24, 0x00	; 0
    1aaa:	90 e0       	ldi	r25, 0x00	; 0
	
}
    1aac:	cf 91       	pop	r28
    1aae:	df 91       	pop	r29
    1ab0:	0f 91       	pop	r16
    1ab2:	ff 90       	pop	r15
    1ab4:	ef 90       	pop	r14
    1ab6:	df 90       	pop	r13
    1ab8:	cf 90       	pop	r12
    1aba:	bf 90       	pop	r11
    1abc:	af 90       	pop	r10
    1abe:	08 95       	ret

00001ac0 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    1ac0:	df 93       	push	r29
    1ac2:	cf 93       	push	r28
    1ac4:	cd b7       	in	r28, 0x3d	; 61
    1ac6:	de b7       	in	r29, 0x3e	; 62
    1ac8:	27 97       	sbiw	r28, 0x07	; 7
    1aca:	0f b6       	in	r0, 0x3f	; 63
    1acc:	f8 94       	cli
    1ace:	de bf       	out	0x3e, r29	; 62
    1ad0:	0f be       	out	0x3f, r0	; 63
    1ad2:	cd bf       	out	0x3d, r28	; 61
    1ad4:	9d 83       	std	Y+5, r25	; 0x05
    1ad6:	8c 83       	std	Y+4, r24	; 0x04
    1ad8:	6e 83       	std	Y+6, r22	; 0x06
    1ada:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    1adc:	8a e1       	ldi	r24, 0x1A	; 26
    1ade:	90 e0       	ldi	r25, 0x00	; 0
    1ae0:	0e 94 38 10 	call	0x2070	; 0x2070 <pvPortMalloc>
    1ae4:	9a 83       	std	Y+2, r25	; 0x02
    1ae6:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    1ae8:	89 81       	ldd	r24, Y+1	; 0x01
    1aea:	9a 81       	ldd	r25, Y+2	; 0x02
    1aec:	00 97       	sbiw	r24, 0x00	; 0
    1aee:	09 f4       	brne	.+2      	; 0x1af2 <xCoRoutineCreate+0x32>
    1af0:	6f c0       	rjmp	.+222    	; 0x1bd0 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1af2:	80 91 70 00 	lds	r24, 0x0070
    1af6:	90 91 71 00 	lds	r25, 0x0071
    1afa:	00 97       	sbiw	r24, 0x00	; 0
    1afc:	41 f4       	brne	.+16     	; 0x1b0e <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1afe:	89 81       	ldd	r24, Y+1	; 0x01
    1b00:	9a 81       	ldd	r25, Y+2	; 0x02
    1b02:	90 93 71 00 	sts	0x0071, r25
    1b06:	80 93 70 00 	sts	0x0070, r24
			prvInitialiseCoRoutineLists();
    1b0a:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    1b0e:	8e 81       	ldd	r24, Y+6	; 0x06
    1b10:	82 30       	cpi	r24, 0x02	; 2
    1b12:	10 f0       	brcs	.+4      	; 0x1b18 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    1b14:	81 e0       	ldi	r24, 0x01	; 1
    1b16:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1b18:	e9 81       	ldd	r30, Y+1	; 0x01
    1b1a:	fa 81       	ldd	r31, Y+2	; 0x02
    1b1c:	11 8e       	std	Z+25, r1	; 0x19
    1b1e:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1b20:	e9 81       	ldd	r30, Y+1	; 0x01
    1b22:	fa 81       	ldd	r31, Y+2	; 0x02
    1b24:	8e 81       	ldd	r24, Y+6	; 0x06
    1b26:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1b28:	e9 81       	ldd	r30, Y+1	; 0x01
    1b2a:	fa 81       	ldd	r31, Y+2	; 0x02
    1b2c:	8f 81       	ldd	r24, Y+7	; 0x07
    1b2e:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1b30:	e9 81       	ldd	r30, Y+1	; 0x01
    1b32:	fa 81       	ldd	r31, Y+2	; 0x02
    1b34:	8c 81       	ldd	r24, Y+4	; 0x04
    1b36:	9d 81       	ldd	r25, Y+5	; 0x05
    1b38:	91 83       	std	Z+1, r25	; 0x01
    1b3a:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1b3c:	89 81       	ldd	r24, Y+1	; 0x01
    1b3e:	9a 81       	ldd	r25, Y+2	; 0x02
    1b40:	02 96       	adiw	r24, 0x02	; 2
    1b42:	0e 94 ce 10 	call	0x219c	; 0x219c <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1b46:	89 81       	ldd	r24, Y+1	; 0x01
    1b48:	9a 81       	ldd	r25, Y+2	; 0x02
    1b4a:	0c 96       	adiw	r24, 0x0c	; 12
    1b4c:	0e 94 ce 10 	call	0x219c	; 0x219c <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1b50:	e9 81       	ldd	r30, Y+1	; 0x01
    1b52:	fa 81       	ldd	r31, Y+2	; 0x02
    1b54:	89 81       	ldd	r24, Y+1	; 0x01
    1b56:	9a 81       	ldd	r25, Y+2	; 0x02
    1b58:	91 87       	std	Z+9, r25	; 0x09
    1b5a:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1b5c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b5e:	fa 81       	ldd	r31, Y+2	; 0x02
    1b60:	89 81       	ldd	r24, Y+1	; 0x01
    1b62:	9a 81       	ldd	r25, Y+2	; 0x02
    1b64:	93 8b       	std	Z+19, r25	; 0x13
    1b66:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1b68:	8e 81       	ldd	r24, Y+6	; 0x06
    1b6a:	28 2f       	mov	r18, r24
    1b6c:	30 e0       	ldi	r19, 0x00	; 0
    1b6e:	83 e0       	ldi	r24, 0x03	; 3
    1b70:	90 e0       	ldi	r25, 0x00	; 0
    1b72:	82 1b       	sub	r24, r18
    1b74:	93 0b       	sbc	r25, r19
    1b76:	e9 81       	ldd	r30, Y+1	; 0x01
    1b78:	fa 81       	ldd	r31, Y+2	; 0x02
    1b7a:	95 87       	std	Z+13, r25	; 0x0d
    1b7c:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1b7e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b80:	fa 81       	ldd	r31, Y+2	; 0x02
    1b82:	96 89       	ldd	r25, Z+22	; 0x16
    1b84:	80 91 72 00 	lds	r24, 0x0072
    1b88:	89 17       	cp	r24, r25
    1b8a:	28 f4       	brcc	.+10     	; 0x1b96 <xCoRoutineCreate+0xd6>
    1b8c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b8e:	fa 81       	ldd	r31, Y+2	; 0x02
    1b90:	86 89       	ldd	r24, Z+22	; 0x16
    1b92:	80 93 72 00 	sts	0x0072, r24
    1b96:	e9 81       	ldd	r30, Y+1	; 0x01
    1b98:	fa 81       	ldd	r31, Y+2	; 0x02
    1b9a:	86 89       	ldd	r24, Z+22	; 0x16
    1b9c:	28 2f       	mov	r18, r24
    1b9e:	30 e0       	ldi	r19, 0x00	; 0
    1ba0:	c9 01       	movw	r24, r18
    1ba2:	88 0f       	add	r24, r24
    1ba4:	99 1f       	adc	r25, r25
    1ba6:	88 0f       	add	r24, r24
    1ba8:	99 1f       	adc	r25, r25
    1baa:	88 0f       	add	r24, r24
    1bac:	99 1f       	adc	r25, r25
    1bae:	82 0f       	add	r24, r18
    1bb0:	93 1f       	adc	r25, r19
    1bb2:	ac 01       	movw	r20, r24
    1bb4:	47 58       	subi	r20, 0x87	; 135
    1bb6:	5f 4f       	sbci	r21, 0xFF	; 255
    1bb8:	89 81       	ldd	r24, Y+1	; 0x01
    1bba:	9a 81       	ldd	r25, Y+2	; 0x02
    1bbc:	9c 01       	movw	r18, r24
    1bbe:	2e 5f       	subi	r18, 0xFE	; 254
    1bc0:	3f 4f       	sbci	r19, 0xFF	; 255
    1bc2:	ca 01       	movw	r24, r20
    1bc4:	b9 01       	movw	r22, r18
    1bc6:	0e 94 de 10 	call	0x21bc	; 0x21bc <vListInsertEnd>

		xReturn = pdPASS;
    1bca:	81 e0       	ldi	r24, 0x01	; 1
    1bcc:	8b 83       	std	Y+3, r24	; 0x03
    1bce:	02 c0       	rjmp	.+4      	; 0x1bd4 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1bd0:	8f ef       	ldi	r24, 0xFF	; 255
    1bd2:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    1bd4:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1bd6:	27 96       	adiw	r28, 0x07	; 7
    1bd8:	0f b6       	in	r0, 0x3f	; 63
    1bda:	f8 94       	cli
    1bdc:	de bf       	out	0x3e, r29	; 62
    1bde:	0f be       	out	0x3f, r0	; 63
    1be0:	cd bf       	out	0x3d, r28	; 61
    1be2:	cf 91       	pop	r28
    1be4:	df 91       	pop	r29
    1be6:	08 95       	ret

00001be8 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    1be8:	df 93       	push	r29
    1bea:	cf 93       	push	r28
    1bec:	00 d0       	rcall	.+0      	; 0x1bee <vCoRoutineAddToDelayedList+0x6>
    1bee:	00 d0       	rcall	.+0      	; 0x1bf0 <vCoRoutineAddToDelayedList+0x8>
    1bf0:	00 d0       	rcall	.+0      	; 0x1bf2 <vCoRoutineAddToDelayedList+0xa>
    1bf2:	cd b7       	in	r28, 0x3d	; 61
    1bf4:	de b7       	in	r29, 0x3e	; 62
    1bf6:	9c 83       	std	Y+4, r25	; 0x04
    1bf8:	8b 83       	std	Y+3, r24	; 0x03
    1bfa:	7e 83       	std	Y+6, r23	; 0x06
    1bfc:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1bfe:	20 91 73 00 	lds	r18, 0x0073
    1c02:	30 91 74 00 	lds	r19, 0x0074
    1c06:	8b 81       	ldd	r24, Y+3	; 0x03
    1c08:	9c 81       	ldd	r25, Y+4	; 0x04
    1c0a:	82 0f       	add	r24, r18
    1c0c:	93 1f       	adc	r25, r19
    1c0e:	9a 83       	std	Y+2, r25	; 0x02
    1c10:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1c12:	80 91 70 00 	lds	r24, 0x0070
    1c16:	90 91 71 00 	lds	r25, 0x0071
    1c1a:	02 96       	adiw	r24, 0x02	; 2
    1c1c:	0e 94 96 11 	call	0x232c	; 0x232c <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1c20:	e0 91 70 00 	lds	r30, 0x0070
    1c24:	f0 91 71 00 	lds	r31, 0x0071
    1c28:	89 81       	ldd	r24, Y+1	; 0x01
    1c2a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c2c:	93 83       	std	Z+3, r25	; 0x03
    1c2e:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1c30:	20 91 73 00 	lds	r18, 0x0073
    1c34:	30 91 74 00 	lds	r19, 0x0074
    1c38:	89 81       	ldd	r24, Y+1	; 0x01
    1c3a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c3c:	82 17       	cp	r24, r18
    1c3e:	93 07       	cpc	r25, r19
    1c40:	70 f4       	brcc	.+28     	; 0x1c5e <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1c42:	80 91 9f 00 	lds	r24, 0x009F
    1c46:	90 91 a0 00 	lds	r25, 0x00A0
    1c4a:	20 91 70 00 	lds	r18, 0x0070
    1c4e:	30 91 71 00 	lds	r19, 0x0071
    1c52:	2e 5f       	subi	r18, 0xFE	; 254
    1c54:	3f 4f       	sbci	r19, 0xFF	; 255
    1c56:	b9 01       	movw	r22, r18
    1c58:	0e 94 2a 11 	call	0x2254	; 0x2254 <vListInsert>
    1c5c:	0d c0       	rjmp	.+26     	; 0x1c78 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1c5e:	80 91 9d 00 	lds	r24, 0x009D
    1c62:	90 91 9e 00 	lds	r25, 0x009E
    1c66:	20 91 70 00 	lds	r18, 0x0070
    1c6a:	30 91 71 00 	lds	r19, 0x0071
    1c6e:	2e 5f       	subi	r18, 0xFE	; 254
    1c70:	3f 4f       	sbci	r19, 0xFF	; 255
    1c72:	b9 01       	movw	r22, r18
    1c74:	0e 94 2a 11 	call	0x2254	; 0x2254 <vListInsert>
	}

	if( pxEventList )
    1c78:	8d 81       	ldd	r24, Y+5	; 0x05
    1c7a:	9e 81       	ldd	r25, Y+6	; 0x06
    1c7c:	00 97       	sbiw	r24, 0x00	; 0
    1c7e:	61 f0       	breq	.+24     	; 0x1c98 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1c80:	80 91 70 00 	lds	r24, 0x0070
    1c84:	90 91 71 00 	lds	r25, 0x0071
    1c88:	9c 01       	movw	r18, r24
    1c8a:	24 5f       	subi	r18, 0xF4	; 244
    1c8c:	3f 4f       	sbci	r19, 0xFF	; 255
    1c8e:	8d 81       	ldd	r24, Y+5	; 0x05
    1c90:	9e 81       	ldd	r25, Y+6	; 0x06
    1c92:	b9 01       	movw	r22, r18
    1c94:	0e 94 2a 11 	call	0x2254	; 0x2254 <vListInsert>
	}
}
    1c98:	26 96       	adiw	r28, 0x06	; 6
    1c9a:	0f b6       	in	r0, 0x3f	; 63
    1c9c:	f8 94       	cli
    1c9e:	de bf       	out	0x3e, r29	; 62
    1ca0:	0f be       	out	0x3f, r0	; 63
    1ca2:	cd bf       	out	0x3d, r28	; 61
    1ca4:	cf 91       	pop	r28
    1ca6:	df 91       	pop	r29
    1ca8:	08 95       	ret

00001caa <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    1caa:	df 93       	push	r29
    1cac:	cf 93       	push	r28
    1cae:	00 d0       	rcall	.+0      	; 0x1cb0 <prvCheckPendingReadyList+0x6>
    1cb0:	cd b7       	in	r28, 0x3d	; 61
    1cb2:	de b7       	in	r29, 0x3e	; 62
    1cb4:	3a c0       	rjmp	.+116    	; 0x1d2a <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1cb6:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    1cb8:	e0 91 a6 00 	lds	r30, 0x00A6
    1cbc:	f0 91 a7 00 	lds	r31, 0x00A7
    1cc0:	86 81       	ldd	r24, Z+6	; 0x06
    1cc2:	97 81       	ldd	r25, Z+7	; 0x07
    1cc4:	9a 83       	std	Y+2, r25	; 0x02
    1cc6:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1cc8:	89 81       	ldd	r24, Y+1	; 0x01
    1cca:	9a 81       	ldd	r25, Y+2	; 0x02
    1ccc:	0c 96       	adiw	r24, 0x0c	; 12
    1cce:	0e 94 96 11 	call	0x232c	; 0x232c <vListRemove>
		}
		portENABLE_INTERRUPTS();
    1cd2:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1cd4:	89 81       	ldd	r24, Y+1	; 0x01
    1cd6:	9a 81       	ldd	r25, Y+2	; 0x02
    1cd8:	02 96       	adiw	r24, 0x02	; 2
    1cda:	0e 94 96 11 	call	0x232c	; 0x232c <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    1cde:	e9 81       	ldd	r30, Y+1	; 0x01
    1ce0:	fa 81       	ldd	r31, Y+2	; 0x02
    1ce2:	96 89       	ldd	r25, Z+22	; 0x16
    1ce4:	80 91 72 00 	lds	r24, 0x0072
    1ce8:	89 17       	cp	r24, r25
    1cea:	28 f4       	brcc	.+10     	; 0x1cf6 <prvCheckPendingReadyList+0x4c>
    1cec:	e9 81       	ldd	r30, Y+1	; 0x01
    1cee:	fa 81       	ldd	r31, Y+2	; 0x02
    1cf0:	86 89       	ldd	r24, Z+22	; 0x16
    1cf2:	80 93 72 00 	sts	0x0072, r24
    1cf6:	e9 81       	ldd	r30, Y+1	; 0x01
    1cf8:	fa 81       	ldd	r31, Y+2	; 0x02
    1cfa:	86 89       	ldd	r24, Z+22	; 0x16
    1cfc:	28 2f       	mov	r18, r24
    1cfe:	30 e0       	ldi	r19, 0x00	; 0
    1d00:	c9 01       	movw	r24, r18
    1d02:	88 0f       	add	r24, r24
    1d04:	99 1f       	adc	r25, r25
    1d06:	88 0f       	add	r24, r24
    1d08:	99 1f       	adc	r25, r25
    1d0a:	88 0f       	add	r24, r24
    1d0c:	99 1f       	adc	r25, r25
    1d0e:	82 0f       	add	r24, r18
    1d10:	93 1f       	adc	r25, r19
    1d12:	ac 01       	movw	r20, r24
    1d14:	47 58       	subi	r20, 0x87	; 135
    1d16:	5f 4f       	sbci	r21, 0xFF	; 255
    1d18:	89 81       	ldd	r24, Y+1	; 0x01
    1d1a:	9a 81       	ldd	r25, Y+2	; 0x02
    1d1c:	9c 01       	movw	r18, r24
    1d1e:	2e 5f       	subi	r18, 0xFE	; 254
    1d20:	3f 4f       	sbci	r19, 0xFF	; 255
    1d22:	ca 01       	movw	r24, r20
    1d24:	b9 01       	movw	r22, r18
    1d26:	0e 94 de 10 	call	0x21bc	; 0x21bc <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1d2a:	80 91 a1 00 	lds	r24, 0x00A1
    1d2e:	88 23       	and	r24, r24
    1d30:	09 f0       	breq	.+2      	; 0x1d34 <prvCheckPendingReadyList+0x8a>
    1d32:	c1 cf       	rjmp	.-126    	; 0x1cb6 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    1d34:	0f 90       	pop	r0
    1d36:	0f 90       	pop	r0
    1d38:	cf 91       	pop	r28
    1d3a:	df 91       	pop	r29
    1d3c:	08 95       	ret

00001d3e <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    1d3e:	df 93       	push	r29
    1d40:	cf 93       	push	r28
    1d42:	00 d0       	rcall	.+0      	; 0x1d44 <prvCheckDelayedList+0x6>
    1d44:	00 d0       	rcall	.+0      	; 0x1d46 <prvCheckDelayedList+0x8>
    1d46:	cd b7       	in	r28, 0x3d	; 61
    1d48:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1d4a:	0e 94 04 1c 	call	0x3808	; 0x3808 <xTaskGetTickCount>
    1d4e:	20 91 75 00 	lds	r18, 0x0075
    1d52:	30 91 76 00 	lds	r19, 0x0076
    1d56:	82 1b       	sub	r24, r18
    1d58:	93 0b       	sbc	r25, r19
    1d5a:	90 93 78 00 	sts	0x0078, r25
    1d5e:	80 93 77 00 	sts	0x0077, r24
    1d62:	85 c0       	rjmp	.+266    	; 0x1e6e <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    1d64:	80 91 73 00 	lds	r24, 0x0073
    1d68:	90 91 74 00 	lds	r25, 0x0074
    1d6c:	01 96       	adiw	r24, 0x01	; 1
    1d6e:	90 93 74 00 	sts	0x0074, r25
    1d72:	80 93 73 00 	sts	0x0073, r24
		xPassedTicks--;
    1d76:	80 91 77 00 	lds	r24, 0x0077
    1d7a:	90 91 78 00 	lds	r25, 0x0078
    1d7e:	01 97       	sbiw	r24, 0x01	; 1
    1d80:	90 93 78 00 	sts	0x0078, r25
    1d84:	80 93 77 00 	sts	0x0077, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1d88:	80 91 73 00 	lds	r24, 0x0073
    1d8c:	90 91 74 00 	lds	r25, 0x0074
    1d90:	00 97       	sbiw	r24, 0x00	; 0
    1d92:	09 f0       	breq	.+2      	; 0x1d96 <prvCheckDelayedList+0x58>
    1d94:	64 c0       	rjmp	.+200    	; 0x1e5e <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1d96:	80 91 9d 00 	lds	r24, 0x009D
    1d9a:	90 91 9e 00 	lds	r25, 0x009E
    1d9e:	9a 83       	std	Y+2, r25	; 0x02
    1da0:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1da2:	80 91 9f 00 	lds	r24, 0x009F
    1da6:	90 91 a0 00 	lds	r25, 0x00A0
    1daa:	90 93 9e 00 	sts	0x009E, r25
    1dae:	80 93 9d 00 	sts	0x009D, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    1db2:	89 81       	ldd	r24, Y+1	; 0x01
    1db4:	9a 81       	ldd	r25, Y+2	; 0x02
    1db6:	90 93 a0 00 	sts	0x00A0, r25
    1dba:	80 93 9f 00 	sts	0x009F, r24
    1dbe:	4f c0       	rjmp	.+158    	; 0x1e5e <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1dc0:	e0 91 9d 00 	lds	r30, 0x009D
    1dc4:	f0 91 9e 00 	lds	r31, 0x009E
    1dc8:	05 80       	ldd	r0, Z+5	; 0x05
    1dca:	f6 81       	ldd	r31, Z+6	; 0x06
    1dcc:	e0 2d       	mov	r30, r0
    1dce:	86 81       	ldd	r24, Z+6	; 0x06
    1dd0:	97 81       	ldd	r25, Z+7	; 0x07
    1dd2:	9c 83       	std	Y+4, r25	; 0x04
    1dd4:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    1dd6:	eb 81       	ldd	r30, Y+3	; 0x03
    1dd8:	fc 81       	ldd	r31, Y+4	; 0x04
    1dda:	22 81       	ldd	r18, Z+2	; 0x02
    1ddc:	33 81       	ldd	r19, Z+3	; 0x03
    1dde:	80 91 73 00 	lds	r24, 0x0073
    1de2:	90 91 74 00 	lds	r25, 0x0074
    1de6:	82 17       	cp	r24, r18
    1de8:	93 07       	cpc	r25, r19
    1dea:	08 f4       	brcc	.+2      	; 0x1dee <prvCheckDelayedList+0xb0>
    1dec:	40 c0       	rjmp	.+128    	; 0x1e6e <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    1dee:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    1df0:	8b 81       	ldd	r24, Y+3	; 0x03
    1df2:	9c 81       	ldd	r25, Y+4	; 0x04
    1df4:	02 96       	adiw	r24, 0x02	; 2
    1df6:	0e 94 96 11 	call	0x232c	; 0x232c <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    1dfa:	eb 81       	ldd	r30, Y+3	; 0x03
    1dfc:	fc 81       	ldd	r31, Y+4	; 0x04
    1dfe:	84 89       	ldd	r24, Z+20	; 0x14
    1e00:	95 89       	ldd	r25, Z+21	; 0x15
    1e02:	00 97       	sbiw	r24, 0x00	; 0
    1e04:	29 f0       	breq	.+10     	; 0x1e10 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    1e06:	8b 81       	ldd	r24, Y+3	; 0x03
    1e08:	9c 81       	ldd	r25, Y+4	; 0x04
    1e0a:	0c 96       	adiw	r24, 0x0c	; 12
    1e0c:	0e 94 96 11 	call	0x232c	; 0x232c <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1e10:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    1e12:	eb 81       	ldd	r30, Y+3	; 0x03
    1e14:	fc 81       	ldd	r31, Y+4	; 0x04
    1e16:	96 89       	ldd	r25, Z+22	; 0x16
    1e18:	80 91 72 00 	lds	r24, 0x0072
    1e1c:	89 17       	cp	r24, r25
    1e1e:	28 f4       	brcc	.+10     	; 0x1e2a <prvCheckDelayedList+0xec>
    1e20:	eb 81       	ldd	r30, Y+3	; 0x03
    1e22:	fc 81       	ldd	r31, Y+4	; 0x04
    1e24:	86 89       	ldd	r24, Z+22	; 0x16
    1e26:	80 93 72 00 	sts	0x0072, r24
    1e2a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e2c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e2e:	86 89       	ldd	r24, Z+22	; 0x16
    1e30:	28 2f       	mov	r18, r24
    1e32:	30 e0       	ldi	r19, 0x00	; 0
    1e34:	c9 01       	movw	r24, r18
    1e36:	88 0f       	add	r24, r24
    1e38:	99 1f       	adc	r25, r25
    1e3a:	88 0f       	add	r24, r24
    1e3c:	99 1f       	adc	r25, r25
    1e3e:	88 0f       	add	r24, r24
    1e40:	99 1f       	adc	r25, r25
    1e42:	82 0f       	add	r24, r18
    1e44:	93 1f       	adc	r25, r19
    1e46:	ac 01       	movw	r20, r24
    1e48:	47 58       	subi	r20, 0x87	; 135
    1e4a:	5f 4f       	sbci	r21, 0xFF	; 255
    1e4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e4e:	9c 81       	ldd	r25, Y+4	; 0x04
    1e50:	9c 01       	movw	r18, r24
    1e52:	2e 5f       	subi	r18, 0xFE	; 254
    1e54:	3f 4f       	sbci	r19, 0xFF	; 255
    1e56:	ca 01       	movw	r24, r20
    1e58:	b9 01       	movw	r22, r18
    1e5a:	0e 94 de 10 	call	0x21bc	; 0x21bc <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1e5e:	e0 91 9d 00 	lds	r30, 0x009D
    1e62:	f0 91 9e 00 	lds	r31, 0x009E
    1e66:	80 81       	ld	r24, Z
    1e68:	88 23       	and	r24, r24
    1e6a:	09 f0       	breq	.+2      	; 0x1e6e <prvCheckDelayedList+0x130>
    1e6c:	a9 cf       	rjmp	.-174    	; 0x1dc0 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1e6e:	80 91 77 00 	lds	r24, 0x0077
    1e72:	90 91 78 00 	lds	r25, 0x0078
    1e76:	00 97       	sbiw	r24, 0x00	; 0
    1e78:	09 f0       	breq	.+2      	; 0x1e7c <prvCheckDelayedList+0x13e>
    1e7a:	74 cf       	rjmp	.-280    	; 0x1d64 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    1e7c:	80 91 73 00 	lds	r24, 0x0073
    1e80:	90 91 74 00 	lds	r25, 0x0074
    1e84:	90 93 76 00 	sts	0x0076, r25
    1e88:	80 93 75 00 	sts	0x0075, r24
}
    1e8c:	0f 90       	pop	r0
    1e8e:	0f 90       	pop	r0
    1e90:	0f 90       	pop	r0
    1e92:	0f 90       	pop	r0
    1e94:	cf 91       	pop	r28
    1e96:	df 91       	pop	r29
    1e98:	08 95       	ret

00001e9a <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1e9a:	df 93       	push	r29
    1e9c:	cf 93       	push	r28
    1e9e:	00 d0       	rcall	.+0      	; 0x1ea0 <vCoRoutineSchedule+0x6>
    1ea0:	cd b7       	in	r28, 0x3d	; 61
    1ea2:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    1ea4:	0e 94 55 0e 	call	0x1caa	; 0x1caa <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    1ea8:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <prvCheckDelayedList>
    1eac:	0a c0       	rjmp	.+20     	; 0x1ec2 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1eae:	80 91 72 00 	lds	r24, 0x0072
    1eb2:	88 23       	and	r24, r24
    1eb4:	09 f4       	brne	.+2      	; 0x1eb8 <vCoRoutineSchedule+0x1e>
    1eb6:	66 c0       	rjmp	.+204    	; 0x1f84 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1eb8:	80 91 72 00 	lds	r24, 0x0072
    1ebc:	81 50       	subi	r24, 0x01	; 1
    1ebe:	80 93 72 00 	sts	0x0072, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1ec2:	80 91 72 00 	lds	r24, 0x0072
    1ec6:	28 2f       	mov	r18, r24
    1ec8:	30 e0       	ldi	r19, 0x00	; 0
    1eca:	c9 01       	movw	r24, r18
    1ecc:	88 0f       	add	r24, r24
    1ece:	99 1f       	adc	r25, r25
    1ed0:	88 0f       	add	r24, r24
    1ed2:	99 1f       	adc	r25, r25
    1ed4:	88 0f       	add	r24, r24
    1ed6:	99 1f       	adc	r25, r25
    1ed8:	82 0f       	add	r24, r18
    1eda:	93 1f       	adc	r25, r19
    1edc:	fc 01       	movw	r30, r24
    1ede:	e7 58       	subi	r30, 0x87	; 135
    1ee0:	ff 4f       	sbci	r31, 0xFF	; 255
    1ee2:	80 81       	ld	r24, Z
    1ee4:	88 23       	and	r24, r24
    1ee6:	19 f3       	breq	.-58     	; 0x1eae <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1ee8:	80 91 72 00 	lds	r24, 0x0072
    1eec:	28 2f       	mov	r18, r24
    1eee:	30 e0       	ldi	r19, 0x00	; 0
    1ef0:	c9 01       	movw	r24, r18
    1ef2:	88 0f       	add	r24, r24
    1ef4:	99 1f       	adc	r25, r25
    1ef6:	88 0f       	add	r24, r24
    1ef8:	99 1f       	adc	r25, r25
    1efa:	88 0f       	add	r24, r24
    1efc:	99 1f       	adc	r25, r25
    1efe:	82 0f       	add	r24, r18
    1f00:	93 1f       	adc	r25, r19
    1f02:	87 58       	subi	r24, 0x87	; 135
    1f04:	9f 4f       	sbci	r25, 0xFF	; 255
    1f06:	9a 83       	std	Y+2, r25	; 0x02
    1f08:	89 83       	std	Y+1, r24	; 0x01
    1f0a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f0c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f0e:	01 80       	ldd	r0, Z+1	; 0x01
    1f10:	f2 81       	ldd	r31, Z+2	; 0x02
    1f12:	e0 2d       	mov	r30, r0
    1f14:	82 81       	ldd	r24, Z+2	; 0x02
    1f16:	93 81       	ldd	r25, Z+3	; 0x03
    1f18:	e9 81       	ldd	r30, Y+1	; 0x01
    1f1a:	fa 81       	ldd	r31, Y+2	; 0x02
    1f1c:	92 83       	std	Z+2, r25	; 0x02
    1f1e:	81 83       	std	Z+1, r24	; 0x01
    1f20:	e9 81       	ldd	r30, Y+1	; 0x01
    1f22:	fa 81       	ldd	r31, Y+2	; 0x02
    1f24:	21 81       	ldd	r18, Z+1	; 0x01
    1f26:	32 81       	ldd	r19, Z+2	; 0x02
    1f28:	89 81       	ldd	r24, Y+1	; 0x01
    1f2a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f2c:	03 96       	adiw	r24, 0x03	; 3
    1f2e:	28 17       	cp	r18, r24
    1f30:	39 07       	cpc	r19, r25
    1f32:	59 f4       	brne	.+22     	; 0x1f4a <vCoRoutineSchedule+0xb0>
    1f34:	e9 81       	ldd	r30, Y+1	; 0x01
    1f36:	fa 81       	ldd	r31, Y+2	; 0x02
    1f38:	01 80       	ldd	r0, Z+1	; 0x01
    1f3a:	f2 81       	ldd	r31, Z+2	; 0x02
    1f3c:	e0 2d       	mov	r30, r0
    1f3e:	82 81       	ldd	r24, Z+2	; 0x02
    1f40:	93 81       	ldd	r25, Z+3	; 0x03
    1f42:	e9 81       	ldd	r30, Y+1	; 0x01
    1f44:	fa 81       	ldd	r31, Y+2	; 0x02
    1f46:	92 83       	std	Z+2, r25	; 0x02
    1f48:	81 83       	std	Z+1, r24	; 0x01
    1f4a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f4c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f4e:	01 80       	ldd	r0, Z+1	; 0x01
    1f50:	f2 81       	ldd	r31, Z+2	; 0x02
    1f52:	e0 2d       	mov	r30, r0
    1f54:	86 81       	ldd	r24, Z+6	; 0x06
    1f56:	97 81       	ldd	r25, Z+7	; 0x07
    1f58:	90 93 71 00 	sts	0x0071, r25
    1f5c:	80 93 70 00 	sts	0x0070, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1f60:	e0 91 70 00 	lds	r30, 0x0070
    1f64:	f0 91 71 00 	lds	r31, 0x0071
    1f68:	40 81       	ld	r20, Z
    1f6a:	51 81       	ldd	r21, Z+1	; 0x01
    1f6c:	80 91 70 00 	lds	r24, 0x0070
    1f70:	90 91 71 00 	lds	r25, 0x0071
    1f74:	e0 91 70 00 	lds	r30, 0x0070
    1f78:	f0 91 71 00 	lds	r31, 0x0071
    1f7c:	27 89       	ldd	r18, Z+23	; 0x17
    1f7e:	62 2f       	mov	r22, r18
    1f80:	fa 01       	movw	r30, r20
    1f82:	09 95       	icall

	return;
}
    1f84:	0f 90       	pop	r0
    1f86:	0f 90       	pop	r0
    1f88:	cf 91       	pop	r28
    1f8a:	df 91       	pop	r29
    1f8c:	08 95       	ret

00001f8e <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    1f8e:	df 93       	push	r29
    1f90:	cf 93       	push	r28
    1f92:	0f 92       	push	r0
    1f94:	cd b7       	in	r28, 0x3d	; 61
    1f96:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1f98:	19 82       	std	Y+1, r1	; 0x01
    1f9a:	13 c0       	rjmp	.+38     	; 0x1fc2 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1f9c:	89 81       	ldd	r24, Y+1	; 0x01
    1f9e:	28 2f       	mov	r18, r24
    1fa0:	30 e0       	ldi	r19, 0x00	; 0
    1fa2:	c9 01       	movw	r24, r18
    1fa4:	88 0f       	add	r24, r24
    1fa6:	99 1f       	adc	r25, r25
    1fa8:	88 0f       	add	r24, r24
    1faa:	99 1f       	adc	r25, r25
    1fac:	88 0f       	add	r24, r24
    1fae:	99 1f       	adc	r25, r25
    1fb0:	82 0f       	add	r24, r18
    1fb2:	93 1f       	adc	r25, r19
    1fb4:	87 58       	subi	r24, 0x87	; 135
    1fb6:	9f 4f       	sbci	r25, 0xFF	; 255
    1fb8:	0e 94 a4 10 	call	0x2148	; 0x2148 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1fbc:	89 81       	ldd	r24, Y+1	; 0x01
    1fbe:	8f 5f       	subi	r24, 0xFF	; 255
    1fc0:	89 83       	std	Y+1, r24	; 0x01
    1fc2:	89 81       	ldd	r24, Y+1	; 0x01
    1fc4:	82 30       	cpi	r24, 0x02	; 2
    1fc6:	50 f3       	brcs	.-44     	; 0x1f9c <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    1fc8:	8b e8       	ldi	r24, 0x8B	; 139
    1fca:	90 e0       	ldi	r25, 0x00	; 0
    1fcc:	0e 94 a4 10 	call	0x2148	; 0x2148 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    1fd0:	84 e9       	ldi	r24, 0x94	; 148
    1fd2:	90 e0       	ldi	r25, 0x00	; 0
    1fd4:	0e 94 a4 10 	call	0x2148	; 0x2148 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    1fd8:	81 ea       	ldi	r24, 0xA1	; 161
    1fda:	90 e0       	ldi	r25, 0x00	; 0
    1fdc:	0e 94 a4 10 	call	0x2148	; 0x2148 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1fe0:	8b e8       	ldi	r24, 0x8B	; 139
    1fe2:	90 e0       	ldi	r25, 0x00	; 0
    1fe4:	90 93 9e 00 	sts	0x009E, r25
    1fe8:	80 93 9d 00 	sts	0x009D, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1fec:	84 e9       	ldi	r24, 0x94	; 148
    1fee:	90 e0       	ldi	r25, 0x00	; 0
    1ff0:	90 93 a0 00 	sts	0x00A0, r25
    1ff4:	80 93 9f 00 	sts	0x009F, r24
}
    1ff8:	0f 90       	pop	r0
    1ffa:	cf 91       	pop	r28
    1ffc:	df 91       	pop	r29
    1ffe:	08 95       	ret

00002000 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2000:	df 93       	push	r29
    2002:	cf 93       	push	r28
    2004:	00 d0       	rcall	.+0      	; 0x2006 <xCoRoutineRemoveFromEventList+0x6>
    2006:	00 d0       	rcall	.+0      	; 0x2008 <xCoRoutineRemoveFromEventList+0x8>
    2008:	0f 92       	push	r0
    200a:	cd b7       	in	r28, 0x3d	; 61
    200c:	de b7       	in	r29, 0x3e	; 62
    200e:	9d 83       	std	Y+5, r25	; 0x05
    2010:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2012:	ec 81       	ldd	r30, Y+4	; 0x04
    2014:	fd 81       	ldd	r31, Y+5	; 0x05
    2016:	05 80       	ldd	r0, Z+5	; 0x05
    2018:	f6 81       	ldd	r31, Z+6	; 0x06
    201a:	e0 2d       	mov	r30, r0
    201c:	86 81       	ldd	r24, Z+6	; 0x06
    201e:	97 81       	ldd	r25, Z+7	; 0x07
    2020:	9b 83       	std	Y+3, r25	; 0x03
    2022:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2024:	8a 81       	ldd	r24, Y+2	; 0x02
    2026:	9b 81       	ldd	r25, Y+3	; 0x03
    2028:	0c 96       	adiw	r24, 0x0c	; 12
    202a:	0e 94 96 11 	call	0x232c	; 0x232c <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    202e:	8a 81       	ldd	r24, Y+2	; 0x02
    2030:	9b 81       	ldd	r25, Y+3	; 0x03
    2032:	9c 01       	movw	r18, r24
    2034:	24 5f       	subi	r18, 0xF4	; 244
    2036:	3f 4f       	sbci	r19, 0xFF	; 255
    2038:	81 ea       	ldi	r24, 0xA1	; 161
    203a:	90 e0       	ldi	r25, 0x00	; 0
    203c:	b9 01       	movw	r22, r18
    203e:	0e 94 de 10 	call	0x21bc	; 0x21bc <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2042:	ea 81       	ldd	r30, Y+2	; 0x02
    2044:	fb 81       	ldd	r31, Y+3	; 0x03
    2046:	96 89       	ldd	r25, Z+22	; 0x16
    2048:	e0 91 70 00 	lds	r30, 0x0070
    204c:	f0 91 71 00 	lds	r31, 0x0071
    2050:	86 89       	ldd	r24, Z+22	; 0x16
    2052:	98 17       	cp	r25, r24
    2054:	18 f0       	brcs	.+6      	; 0x205c <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    2056:	81 e0       	ldi	r24, 0x01	; 1
    2058:	89 83       	std	Y+1, r24	; 0x01
    205a:	01 c0       	rjmp	.+2      	; 0x205e <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    205c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    205e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2060:	0f 90       	pop	r0
    2062:	0f 90       	pop	r0
    2064:	0f 90       	pop	r0
    2066:	0f 90       	pop	r0
    2068:	0f 90       	pop	r0
    206a:	cf 91       	pop	r28
    206c:	df 91       	pop	r29
    206e:	08 95       	ret

00002070 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2070:	df 93       	push	r29
    2072:	cf 93       	push	r28
    2074:	00 d0       	rcall	.+0      	; 0x2076 <pvPortMalloc+0x6>
    2076:	00 d0       	rcall	.+0      	; 0x2078 <pvPortMalloc+0x8>
    2078:	cd b7       	in	r28, 0x3d	; 61
    207a:	de b7       	in	r29, 0x3e	; 62
    207c:	9c 83       	std	Y+4, r25	; 0x04
    207e:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    2080:	1a 82       	std	Y+2, r1	; 0x02
    2082:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2084:	0e 94 6e 1b 	call	0x36dc	; 0x36dc <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2088:	80 91 aa 00 	lds	r24, 0x00AA
    208c:	90 91 ab 00 	lds	r25, 0x00AB
    2090:	2b 81       	ldd	r18, Y+3	; 0x03
    2092:	3c 81       	ldd	r19, Y+4	; 0x04
    2094:	82 0f       	add	r24, r18
    2096:	93 1f       	adc	r25, r19
    2098:	22 e0       	ldi	r18, 0x02	; 2
    209a:	88 35       	cpi	r24, 0x58	; 88
    209c:	92 07       	cpc	r25, r18
    209e:	18 f5       	brcc	.+70     	; 0x20e6 <pvPortMalloc+0x76>
    20a0:	20 91 aa 00 	lds	r18, 0x00AA
    20a4:	30 91 ab 00 	lds	r19, 0x00AB
    20a8:	8b 81       	ldd	r24, Y+3	; 0x03
    20aa:	9c 81       	ldd	r25, Y+4	; 0x04
    20ac:	28 0f       	add	r18, r24
    20ae:	39 1f       	adc	r19, r25
    20b0:	80 91 aa 00 	lds	r24, 0x00AA
    20b4:	90 91 ab 00 	lds	r25, 0x00AB
    20b8:	82 17       	cp	r24, r18
    20ba:	93 07       	cpc	r25, r19
    20bc:	a0 f4       	brcc	.+40     	; 0x20e6 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    20be:	80 91 aa 00 	lds	r24, 0x00AA
    20c2:	90 91 ab 00 	lds	r25, 0x00AB
    20c6:	84 55       	subi	r24, 0x54	; 84
    20c8:	9f 4f       	sbci	r25, 0xFF	; 255
    20ca:	9a 83       	std	Y+2, r25	; 0x02
    20cc:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    20ce:	20 91 aa 00 	lds	r18, 0x00AA
    20d2:	30 91 ab 00 	lds	r19, 0x00AB
    20d6:	8b 81       	ldd	r24, Y+3	; 0x03
    20d8:	9c 81       	ldd	r25, Y+4	; 0x04
    20da:	82 0f       	add	r24, r18
    20dc:	93 1f       	adc	r25, r19
    20de:	90 93 ab 00 	sts	0x00AB, r25
    20e2:	80 93 aa 00 	sts	0x00AA, r24
		}	
	}
	xTaskResumeAll();
    20e6:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    20ea:	89 81       	ldd	r24, Y+1	; 0x01
    20ec:	9a 81       	ldd	r25, Y+2	; 0x02
}
    20ee:	0f 90       	pop	r0
    20f0:	0f 90       	pop	r0
    20f2:	0f 90       	pop	r0
    20f4:	0f 90       	pop	r0
    20f6:	cf 91       	pop	r28
    20f8:	df 91       	pop	r29
    20fa:	08 95       	ret

000020fc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    20fc:	df 93       	push	r29
    20fe:	cf 93       	push	r28
    2100:	00 d0       	rcall	.+0      	; 0x2102 <vPortFree+0x6>
    2102:	cd b7       	in	r28, 0x3d	; 61
    2104:	de b7       	in	r29, 0x3e	; 62
    2106:	9a 83       	std	Y+2, r25	; 0x02
    2108:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    210a:	0f 90       	pop	r0
    210c:	0f 90       	pop	r0
    210e:	cf 91       	pop	r28
    2110:	df 91       	pop	r29
    2112:	08 95       	ret

00002114 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2114:	df 93       	push	r29
    2116:	cf 93       	push	r28
    2118:	cd b7       	in	r28, 0x3d	; 61
    211a:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    211c:	10 92 ab 00 	sts	0x00AB, r1
    2120:	10 92 aa 00 	sts	0x00AA, r1
}
    2124:	cf 91       	pop	r28
    2126:	df 91       	pop	r29
    2128:	08 95       	ret

0000212a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    212a:	df 93       	push	r29
    212c:	cf 93       	push	r28
    212e:	cd b7       	in	r28, 0x3d	; 61
    2130:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    2132:	20 91 aa 00 	lds	r18, 0x00AA
    2136:	30 91 ab 00 	lds	r19, 0x00AB
    213a:	88 e5       	ldi	r24, 0x58	; 88
    213c:	92 e0       	ldi	r25, 0x02	; 2
    213e:	82 1b       	sub	r24, r18
    2140:	93 0b       	sbc	r25, r19
}
    2142:	cf 91       	pop	r28
    2144:	df 91       	pop	r29
    2146:	08 95       	ret

00002148 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2148:	df 93       	push	r29
    214a:	cf 93       	push	r28
    214c:	00 d0       	rcall	.+0      	; 0x214e <vListInitialise+0x6>
    214e:	cd b7       	in	r28, 0x3d	; 61
    2150:	de b7       	in	r29, 0x3e	; 62
    2152:	9a 83       	std	Y+2, r25	; 0x02
    2154:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2156:	89 81       	ldd	r24, Y+1	; 0x01
    2158:	9a 81       	ldd	r25, Y+2	; 0x02
    215a:	03 96       	adiw	r24, 0x03	; 3
    215c:	e9 81       	ldd	r30, Y+1	; 0x01
    215e:	fa 81       	ldd	r31, Y+2	; 0x02
    2160:	92 83       	std	Z+2, r25	; 0x02
    2162:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2164:	e9 81       	ldd	r30, Y+1	; 0x01
    2166:	fa 81       	ldd	r31, Y+2	; 0x02
    2168:	8f ef       	ldi	r24, 0xFF	; 255
    216a:	9f ef       	ldi	r25, 0xFF	; 255
    216c:	94 83       	std	Z+4, r25	; 0x04
    216e:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    2170:	89 81       	ldd	r24, Y+1	; 0x01
    2172:	9a 81       	ldd	r25, Y+2	; 0x02
    2174:	03 96       	adiw	r24, 0x03	; 3
    2176:	e9 81       	ldd	r30, Y+1	; 0x01
    2178:	fa 81       	ldd	r31, Y+2	; 0x02
    217a:	96 83       	std	Z+6, r25	; 0x06
    217c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    217e:	89 81       	ldd	r24, Y+1	; 0x01
    2180:	9a 81       	ldd	r25, Y+2	; 0x02
    2182:	03 96       	adiw	r24, 0x03	; 3
    2184:	e9 81       	ldd	r30, Y+1	; 0x01
    2186:	fa 81       	ldd	r31, Y+2	; 0x02
    2188:	90 87       	std	Z+8, r25	; 0x08
    218a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    218c:	e9 81       	ldd	r30, Y+1	; 0x01
    218e:	fa 81       	ldd	r31, Y+2	; 0x02
    2190:	10 82       	st	Z, r1
}
    2192:	0f 90       	pop	r0
    2194:	0f 90       	pop	r0
    2196:	cf 91       	pop	r28
    2198:	df 91       	pop	r29
    219a:	08 95       	ret

0000219c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    219c:	df 93       	push	r29
    219e:	cf 93       	push	r28
    21a0:	00 d0       	rcall	.+0      	; 0x21a2 <vListInitialiseItem+0x6>
    21a2:	cd b7       	in	r28, 0x3d	; 61
    21a4:	de b7       	in	r29, 0x3e	; 62
    21a6:	9a 83       	std	Y+2, r25	; 0x02
    21a8:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    21aa:	e9 81       	ldd	r30, Y+1	; 0x01
    21ac:	fa 81       	ldd	r31, Y+2	; 0x02
    21ae:	11 86       	std	Z+9, r1	; 0x09
    21b0:	10 86       	std	Z+8, r1	; 0x08
}
    21b2:	0f 90       	pop	r0
    21b4:	0f 90       	pop	r0
    21b6:	cf 91       	pop	r28
    21b8:	df 91       	pop	r29
    21ba:	08 95       	ret

000021bc <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    21bc:	df 93       	push	r29
    21be:	cf 93       	push	r28
    21c0:	00 d0       	rcall	.+0      	; 0x21c2 <vListInsertEnd+0x6>
    21c2:	00 d0       	rcall	.+0      	; 0x21c4 <vListInsertEnd+0x8>
    21c4:	00 d0       	rcall	.+0      	; 0x21c6 <vListInsertEnd+0xa>
    21c6:	cd b7       	in	r28, 0x3d	; 61
    21c8:	de b7       	in	r29, 0x3e	; 62
    21ca:	9c 83       	std	Y+4, r25	; 0x04
    21cc:	8b 83       	std	Y+3, r24	; 0x03
    21ce:	7e 83       	std	Y+6, r23	; 0x06
    21d0:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    21d2:	eb 81       	ldd	r30, Y+3	; 0x03
    21d4:	fc 81       	ldd	r31, Y+4	; 0x04
    21d6:	81 81       	ldd	r24, Z+1	; 0x01
    21d8:	92 81       	ldd	r25, Z+2	; 0x02
    21da:	9a 83       	std	Y+2, r25	; 0x02
    21dc:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    21de:	e9 81       	ldd	r30, Y+1	; 0x01
    21e0:	fa 81       	ldd	r31, Y+2	; 0x02
    21e2:	82 81       	ldd	r24, Z+2	; 0x02
    21e4:	93 81       	ldd	r25, Z+3	; 0x03
    21e6:	ed 81       	ldd	r30, Y+5	; 0x05
    21e8:	fe 81       	ldd	r31, Y+6	; 0x06
    21ea:	93 83       	std	Z+3, r25	; 0x03
    21ec:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    21ee:	eb 81       	ldd	r30, Y+3	; 0x03
    21f0:	fc 81       	ldd	r31, Y+4	; 0x04
    21f2:	81 81       	ldd	r24, Z+1	; 0x01
    21f4:	92 81       	ldd	r25, Z+2	; 0x02
    21f6:	ed 81       	ldd	r30, Y+5	; 0x05
    21f8:	fe 81       	ldd	r31, Y+6	; 0x06
    21fa:	95 83       	std	Z+5, r25	; 0x05
    21fc:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    21fe:	e9 81       	ldd	r30, Y+1	; 0x01
    2200:	fa 81       	ldd	r31, Y+2	; 0x02
    2202:	02 80       	ldd	r0, Z+2	; 0x02
    2204:	f3 81       	ldd	r31, Z+3	; 0x03
    2206:	e0 2d       	mov	r30, r0
    2208:	8d 81       	ldd	r24, Y+5	; 0x05
    220a:	9e 81       	ldd	r25, Y+6	; 0x06
    220c:	95 83       	std	Z+5, r25	; 0x05
    220e:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    2210:	8d 81       	ldd	r24, Y+5	; 0x05
    2212:	9e 81       	ldd	r25, Y+6	; 0x06
    2214:	e9 81       	ldd	r30, Y+1	; 0x01
    2216:	fa 81       	ldd	r31, Y+2	; 0x02
    2218:	93 83       	std	Z+3, r25	; 0x03
    221a:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    221c:	8d 81       	ldd	r24, Y+5	; 0x05
    221e:	9e 81       	ldd	r25, Y+6	; 0x06
    2220:	eb 81       	ldd	r30, Y+3	; 0x03
    2222:	fc 81       	ldd	r31, Y+4	; 0x04
    2224:	92 83       	std	Z+2, r25	; 0x02
    2226:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2228:	ed 81       	ldd	r30, Y+5	; 0x05
    222a:	fe 81       	ldd	r31, Y+6	; 0x06
    222c:	8b 81       	ldd	r24, Y+3	; 0x03
    222e:	9c 81       	ldd	r25, Y+4	; 0x04
    2230:	91 87       	std	Z+9, r25	; 0x09
    2232:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2234:	eb 81       	ldd	r30, Y+3	; 0x03
    2236:	fc 81       	ldd	r31, Y+4	; 0x04
    2238:	80 81       	ld	r24, Z
    223a:	8f 5f       	subi	r24, 0xFF	; 255
    223c:	eb 81       	ldd	r30, Y+3	; 0x03
    223e:	fc 81       	ldd	r31, Y+4	; 0x04
    2240:	80 83       	st	Z, r24
}
    2242:	26 96       	adiw	r28, 0x06	; 6
    2244:	0f b6       	in	r0, 0x3f	; 63
    2246:	f8 94       	cli
    2248:	de bf       	out	0x3e, r29	; 62
    224a:	0f be       	out	0x3f, r0	; 63
    224c:	cd bf       	out	0x3d, r28	; 61
    224e:	cf 91       	pop	r28
    2250:	df 91       	pop	r29
    2252:	08 95       	ret

00002254 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    2254:	df 93       	push	r29
    2256:	cf 93       	push	r28
    2258:	cd b7       	in	r28, 0x3d	; 61
    225a:	de b7       	in	r29, 0x3e	; 62
    225c:	28 97       	sbiw	r28, 0x08	; 8
    225e:	0f b6       	in	r0, 0x3f	; 63
    2260:	f8 94       	cli
    2262:	de bf       	out	0x3e, r29	; 62
    2264:	0f be       	out	0x3f, r0	; 63
    2266:	cd bf       	out	0x3d, r28	; 61
    2268:	9e 83       	std	Y+6, r25	; 0x06
    226a:	8d 83       	std	Y+5, r24	; 0x05
    226c:	78 87       	std	Y+8, r23	; 0x08
    226e:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    2270:	ef 81       	ldd	r30, Y+7	; 0x07
    2272:	f8 85       	ldd	r31, Y+8	; 0x08
    2274:	80 81       	ld	r24, Z
    2276:	91 81       	ldd	r25, Z+1	; 0x01
    2278:	9a 83       	std	Y+2, r25	; 0x02
    227a:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    227c:	89 81       	ldd	r24, Y+1	; 0x01
    227e:	9a 81       	ldd	r25, Y+2	; 0x02
    2280:	2f ef       	ldi	r18, 0xFF	; 255
    2282:	8f 3f       	cpi	r24, 0xFF	; 255
    2284:	92 07       	cpc	r25, r18
    2286:	39 f4       	brne	.+14     	; 0x2296 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2288:	ed 81       	ldd	r30, Y+5	; 0x05
    228a:	fe 81       	ldd	r31, Y+6	; 0x06
    228c:	87 81       	ldd	r24, Z+7	; 0x07
    228e:	90 85       	ldd	r25, Z+8	; 0x08
    2290:	9c 83       	std	Y+4, r25	; 0x04
    2292:	8b 83       	std	Y+3, r24	; 0x03
    2294:	18 c0       	rjmp	.+48     	; 0x22c6 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    2296:	8d 81       	ldd	r24, Y+5	; 0x05
    2298:	9e 81       	ldd	r25, Y+6	; 0x06
    229a:	03 96       	adiw	r24, 0x03	; 3
    229c:	9c 83       	std	Y+4, r25	; 0x04
    229e:	8b 83       	std	Y+3, r24	; 0x03
    22a0:	06 c0       	rjmp	.+12     	; 0x22ae <vListInsert+0x5a>
    22a2:	eb 81       	ldd	r30, Y+3	; 0x03
    22a4:	fc 81       	ldd	r31, Y+4	; 0x04
    22a6:	82 81       	ldd	r24, Z+2	; 0x02
    22a8:	93 81       	ldd	r25, Z+3	; 0x03
    22aa:	9c 83       	std	Y+4, r25	; 0x04
    22ac:	8b 83       	std	Y+3, r24	; 0x03
    22ae:	eb 81       	ldd	r30, Y+3	; 0x03
    22b0:	fc 81       	ldd	r31, Y+4	; 0x04
    22b2:	02 80       	ldd	r0, Z+2	; 0x02
    22b4:	f3 81       	ldd	r31, Z+3	; 0x03
    22b6:	e0 2d       	mov	r30, r0
    22b8:	20 81       	ld	r18, Z
    22ba:	31 81       	ldd	r19, Z+1	; 0x01
    22bc:	89 81       	ldd	r24, Y+1	; 0x01
    22be:	9a 81       	ldd	r25, Y+2	; 0x02
    22c0:	82 17       	cp	r24, r18
    22c2:	93 07       	cpc	r25, r19
    22c4:	70 f7       	brcc	.-36     	; 0x22a2 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    22c6:	eb 81       	ldd	r30, Y+3	; 0x03
    22c8:	fc 81       	ldd	r31, Y+4	; 0x04
    22ca:	82 81       	ldd	r24, Z+2	; 0x02
    22cc:	93 81       	ldd	r25, Z+3	; 0x03
    22ce:	ef 81       	ldd	r30, Y+7	; 0x07
    22d0:	f8 85       	ldd	r31, Y+8	; 0x08
    22d2:	93 83       	std	Z+3, r25	; 0x03
    22d4:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    22d6:	ef 81       	ldd	r30, Y+7	; 0x07
    22d8:	f8 85       	ldd	r31, Y+8	; 0x08
    22da:	02 80       	ldd	r0, Z+2	; 0x02
    22dc:	f3 81       	ldd	r31, Z+3	; 0x03
    22de:	e0 2d       	mov	r30, r0
    22e0:	8f 81       	ldd	r24, Y+7	; 0x07
    22e2:	98 85       	ldd	r25, Y+8	; 0x08
    22e4:	95 83       	std	Z+5, r25	; 0x05
    22e6:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    22e8:	ef 81       	ldd	r30, Y+7	; 0x07
    22ea:	f8 85       	ldd	r31, Y+8	; 0x08
    22ec:	8b 81       	ldd	r24, Y+3	; 0x03
    22ee:	9c 81       	ldd	r25, Y+4	; 0x04
    22f0:	95 83       	std	Z+5, r25	; 0x05
    22f2:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    22f4:	8f 81       	ldd	r24, Y+7	; 0x07
    22f6:	98 85       	ldd	r25, Y+8	; 0x08
    22f8:	eb 81       	ldd	r30, Y+3	; 0x03
    22fa:	fc 81       	ldd	r31, Y+4	; 0x04
    22fc:	93 83       	std	Z+3, r25	; 0x03
    22fe:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2300:	ef 81       	ldd	r30, Y+7	; 0x07
    2302:	f8 85       	ldd	r31, Y+8	; 0x08
    2304:	8d 81       	ldd	r24, Y+5	; 0x05
    2306:	9e 81       	ldd	r25, Y+6	; 0x06
    2308:	91 87       	std	Z+9, r25	; 0x09
    230a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    230c:	ed 81       	ldd	r30, Y+5	; 0x05
    230e:	fe 81       	ldd	r31, Y+6	; 0x06
    2310:	80 81       	ld	r24, Z
    2312:	8f 5f       	subi	r24, 0xFF	; 255
    2314:	ed 81       	ldd	r30, Y+5	; 0x05
    2316:	fe 81       	ldd	r31, Y+6	; 0x06
    2318:	80 83       	st	Z, r24
}
    231a:	28 96       	adiw	r28, 0x08	; 8
    231c:	0f b6       	in	r0, 0x3f	; 63
    231e:	f8 94       	cli
    2320:	de bf       	out	0x3e, r29	; 62
    2322:	0f be       	out	0x3f, r0	; 63
    2324:	cd bf       	out	0x3d, r28	; 61
    2326:	cf 91       	pop	r28
    2328:	df 91       	pop	r29
    232a:	08 95       	ret

0000232c <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    232c:	df 93       	push	r29
    232e:	cf 93       	push	r28
    2330:	00 d0       	rcall	.+0      	; 0x2332 <vListRemove+0x6>
    2332:	00 d0       	rcall	.+0      	; 0x2334 <vListRemove+0x8>
    2334:	cd b7       	in	r28, 0x3d	; 61
    2336:	de b7       	in	r29, 0x3e	; 62
    2338:	9c 83       	std	Y+4, r25	; 0x04
    233a:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    233c:	eb 81       	ldd	r30, Y+3	; 0x03
    233e:	fc 81       	ldd	r31, Y+4	; 0x04
    2340:	a2 81       	ldd	r26, Z+2	; 0x02
    2342:	b3 81       	ldd	r27, Z+3	; 0x03
    2344:	eb 81       	ldd	r30, Y+3	; 0x03
    2346:	fc 81       	ldd	r31, Y+4	; 0x04
    2348:	84 81       	ldd	r24, Z+4	; 0x04
    234a:	95 81       	ldd	r25, Z+5	; 0x05
    234c:	15 96       	adiw	r26, 0x05	; 5
    234e:	9c 93       	st	X, r25
    2350:	8e 93       	st	-X, r24
    2352:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2354:	eb 81       	ldd	r30, Y+3	; 0x03
    2356:	fc 81       	ldd	r31, Y+4	; 0x04
    2358:	a4 81       	ldd	r26, Z+4	; 0x04
    235a:	b5 81       	ldd	r27, Z+5	; 0x05
    235c:	eb 81       	ldd	r30, Y+3	; 0x03
    235e:	fc 81       	ldd	r31, Y+4	; 0x04
    2360:	82 81       	ldd	r24, Z+2	; 0x02
    2362:	93 81       	ldd	r25, Z+3	; 0x03
    2364:	13 96       	adiw	r26, 0x03	; 3
    2366:	9c 93       	st	X, r25
    2368:	8e 93       	st	-X, r24
    236a:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    236c:	eb 81       	ldd	r30, Y+3	; 0x03
    236e:	fc 81       	ldd	r31, Y+4	; 0x04
    2370:	80 85       	ldd	r24, Z+8	; 0x08
    2372:	91 85       	ldd	r25, Z+9	; 0x09
    2374:	9a 83       	std	Y+2, r25	; 0x02
    2376:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2378:	e9 81       	ldd	r30, Y+1	; 0x01
    237a:	fa 81       	ldd	r31, Y+2	; 0x02
    237c:	21 81       	ldd	r18, Z+1	; 0x01
    237e:	32 81       	ldd	r19, Z+2	; 0x02
    2380:	8b 81       	ldd	r24, Y+3	; 0x03
    2382:	9c 81       	ldd	r25, Y+4	; 0x04
    2384:	28 17       	cp	r18, r24
    2386:	39 07       	cpc	r19, r25
    2388:	41 f4       	brne	.+16     	; 0x239a <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    238a:	eb 81       	ldd	r30, Y+3	; 0x03
    238c:	fc 81       	ldd	r31, Y+4	; 0x04
    238e:	84 81       	ldd	r24, Z+4	; 0x04
    2390:	95 81       	ldd	r25, Z+5	; 0x05
    2392:	e9 81       	ldd	r30, Y+1	; 0x01
    2394:	fa 81       	ldd	r31, Y+2	; 0x02
    2396:	92 83       	std	Z+2, r25	; 0x02
    2398:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    239a:	eb 81       	ldd	r30, Y+3	; 0x03
    239c:	fc 81       	ldd	r31, Y+4	; 0x04
    239e:	11 86       	std	Z+9, r1	; 0x09
    23a0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    23a2:	e9 81       	ldd	r30, Y+1	; 0x01
    23a4:	fa 81       	ldd	r31, Y+2	; 0x02
    23a6:	80 81       	ld	r24, Z
    23a8:	81 50       	subi	r24, 0x01	; 1
    23aa:	e9 81       	ldd	r30, Y+1	; 0x01
    23ac:	fa 81       	ldd	r31, Y+2	; 0x02
    23ae:	80 83       	st	Z, r24
}
    23b0:	0f 90       	pop	r0
    23b2:	0f 90       	pop	r0
    23b4:	0f 90       	pop	r0
    23b6:	0f 90       	pop	r0
    23b8:	cf 91       	pop	r28
    23ba:	df 91       	pop	r29
    23bc:	08 95       	ret

000023be <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    23be:	df 93       	push	r29
    23c0:	cf 93       	push	r28
    23c2:	cd b7       	in	r28, 0x3d	; 61
    23c4:	de b7       	in	r29, 0x3e	; 62
    23c6:	28 97       	sbiw	r28, 0x08	; 8
    23c8:	0f b6       	in	r0, 0x3f	; 63
    23ca:	f8 94       	cli
    23cc:	de bf       	out	0x3e, r29	; 62
    23ce:	0f be       	out	0x3f, r0	; 63
    23d0:	cd bf       	out	0x3d, r28	; 61
    23d2:	9c 83       	std	Y+4, r25	; 0x04
    23d4:	8b 83       	std	Y+3, r24	; 0x03
    23d6:	7e 83       	std	Y+6, r23	; 0x06
    23d8:	6d 83       	std	Y+5, r22	; 0x05
    23da:	58 87       	std	Y+8, r21	; 0x08
    23dc:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    23de:	eb 81       	ldd	r30, Y+3	; 0x03
    23e0:	fc 81       	ldd	r31, Y+4	; 0x04
    23e2:	81 e1       	ldi	r24, 0x11	; 17
    23e4:	80 83       	st	Z, r24
	pxTopOfStack--;
    23e6:	8b 81       	ldd	r24, Y+3	; 0x03
    23e8:	9c 81       	ldd	r25, Y+4	; 0x04
    23ea:	01 97       	sbiw	r24, 0x01	; 1
    23ec:	9c 83       	std	Y+4, r25	; 0x04
    23ee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    23f0:	eb 81       	ldd	r30, Y+3	; 0x03
    23f2:	fc 81       	ldd	r31, Y+4	; 0x04
    23f4:	82 e2       	ldi	r24, 0x22	; 34
    23f6:	80 83       	st	Z, r24
	pxTopOfStack--;
    23f8:	8b 81       	ldd	r24, Y+3	; 0x03
    23fa:	9c 81       	ldd	r25, Y+4	; 0x04
    23fc:	01 97       	sbiw	r24, 0x01	; 1
    23fe:	9c 83       	std	Y+4, r25	; 0x04
    2400:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2402:	eb 81       	ldd	r30, Y+3	; 0x03
    2404:	fc 81       	ldd	r31, Y+4	; 0x04
    2406:	83 e3       	ldi	r24, 0x33	; 51
    2408:	80 83       	st	Z, r24
	pxTopOfStack--;
    240a:	8b 81       	ldd	r24, Y+3	; 0x03
    240c:	9c 81       	ldd	r25, Y+4	; 0x04
    240e:	01 97       	sbiw	r24, 0x01	; 1
    2410:	9c 83       	std	Y+4, r25	; 0x04
    2412:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    2414:	8d 81       	ldd	r24, Y+5	; 0x05
    2416:	9e 81       	ldd	r25, Y+6	; 0x06
    2418:	9a 83       	std	Y+2, r25	; 0x02
    241a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    241c:	89 81       	ldd	r24, Y+1	; 0x01
    241e:	eb 81       	ldd	r30, Y+3	; 0x03
    2420:	fc 81       	ldd	r31, Y+4	; 0x04
    2422:	80 83       	st	Z, r24
	pxTopOfStack--;
    2424:	8b 81       	ldd	r24, Y+3	; 0x03
    2426:	9c 81       	ldd	r25, Y+4	; 0x04
    2428:	01 97       	sbiw	r24, 0x01	; 1
    242a:	9c 83       	std	Y+4, r25	; 0x04
    242c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    242e:	89 81       	ldd	r24, Y+1	; 0x01
    2430:	9a 81       	ldd	r25, Y+2	; 0x02
    2432:	89 2f       	mov	r24, r25
    2434:	99 27       	eor	r25, r25
    2436:	9a 83       	std	Y+2, r25	; 0x02
    2438:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    243a:	89 81       	ldd	r24, Y+1	; 0x01
    243c:	eb 81       	ldd	r30, Y+3	; 0x03
    243e:	fc 81       	ldd	r31, Y+4	; 0x04
    2440:	80 83       	st	Z, r24
	pxTopOfStack--;
    2442:	8b 81       	ldd	r24, Y+3	; 0x03
    2444:	9c 81       	ldd	r25, Y+4	; 0x04
    2446:	01 97       	sbiw	r24, 0x01	; 1
    2448:	9c 83       	std	Y+4, r25	; 0x04
    244a:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    244c:	eb 81       	ldd	r30, Y+3	; 0x03
    244e:	fc 81       	ldd	r31, Y+4	; 0x04
    2450:	10 82       	st	Z, r1
	pxTopOfStack--;
    2452:	8b 81       	ldd	r24, Y+3	; 0x03
    2454:	9c 81       	ldd	r25, Y+4	; 0x04
    2456:	01 97       	sbiw	r24, 0x01	; 1
    2458:	9c 83       	std	Y+4, r25	; 0x04
    245a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    245c:	eb 81       	ldd	r30, Y+3	; 0x03
    245e:	fc 81       	ldd	r31, Y+4	; 0x04
    2460:	80 e8       	ldi	r24, 0x80	; 128
    2462:	80 83       	st	Z, r24
	pxTopOfStack--;
    2464:	8b 81       	ldd	r24, Y+3	; 0x03
    2466:	9c 81       	ldd	r25, Y+4	; 0x04
    2468:	01 97       	sbiw	r24, 0x01	; 1
    246a:	9c 83       	std	Y+4, r25	; 0x04
    246c:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    246e:	eb 81       	ldd	r30, Y+3	; 0x03
    2470:	fc 81       	ldd	r31, Y+4	; 0x04
    2472:	10 82       	st	Z, r1
	pxTopOfStack--;
    2474:	8b 81       	ldd	r24, Y+3	; 0x03
    2476:	9c 81       	ldd	r25, Y+4	; 0x04
    2478:	01 97       	sbiw	r24, 0x01	; 1
    247a:	9c 83       	std	Y+4, r25	; 0x04
    247c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    247e:	eb 81       	ldd	r30, Y+3	; 0x03
    2480:	fc 81       	ldd	r31, Y+4	; 0x04
    2482:	82 e0       	ldi	r24, 0x02	; 2
    2484:	80 83       	st	Z, r24
	pxTopOfStack--;
    2486:	8b 81       	ldd	r24, Y+3	; 0x03
    2488:	9c 81       	ldd	r25, Y+4	; 0x04
    248a:	01 97       	sbiw	r24, 0x01	; 1
    248c:	9c 83       	std	Y+4, r25	; 0x04
    248e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2490:	eb 81       	ldd	r30, Y+3	; 0x03
    2492:	fc 81       	ldd	r31, Y+4	; 0x04
    2494:	83 e0       	ldi	r24, 0x03	; 3
    2496:	80 83       	st	Z, r24
	pxTopOfStack--;
    2498:	8b 81       	ldd	r24, Y+3	; 0x03
    249a:	9c 81       	ldd	r25, Y+4	; 0x04
    249c:	01 97       	sbiw	r24, 0x01	; 1
    249e:	9c 83       	std	Y+4, r25	; 0x04
    24a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    24a2:	eb 81       	ldd	r30, Y+3	; 0x03
    24a4:	fc 81       	ldd	r31, Y+4	; 0x04
    24a6:	84 e0       	ldi	r24, 0x04	; 4
    24a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    24aa:	8b 81       	ldd	r24, Y+3	; 0x03
    24ac:	9c 81       	ldd	r25, Y+4	; 0x04
    24ae:	01 97       	sbiw	r24, 0x01	; 1
    24b0:	9c 83       	std	Y+4, r25	; 0x04
    24b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    24b4:	eb 81       	ldd	r30, Y+3	; 0x03
    24b6:	fc 81       	ldd	r31, Y+4	; 0x04
    24b8:	85 e0       	ldi	r24, 0x05	; 5
    24ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    24bc:	8b 81       	ldd	r24, Y+3	; 0x03
    24be:	9c 81       	ldd	r25, Y+4	; 0x04
    24c0:	01 97       	sbiw	r24, 0x01	; 1
    24c2:	9c 83       	std	Y+4, r25	; 0x04
    24c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    24c6:	eb 81       	ldd	r30, Y+3	; 0x03
    24c8:	fc 81       	ldd	r31, Y+4	; 0x04
    24ca:	86 e0       	ldi	r24, 0x06	; 6
    24cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    24ce:	8b 81       	ldd	r24, Y+3	; 0x03
    24d0:	9c 81       	ldd	r25, Y+4	; 0x04
    24d2:	01 97       	sbiw	r24, 0x01	; 1
    24d4:	9c 83       	std	Y+4, r25	; 0x04
    24d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    24d8:	eb 81       	ldd	r30, Y+3	; 0x03
    24da:	fc 81       	ldd	r31, Y+4	; 0x04
    24dc:	87 e0       	ldi	r24, 0x07	; 7
    24de:	80 83       	st	Z, r24
	pxTopOfStack--;
    24e0:	8b 81       	ldd	r24, Y+3	; 0x03
    24e2:	9c 81       	ldd	r25, Y+4	; 0x04
    24e4:	01 97       	sbiw	r24, 0x01	; 1
    24e6:	9c 83       	std	Y+4, r25	; 0x04
    24e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    24ea:	eb 81       	ldd	r30, Y+3	; 0x03
    24ec:	fc 81       	ldd	r31, Y+4	; 0x04
    24ee:	88 e0       	ldi	r24, 0x08	; 8
    24f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    24f2:	8b 81       	ldd	r24, Y+3	; 0x03
    24f4:	9c 81       	ldd	r25, Y+4	; 0x04
    24f6:	01 97       	sbiw	r24, 0x01	; 1
    24f8:	9c 83       	std	Y+4, r25	; 0x04
    24fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    24fc:	eb 81       	ldd	r30, Y+3	; 0x03
    24fe:	fc 81       	ldd	r31, Y+4	; 0x04
    2500:	89 e0       	ldi	r24, 0x09	; 9
    2502:	80 83       	st	Z, r24
	pxTopOfStack--;
    2504:	8b 81       	ldd	r24, Y+3	; 0x03
    2506:	9c 81       	ldd	r25, Y+4	; 0x04
    2508:	01 97       	sbiw	r24, 0x01	; 1
    250a:	9c 83       	std	Y+4, r25	; 0x04
    250c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    250e:	eb 81       	ldd	r30, Y+3	; 0x03
    2510:	fc 81       	ldd	r31, Y+4	; 0x04
    2512:	80 e1       	ldi	r24, 0x10	; 16
    2514:	80 83       	st	Z, r24
	pxTopOfStack--;
    2516:	8b 81       	ldd	r24, Y+3	; 0x03
    2518:	9c 81       	ldd	r25, Y+4	; 0x04
    251a:	01 97       	sbiw	r24, 0x01	; 1
    251c:	9c 83       	std	Y+4, r25	; 0x04
    251e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    2520:	eb 81       	ldd	r30, Y+3	; 0x03
    2522:	fc 81       	ldd	r31, Y+4	; 0x04
    2524:	81 e1       	ldi	r24, 0x11	; 17
    2526:	80 83       	st	Z, r24
	pxTopOfStack--;
    2528:	8b 81       	ldd	r24, Y+3	; 0x03
    252a:	9c 81       	ldd	r25, Y+4	; 0x04
    252c:	01 97       	sbiw	r24, 0x01	; 1
    252e:	9c 83       	std	Y+4, r25	; 0x04
    2530:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    2532:	eb 81       	ldd	r30, Y+3	; 0x03
    2534:	fc 81       	ldd	r31, Y+4	; 0x04
    2536:	82 e1       	ldi	r24, 0x12	; 18
    2538:	80 83       	st	Z, r24
	pxTopOfStack--;
    253a:	8b 81       	ldd	r24, Y+3	; 0x03
    253c:	9c 81       	ldd	r25, Y+4	; 0x04
    253e:	01 97       	sbiw	r24, 0x01	; 1
    2540:	9c 83       	std	Y+4, r25	; 0x04
    2542:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    2544:	eb 81       	ldd	r30, Y+3	; 0x03
    2546:	fc 81       	ldd	r31, Y+4	; 0x04
    2548:	83 e1       	ldi	r24, 0x13	; 19
    254a:	80 83       	st	Z, r24
	pxTopOfStack--;
    254c:	8b 81       	ldd	r24, Y+3	; 0x03
    254e:	9c 81       	ldd	r25, Y+4	; 0x04
    2550:	01 97       	sbiw	r24, 0x01	; 1
    2552:	9c 83       	std	Y+4, r25	; 0x04
    2554:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2556:	eb 81       	ldd	r30, Y+3	; 0x03
    2558:	fc 81       	ldd	r31, Y+4	; 0x04
    255a:	84 e1       	ldi	r24, 0x14	; 20
    255c:	80 83       	st	Z, r24
	pxTopOfStack--;
    255e:	8b 81       	ldd	r24, Y+3	; 0x03
    2560:	9c 81       	ldd	r25, Y+4	; 0x04
    2562:	01 97       	sbiw	r24, 0x01	; 1
    2564:	9c 83       	std	Y+4, r25	; 0x04
    2566:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2568:	eb 81       	ldd	r30, Y+3	; 0x03
    256a:	fc 81       	ldd	r31, Y+4	; 0x04
    256c:	85 e1       	ldi	r24, 0x15	; 21
    256e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2570:	8b 81       	ldd	r24, Y+3	; 0x03
    2572:	9c 81       	ldd	r25, Y+4	; 0x04
    2574:	01 97       	sbiw	r24, 0x01	; 1
    2576:	9c 83       	std	Y+4, r25	; 0x04
    2578:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    257a:	eb 81       	ldd	r30, Y+3	; 0x03
    257c:	fc 81       	ldd	r31, Y+4	; 0x04
    257e:	86 e1       	ldi	r24, 0x16	; 22
    2580:	80 83       	st	Z, r24
	pxTopOfStack--;
    2582:	8b 81       	ldd	r24, Y+3	; 0x03
    2584:	9c 81       	ldd	r25, Y+4	; 0x04
    2586:	01 97       	sbiw	r24, 0x01	; 1
    2588:	9c 83       	std	Y+4, r25	; 0x04
    258a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    258c:	eb 81       	ldd	r30, Y+3	; 0x03
    258e:	fc 81       	ldd	r31, Y+4	; 0x04
    2590:	87 e1       	ldi	r24, 0x17	; 23
    2592:	80 83       	st	Z, r24
	pxTopOfStack--;
    2594:	8b 81       	ldd	r24, Y+3	; 0x03
    2596:	9c 81       	ldd	r25, Y+4	; 0x04
    2598:	01 97       	sbiw	r24, 0x01	; 1
    259a:	9c 83       	std	Y+4, r25	; 0x04
    259c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    259e:	eb 81       	ldd	r30, Y+3	; 0x03
    25a0:	fc 81       	ldd	r31, Y+4	; 0x04
    25a2:	88 e1       	ldi	r24, 0x18	; 24
    25a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    25a6:	8b 81       	ldd	r24, Y+3	; 0x03
    25a8:	9c 81       	ldd	r25, Y+4	; 0x04
    25aa:	01 97       	sbiw	r24, 0x01	; 1
    25ac:	9c 83       	std	Y+4, r25	; 0x04
    25ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    25b0:	eb 81       	ldd	r30, Y+3	; 0x03
    25b2:	fc 81       	ldd	r31, Y+4	; 0x04
    25b4:	89 e1       	ldi	r24, 0x19	; 25
    25b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    25b8:	8b 81       	ldd	r24, Y+3	; 0x03
    25ba:	9c 81       	ldd	r25, Y+4	; 0x04
    25bc:	01 97       	sbiw	r24, 0x01	; 1
    25be:	9c 83       	std	Y+4, r25	; 0x04
    25c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    25c2:	eb 81       	ldd	r30, Y+3	; 0x03
    25c4:	fc 81       	ldd	r31, Y+4	; 0x04
    25c6:	80 e2       	ldi	r24, 0x20	; 32
    25c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    25ca:	8b 81       	ldd	r24, Y+3	; 0x03
    25cc:	9c 81       	ldd	r25, Y+4	; 0x04
    25ce:	01 97       	sbiw	r24, 0x01	; 1
    25d0:	9c 83       	std	Y+4, r25	; 0x04
    25d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    25d4:	eb 81       	ldd	r30, Y+3	; 0x03
    25d6:	fc 81       	ldd	r31, Y+4	; 0x04
    25d8:	81 e2       	ldi	r24, 0x21	; 33
    25da:	80 83       	st	Z, r24
	pxTopOfStack--;
    25dc:	8b 81       	ldd	r24, Y+3	; 0x03
    25de:	9c 81       	ldd	r25, Y+4	; 0x04
    25e0:	01 97       	sbiw	r24, 0x01	; 1
    25e2:	9c 83       	std	Y+4, r25	; 0x04
    25e4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    25e6:	eb 81       	ldd	r30, Y+3	; 0x03
    25e8:	fc 81       	ldd	r31, Y+4	; 0x04
    25ea:	82 e2       	ldi	r24, 0x22	; 34
    25ec:	80 83       	st	Z, r24
	pxTopOfStack--;
    25ee:	8b 81       	ldd	r24, Y+3	; 0x03
    25f0:	9c 81       	ldd	r25, Y+4	; 0x04
    25f2:	01 97       	sbiw	r24, 0x01	; 1
    25f4:	9c 83       	std	Y+4, r25	; 0x04
    25f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    25f8:	eb 81       	ldd	r30, Y+3	; 0x03
    25fa:	fc 81       	ldd	r31, Y+4	; 0x04
    25fc:	83 e2       	ldi	r24, 0x23	; 35
    25fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    2600:	8b 81       	ldd	r24, Y+3	; 0x03
    2602:	9c 81       	ldd	r25, Y+4	; 0x04
    2604:	01 97       	sbiw	r24, 0x01	; 1
    2606:	9c 83       	std	Y+4, r25	; 0x04
    2608:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    260a:	8f 81       	ldd	r24, Y+7	; 0x07
    260c:	98 85       	ldd	r25, Y+8	; 0x08
    260e:	9a 83       	std	Y+2, r25	; 0x02
    2610:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2612:	89 81       	ldd	r24, Y+1	; 0x01
    2614:	eb 81       	ldd	r30, Y+3	; 0x03
    2616:	fc 81       	ldd	r31, Y+4	; 0x04
    2618:	80 83       	st	Z, r24
	pxTopOfStack--;
    261a:	8b 81       	ldd	r24, Y+3	; 0x03
    261c:	9c 81       	ldd	r25, Y+4	; 0x04
    261e:	01 97       	sbiw	r24, 0x01	; 1
    2620:	9c 83       	std	Y+4, r25	; 0x04
    2622:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2624:	89 81       	ldd	r24, Y+1	; 0x01
    2626:	9a 81       	ldd	r25, Y+2	; 0x02
    2628:	89 2f       	mov	r24, r25
    262a:	99 27       	eor	r25, r25
    262c:	9a 83       	std	Y+2, r25	; 0x02
    262e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2630:	89 81       	ldd	r24, Y+1	; 0x01
    2632:	eb 81       	ldd	r30, Y+3	; 0x03
    2634:	fc 81       	ldd	r31, Y+4	; 0x04
    2636:	80 83       	st	Z, r24
	pxTopOfStack--;
    2638:	8b 81       	ldd	r24, Y+3	; 0x03
    263a:	9c 81       	ldd	r25, Y+4	; 0x04
    263c:	01 97       	sbiw	r24, 0x01	; 1
    263e:	9c 83       	std	Y+4, r25	; 0x04
    2640:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    2642:	eb 81       	ldd	r30, Y+3	; 0x03
    2644:	fc 81       	ldd	r31, Y+4	; 0x04
    2646:	86 e2       	ldi	r24, 0x26	; 38
    2648:	80 83       	st	Z, r24
	pxTopOfStack--;
    264a:	8b 81       	ldd	r24, Y+3	; 0x03
    264c:	9c 81       	ldd	r25, Y+4	; 0x04
    264e:	01 97       	sbiw	r24, 0x01	; 1
    2650:	9c 83       	std	Y+4, r25	; 0x04
    2652:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    2654:	eb 81       	ldd	r30, Y+3	; 0x03
    2656:	fc 81       	ldd	r31, Y+4	; 0x04
    2658:	87 e2       	ldi	r24, 0x27	; 39
    265a:	80 83       	st	Z, r24
	pxTopOfStack--;
    265c:	8b 81       	ldd	r24, Y+3	; 0x03
    265e:	9c 81       	ldd	r25, Y+4	; 0x04
    2660:	01 97       	sbiw	r24, 0x01	; 1
    2662:	9c 83       	std	Y+4, r25	; 0x04
    2664:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    2666:	eb 81       	ldd	r30, Y+3	; 0x03
    2668:	fc 81       	ldd	r31, Y+4	; 0x04
    266a:	88 e2       	ldi	r24, 0x28	; 40
    266c:	80 83       	st	Z, r24
	pxTopOfStack--;
    266e:	8b 81       	ldd	r24, Y+3	; 0x03
    2670:	9c 81       	ldd	r25, Y+4	; 0x04
    2672:	01 97       	sbiw	r24, 0x01	; 1
    2674:	9c 83       	std	Y+4, r25	; 0x04
    2676:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    2678:	eb 81       	ldd	r30, Y+3	; 0x03
    267a:	fc 81       	ldd	r31, Y+4	; 0x04
    267c:	89 e2       	ldi	r24, 0x29	; 41
    267e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2680:	8b 81       	ldd	r24, Y+3	; 0x03
    2682:	9c 81       	ldd	r25, Y+4	; 0x04
    2684:	01 97       	sbiw	r24, 0x01	; 1
    2686:	9c 83       	std	Y+4, r25	; 0x04
    2688:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    268a:	eb 81       	ldd	r30, Y+3	; 0x03
    268c:	fc 81       	ldd	r31, Y+4	; 0x04
    268e:	80 e3       	ldi	r24, 0x30	; 48
    2690:	80 83       	st	Z, r24
	pxTopOfStack--;
    2692:	8b 81       	ldd	r24, Y+3	; 0x03
    2694:	9c 81       	ldd	r25, Y+4	; 0x04
    2696:	01 97       	sbiw	r24, 0x01	; 1
    2698:	9c 83       	std	Y+4, r25	; 0x04
    269a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    269c:	eb 81       	ldd	r30, Y+3	; 0x03
    269e:	fc 81       	ldd	r31, Y+4	; 0x04
    26a0:	81 e3       	ldi	r24, 0x31	; 49
    26a2:	80 83       	st	Z, r24
	pxTopOfStack--;
    26a4:	8b 81       	ldd	r24, Y+3	; 0x03
    26a6:	9c 81       	ldd	r25, Y+4	; 0x04
    26a8:	01 97       	sbiw	r24, 0x01	; 1
    26aa:	9c 83       	std	Y+4, r25	; 0x04
    26ac:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    26ae:	8b 81       	ldd	r24, Y+3	; 0x03
    26b0:	9c 81       	ldd	r25, Y+4	; 0x04
}
    26b2:	28 96       	adiw	r28, 0x08	; 8
    26b4:	0f b6       	in	r0, 0x3f	; 63
    26b6:	f8 94       	cli
    26b8:	de bf       	out	0x3e, r29	; 62
    26ba:	0f be       	out	0x3f, r0	; 63
    26bc:	cd bf       	out	0x3d, r28	; 61
    26be:	cf 91       	pop	r28
    26c0:	df 91       	pop	r29
    26c2:	08 95       	ret

000026c4 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    26c4:	df 93       	push	r29
    26c6:	cf 93       	push	r28
    26c8:	cd b7       	in	r28, 0x3d	; 61
    26ca:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    26cc:	0e 94 52 14 	call	0x28a4	; 0x28a4 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    26d0:	a0 91 04 03 	lds	r26, 0x0304
    26d4:	b0 91 05 03 	lds	r27, 0x0305
    26d8:	cd 91       	ld	r28, X+
    26da:	cd bf       	out	0x3d, r28	; 61
    26dc:	dd 91       	ld	r29, X+
    26de:	de bf       	out	0x3e, r29	; 62
    26e0:	ff 91       	pop	r31
    26e2:	ef 91       	pop	r30
    26e4:	df 91       	pop	r29
    26e6:	cf 91       	pop	r28
    26e8:	bf 91       	pop	r27
    26ea:	af 91       	pop	r26
    26ec:	9f 91       	pop	r25
    26ee:	8f 91       	pop	r24
    26f0:	7f 91       	pop	r23
    26f2:	6f 91       	pop	r22
    26f4:	5f 91       	pop	r21
    26f6:	4f 91       	pop	r20
    26f8:	3f 91       	pop	r19
    26fa:	2f 91       	pop	r18
    26fc:	1f 91       	pop	r17
    26fe:	0f 91       	pop	r16
    2700:	ff 90       	pop	r15
    2702:	ef 90       	pop	r14
    2704:	df 90       	pop	r13
    2706:	cf 90       	pop	r12
    2708:	bf 90       	pop	r11
    270a:	af 90       	pop	r10
    270c:	9f 90       	pop	r9
    270e:	8f 90       	pop	r8
    2710:	7f 90       	pop	r7
    2712:	6f 90       	pop	r6
    2714:	5f 90       	pop	r5
    2716:	4f 90       	pop	r4
    2718:	3f 90       	pop	r3
    271a:	2f 90       	pop	r2
    271c:	1f 90       	pop	r1
    271e:	0f 90       	pop	r0
    2720:	0f be       	out	0x3f, r0	; 63
    2722:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2724:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2726:	81 e0       	ldi	r24, 0x01	; 1
}
    2728:	cf 91       	pop	r28
    272a:	df 91       	pop	r29
    272c:	08 95       	ret

0000272e <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    272e:	df 93       	push	r29
    2730:	cf 93       	push	r28
    2732:	cd b7       	in	r28, 0x3d	; 61
    2734:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2736:	cf 91       	pop	r28
    2738:	df 91       	pop	r29
    273a:	08 95       	ret

0000273c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    273c:	0f 92       	push	r0
    273e:	0f b6       	in	r0, 0x3f	; 63
    2740:	f8 94       	cli
    2742:	0f 92       	push	r0
    2744:	1f 92       	push	r1
    2746:	11 24       	eor	r1, r1
    2748:	2f 92       	push	r2
    274a:	3f 92       	push	r3
    274c:	4f 92       	push	r4
    274e:	5f 92       	push	r5
    2750:	6f 92       	push	r6
    2752:	7f 92       	push	r7
    2754:	8f 92       	push	r8
    2756:	9f 92       	push	r9
    2758:	af 92       	push	r10
    275a:	bf 92       	push	r11
    275c:	cf 92       	push	r12
    275e:	df 92       	push	r13
    2760:	ef 92       	push	r14
    2762:	ff 92       	push	r15
    2764:	0f 93       	push	r16
    2766:	1f 93       	push	r17
    2768:	2f 93       	push	r18
    276a:	3f 93       	push	r19
    276c:	4f 93       	push	r20
    276e:	5f 93       	push	r21
    2770:	6f 93       	push	r22
    2772:	7f 93       	push	r23
    2774:	8f 93       	push	r24
    2776:	9f 93       	push	r25
    2778:	af 93       	push	r26
    277a:	bf 93       	push	r27
    277c:	cf 93       	push	r28
    277e:	df 93       	push	r29
    2780:	ef 93       	push	r30
    2782:	ff 93       	push	r31
    2784:	a0 91 04 03 	lds	r26, 0x0304
    2788:	b0 91 05 03 	lds	r27, 0x0305
    278c:	0d b6       	in	r0, 0x3d	; 61
    278e:	0d 92       	st	X+, r0
    2790:	0e b6       	in	r0, 0x3e	; 62
    2792:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2794:	0e 94 0e 1d 	call	0x3a1c	; 0x3a1c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2798:	a0 91 04 03 	lds	r26, 0x0304
    279c:	b0 91 05 03 	lds	r27, 0x0305
    27a0:	cd 91       	ld	r28, X+
    27a2:	cd bf       	out	0x3d, r28	; 61
    27a4:	dd 91       	ld	r29, X+
    27a6:	de bf       	out	0x3e, r29	; 62
    27a8:	ff 91       	pop	r31
    27aa:	ef 91       	pop	r30
    27ac:	df 91       	pop	r29
    27ae:	cf 91       	pop	r28
    27b0:	bf 91       	pop	r27
    27b2:	af 91       	pop	r26
    27b4:	9f 91       	pop	r25
    27b6:	8f 91       	pop	r24
    27b8:	7f 91       	pop	r23
    27ba:	6f 91       	pop	r22
    27bc:	5f 91       	pop	r21
    27be:	4f 91       	pop	r20
    27c0:	3f 91       	pop	r19
    27c2:	2f 91       	pop	r18
    27c4:	1f 91       	pop	r17
    27c6:	0f 91       	pop	r16
    27c8:	ff 90       	pop	r15
    27ca:	ef 90       	pop	r14
    27cc:	df 90       	pop	r13
    27ce:	cf 90       	pop	r12
    27d0:	bf 90       	pop	r11
    27d2:	af 90       	pop	r10
    27d4:	9f 90       	pop	r9
    27d6:	8f 90       	pop	r8
    27d8:	7f 90       	pop	r7
    27da:	6f 90       	pop	r6
    27dc:	5f 90       	pop	r5
    27de:	4f 90       	pop	r4
    27e0:	3f 90       	pop	r3
    27e2:	2f 90       	pop	r2
    27e4:	1f 90       	pop	r1
    27e6:	0f 90       	pop	r0
    27e8:	0f be       	out	0x3f, r0	; 63
    27ea:	0f 90       	pop	r0

	asm volatile ( "ret" );
    27ec:	08 95       	ret

000027ee <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    27ee:	0f 92       	push	r0
    27f0:	0f b6       	in	r0, 0x3f	; 63
    27f2:	f8 94       	cli
    27f4:	0f 92       	push	r0
    27f6:	1f 92       	push	r1
    27f8:	11 24       	eor	r1, r1
    27fa:	2f 92       	push	r2
    27fc:	3f 92       	push	r3
    27fe:	4f 92       	push	r4
    2800:	5f 92       	push	r5
    2802:	6f 92       	push	r6
    2804:	7f 92       	push	r7
    2806:	8f 92       	push	r8
    2808:	9f 92       	push	r9
    280a:	af 92       	push	r10
    280c:	bf 92       	push	r11
    280e:	cf 92       	push	r12
    2810:	df 92       	push	r13
    2812:	ef 92       	push	r14
    2814:	ff 92       	push	r15
    2816:	0f 93       	push	r16
    2818:	1f 93       	push	r17
    281a:	2f 93       	push	r18
    281c:	3f 93       	push	r19
    281e:	4f 93       	push	r20
    2820:	5f 93       	push	r21
    2822:	6f 93       	push	r22
    2824:	7f 93       	push	r23
    2826:	8f 93       	push	r24
    2828:	9f 93       	push	r25
    282a:	af 93       	push	r26
    282c:	bf 93       	push	r27
    282e:	cf 93       	push	r28
    2830:	df 93       	push	r29
    2832:	ef 93       	push	r30
    2834:	ff 93       	push	r31
    2836:	a0 91 04 03 	lds	r26, 0x0304
    283a:	b0 91 05 03 	lds	r27, 0x0305
    283e:	0d b6       	in	r0, 0x3d	; 61
    2840:	0d 92       	st	X+, r0
    2842:	0e b6       	in	r0, 0x3e	; 62
    2844:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    2846:	0e 94 39 1c 	call	0x3872	; 0x3872 <vTaskIncrementTick>
	vTaskSwitchContext();
    284a:	0e 94 0e 1d 	call	0x3a1c	; 0x3a1c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    284e:	a0 91 04 03 	lds	r26, 0x0304
    2852:	b0 91 05 03 	lds	r27, 0x0305
    2856:	cd 91       	ld	r28, X+
    2858:	cd bf       	out	0x3d, r28	; 61
    285a:	dd 91       	ld	r29, X+
    285c:	de bf       	out	0x3e, r29	; 62
    285e:	ff 91       	pop	r31
    2860:	ef 91       	pop	r30
    2862:	df 91       	pop	r29
    2864:	cf 91       	pop	r28
    2866:	bf 91       	pop	r27
    2868:	af 91       	pop	r26
    286a:	9f 91       	pop	r25
    286c:	8f 91       	pop	r24
    286e:	7f 91       	pop	r23
    2870:	6f 91       	pop	r22
    2872:	5f 91       	pop	r21
    2874:	4f 91       	pop	r20
    2876:	3f 91       	pop	r19
    2878:	2f 91       	pop	r18
    287a:	1f 91       	pop	r17
    287c:	0f 91       	pop	r16
    287e:	ff 90       	pop	r15
    2880:	ef 90       	pop	r14
    2882:	df 90       	pop	r13
    2884:	cf 90       	pop	r12
    2886:	bf 90       	pop	r11
    2888:	af 90       	pop	r10
    288a:	9f 90       	pop	r9
    288c:	8f 90       	pop	r8
    288e:	7f 90       	pop	r7
    2890:	6f 90       	pop	r6
    2892:	5f 90       	pop	r5
    2894:	4f 90       	pop	r4
    2896:	3f 90       	pop	r3
    2898:	2f 90       	pop	r2
    289a:	1f 90       	pop	r1
    289c:	0f 90       	pop	r0
    289e:	0f be       	out	0x3f, r0	; 63
    28a0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    28a2:	08 95       	ret

000028a4 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    28a4:	df 93       	push	r29
    28a6:	cf 93       	push	r28
    28a8:	00 d0       	rcall	.+0      	; 0x28aa <prvSetupTimerInterrupt+0x6>
    28aa:	00 d0       	rcall	.+0      	; 0x28ac <prvSetupTimerInterrupt+0x8>
    28ac:	00 d0       	rcall	.+0      	; 0x28ae <prvSetupTimerInterrupt+0xa>
    28ae:	cd b7       	in	r28, 0x3d	; 61
    28b0:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    28b2:	80 ee       	ldi	r24, 0xE0	; 224
    28b4:	9e e2       	ldi	r25, 0x2E	; 46
    28b6:	a0 e0       	ldi	r26, 0x00	; 0
    28b8:	b0 e0       	ldi	r27, 0x00	; 0
    28ba:	8b 83       	std	Y+3, r24	; 0x03
    28bc:	9c 83       	std	Y+4, r25	; 0x04
    28be:	ad 83       	std	Y+5, r26	; 0x05
    28c0:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    28c2:	8b 81       	ldd	r24, Y+3	; 0x03
    28c4:	9c 81       	ldd	r25, Y+4	; 0x04
    28c6:	ad 81       	ldd	r26, Y+5	; 0x05
    28c8:	be 81       	ldd	r27, Y+6	; 0x06
    28ca:	68 94       	set
    28cc:	15 f8       	bld	r1, 5
    28ce:	b6 95       	lsr	r27
    28d0:	a7 95       	ror	r26
    28d2:	97 95       	ror	r25
    28d4:	87 95       	ror	r24
    28d6:	16 94       	lsr	r1
    28d8:	d1 f7       	brne	.-12     	; 0x28ce <prvSetupTimerInterrupt+0x2a>
    28da:	8b 83       	std	Y+3, r24	; 0x03
    28dc:	9c 83       	std	Y+4, r25	; 0x04
    28de:	ad 83       	std	Y+5, r26	; 0x05
    28e0:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    28e2:	8b 81       	ldd	r24, Y+3	; 0x03
    28e4:	9c 81       	ldd	r25, Y+4	; 0x04
    28e6:	ad 81       	ldd	r26, Y+5	; 0x05
    28e8:	be 81       	ldd	r27, Y+6	; 0x06
    28ea:	01 97       	sbiw	r24, 0x01	; 1
    28ec:	a1 09       	sbc	r26, r1
    28ee:	b1 09       	sbc	r27, r1
    28f0:	8b 83       	std	Y+3, r24	; 0x03
    28f2:	9c 83       	std	Y+4, r25	; 0x04
    28f4:	ad 83       	std	Y+5, r26	; 0x05
    28f6:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    28f8:	8b 81       	ldd	r24, Y+3	; 0x03
    28fa:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    28fc:	8b 81       	ldd	r24, Y+3	; 0x03
    28fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2900:	ad 81       	ldd	r26, Y+5	; 0x05
    2902:	be 81       	ldd	r27, Y+6	; 0x06
    2904:	89 2f       	mov	r24, r25
    2906:	9a 2f       	mov	r25, r26
    2908:	ab 2f       	mov	r26, r27
    290a:	bb 27       	eor	r27, r27
    290c:	8b 83       	std	Y+3, r24	; 0x03
    290e:	9c 83       	std	Y+4, r25	; 0x04
    2910:	ad 83       	std	Y+5, r26	; 0x05
    2912:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    2914:	8b 81       	ldd	r24, Y+3	; 0x03
    2916:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    2918:	eb e4       	ldi	r30, 0x4B	; 75
    291a:	f0 e0       	ldi	r31, 0x00	; 0
    291c:	8a 81       	ldd	r24, Y+2	; 0x02
    291e:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    2920:	ea e4       	ldi	r30, 0x4A	; 74
    2922:	f0 e0       	ldi	r31, 0x00	; 0
    2924:	89 81       	ldd	r24, Y+1	; 0x01
    2926:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2928:	8b e0       	ldi	r24, 0x0B	; 11
    292a:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    292c:	ee e4       	ldi	r30, 0x4E	; 78
    292e:	f0 e0       	ldi	r31, 0x00	; 0
    2930:	89 81       	ldd	r24, Y+1	; 0x01
    2932:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2934:	e9 e5       	ldi	r30, 0x59	; 89
    2936:	f0 e0       	ldi	r31, 0x00	; 0
    2938:	80 81       	ld	r24, Z
    293a:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    293c:	89 81       	ldd	r24, Y+1	; 0x01
    293e:	80 61       	ori	r24, 0x10	; 16
    2940:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    2942:	e9 e5       	ldi	r30, 0x59	; 89
    2944:	f0 e0       	ldi	r31, 0x00	; 0
    2946:	89 81       	ldd	r24, Y+1	; 0x01
    2948:	80 83       	st	Z, r24
}
    294a:	26 96       	adiw	r28, 0x06	; 6
    294c:	0f b6       	in	r0, 0x3f	; 63
    294e:	f8 94       	cli
    2950:	de bf       	out	0x3e, r29	; 62
    2952:	0f be       	out	0x3f, r0	; 63
    2954:	cd bf       	out	0x3d, r28	; 61
    2956:	cf 91       	pop	r28
    2958:	df 91       	pop	r29
    295a:	08 95       	ret

0000295c <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void  TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void  TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    295c:	0e 94 f7 13 	call	0x27ee	; 0x27ee <vPortYieldFromTick>
		asm volatile ( "reti" );
    2960:	18 95       	reti

00002962 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    2962:	df 93       	push	r29
    2964:	cf 93       	push	r28
    2966:	cd b7       	in	r28, 0x3d	; 61
    2968:	de b7       	in	r29, 0x3e	; 62
    296a:	28 97       	sbiw	r28, 0x08	; 8
    296c:	0f b6       	in	r0, 0x3f	; 63
    296e:	f8 94       	cli
    2970:	de bf       	out	0x3e, r29	; 62
    2972:	0f be       	out	0x3f, r0	; 63
    2974:	cd bf       	out	0x3d, r28	; 61
    2976:	8f 83       	std	Y+7, r24	; 0x07
    2978:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    297a:	1a 82       	std	Y+2, r1	; 0x02
    297c:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    297e:	8f 81       	ldd	r24, Y+7	; 0x07
    2980:	88 23       	and	r24, r24
    2982:	09 f4       	brne	.+2      	; 0x2986 <xQueueCreate+0x24>
    2984:	8c c0       	rjmp	.+280    	; 0x2a9e <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    2986:	8f e1       	ldi	r24, 0x1F	; 31
    2988:	90 e0       	ldi	r25, 0x00	; 0
    298a:	0e 94 38 10 	call	0x2070	; 0x2070 <pvPortMalloc>
    298e:	9e 83       	std	Y+6, r25	; 0x06
    2990:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    2992:	8d 81       	ldd	r24, Y+5	; 0x05
    2994:	9e 81       	ldd	r25, Y+6	; 0x06
    2996:	00 97       	sbiw	r24, 0x00	; 0
    2998:	09 f4       	brne	.+2      	; 0x299c <xQueueCreate+0x3a>
    299a:	81 c0       	rjmp	.+258    	; 0x2a9e <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    299c:	8f 81       	ldd	r24, Y+7	; 0x07
    299e:	28 2f       	mov	r18, r24
    29a0:	30 e0       	ldi	r19, 0x00	; 0
    29a2:	88 85       	ldd	r24, Y+8	; 0x08
    29a4:	88 2f       	mov	r24, r24
    29a6:	90 e0       	ldi	r25, 0x00	; 0
    29a8:	ac 01       	movw	r20, r24
    29aa:	24 9f       	mul	r18, r20
    29ac:	c0 01       	movw	r24, r0
    29ae:	25 9f       	mul	r18, r21
    29b0:	90 0d       	add	r25, r0
    29b2:	34 9f       	mul	r19, r20
    29b4:	90 0d       	add	r25, r0
    29b6:	11 24       	eor	r1, r1
    29b8:	01 96       	adiw	r24, 0x01	; 1
    29ba:	9c 83       	std	Y+4, r25	; 0x04
    29bc:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    29be:	8b 81       	ldd	r24, Y+3	; 0x03
    29c0:	9c 81       	ldd	r25, Y+4	; 0x04
    29c2:	0e 94 38 10 	call	0x2070	; 0x2070 <pvPortMalloc>
    29c6:	ed 81       	ldd	r30, Y+5	; 0x05
    29c8:	fe 81       	ldd	r31, Y+6	; 0x06
    29ca:	91 83       	std	Z+1, r25	; 0x01
    29cc:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    29ce:	ed 81       	ldd	r30, Y+5	; 0x05
    29d0:	fe 81       	ldd	r31, Y+6	; 0x06
    29d2:	80 81       	ld	r24, Z
    29d4:	91 81       	ldd	r25, Z+1	; 0x01
    29d6:	00 97       	sbiw	r24, 0x00	; 0
    29d8:	09 f4       	brne	.+2      	; 0x29dc <xQueueCreate+0x7a>
    29da:	5d c0       	rjmp	.+186    	; 0x2a96 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    29dc:	ed 81       	ldd	r30, Y+5	; 0x05
    29de:	fe 81       	ldd	r31, Y+6	; 0x06
    29e0:	40 81       	ld	r20, Z
    29e2:	51 81       	ldd	r21, Z+1	; 0x01
    29e4:	8f 81       	ldd	r24, Y+7	; 0x07
    29e6:	28 2f       	mov	r18, r24
    29e8:	30 e0       	ldi	r19, 0x00	; 0
    29ea:	88 85       	ldd	r24, Y+8	; 0x08
    29ec:	88 2f       	mov	r24, r24
    29ee:	90 e0       	ldi	r25, 0x00	; 0
    29f0:	bc 01       	movw	r22, r24
    29f2:	26 9f       	mul	r18, r22
    29f4:	c0 01       	movw	r24, r0
    29f6:	27 9f       	mul	r18, r23
    29f8:	90 0d       	add	r25, r0
    29fa:	36 9f       	mul	r19, r22
    29fc:	90 0d       	add	r25, r0
    29fe:	11 24       	eor	r1, r1
    2a00:	84 0f       	add	r24, r20
    2a02:	95 1f       	adc	r25, r21
    2a04:	ed 81       	ldd	r30, Y+5	; 0x05
    2a06:	fe 81       	ldd	r31, Y+6	; 0x06
    2a08:	93 83       	std	Z+3, r25	; 0x03
    2a0a:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    2a0c:	ed 81       	ldd	r30, Y+5	; 0x05
    2a0e:	fe 81       	ldd	r31, Y+6	; 0x06
    2a10:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    2a12:	ed 81       	ldd	r30, Y+5	; 0x05
    2a14:	fe 81       	ldd	r31, Y+6	; 0x06
    2a16:	80 81       	ld	r24, Z
    2a18:	91 81       	ldd	r25, Z+1	; 0x01
    2a1a:	ed 81       	ldd	r30, Y+5	; 0x05
    2a1c:	fe 81       	ldd	r31, Y+6	; 0x06
    2a1e:	95 83       	std	Z+5, r25	; 0x05
    2a20:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    2a22:	ed 81       	ldd	r30, Y+5	; 0x05
    2a24:	fe 81       	ldd	r31, Y+6	; 0x06
    2a26:	40 81       	ld	r20, Z
    2a28:	51 81       	ldd	r21, Z+1	; 0x01
    2a2a:	8f 81       	ldd	r24, Y+7	; 0x07
    2a2c:	88 2f       	mov	r24, r24
    2a2e:	90 e0       	ldi	r25, 0x00	; 0
    2a30:	9c 01       	movw	r18, r24
    2a32:	21 50       	subi	r18, 0x01	; 1
    2a34:	30 40       	sbci	r19, 0x00	; 0
    2a36:	88 85       	ldd	r24, Y+8	; 0x08
    2a38:	88 2f       	mov	r24, r24
    2a3a:	90 e0       	ldi	r25, 0x00	; 0
    2a3c:	bc 01       	movw	r22, r24
    2a3e:	26 9f       	mul	r18, r22
    2a40:	c0 01       	movw	r24, r0
    2a42:	27 9f       	mul	r18, r23
    2a44:	90 0d       	add	r25, r0
    2a46:	36 9f       	mul	r19, r22
    2a48:	90 0d       	add	r25, r0
    2a4a:	11 24       	eor	r1, r1
    2a4c:	84 0f       	add	r24, r20
    2a4e:	95 1f       	adc	r25, r21
    2a50:	ed 81       	ldd	r30, Y+5	; 0x05
    2a52:	fe 81       	ldd	r31, Y+6	; 0x06
    2a54:	97 83       	std	Z+7, r25	; 0x07
    2a56:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    2a58:	ed 81       	ldd	r30, Y+5	; 0x05
    2a5a:	fe 81       	ldd	r31, Y+6	; 0x06
    2a5c:	8f 81       	ldd	r24, Y+7	; 0x07
    2a5e:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    2a60:	ed 81       	ldd	r30, Y+5	; 0x05
    2a62:	fe 81       	ldd	r31, Y+6	; 0x06
    2a64:	88 85       	ldd	r24, Y+8	; 0x08
    2a66:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    2a68:	ed 81       	ldd	r30, Y+5	; 0x05
    2a6a:	fe 81       	ldd	r31, Y+6	; 0x06
    2a6c:	8f ef       	ldi	r24, 0xFF	; 255
    2a6e:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    2a70:	ed 81       	ldd	r30, Y+5	; 0x05
    2a72:	fe 81       	ldd	r31, Y+6	; 0x06
    2a74:	8f ef       	ldi	r24, 0xFF	; 255
    2a76:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    2a78:	8d 81       	ldd	r24, Y+5	; 0x05
    2a7a:	9e 81       	ldd	r25, Y+6	; 0x06
    2a7c:	08 96       	adiw	r24, 0x08	; 8
    2a7e:	0e 94 a4 10 	call	0x2148	; 0x2148 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    2a82:	8d 81       	ldd	r24, Y+5	; 0x05
    2a84:	9e 81       	ldd	r25, Y+6	; 0x06
    2a86:	41 96       	adiw	r24, 0x11	; 17
    2a88:	0e 94 a4 10 	call	0x2148	; 0x2148 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    2a8c:	8d 81       	ldd	r24, Y+5	; 0x05
    2a8e:	9e 81       	ldd	r25, Y+6	; 0x06
    2a90:	9a 83       	std	Y+2, r25	; 0x02
    2a92:	89 83       	std	Y+1, r24	; 0x01
    2a94:	04 c0       	rjmp	.+8      	; 0x2a9e <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    2a96:	8d 81       	ldd	r24, Y+5	; 0x05
    2a98:	9e 81       	ldd	r25, Y+6	; 0x06
    2a9a:	0e 94 7e 10 	call	0x20fc	; 0x20fc <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    2a9e:	89 81       	ldd	r24, Y+1	; 0x01
    2aa0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2aa2:	28 96       	adiw	r28, 0x08	; 8
    2aa4:	0f b6       	in	r0, 0x3f	; 63
    2aa6:	f8 94       	cli
    2aa8:	de bf       	out	0x3e, r29	; 62
    2aaa:	0f be       	out	0x3f, r0	; 63
    2aac:	cd bf       	out	0x3d, r28	; 61
    2aae:	cf 91       	pop	r28
    2ab0:	df 91       	pop	r29
    2ab2:	08 95       	ret

00002ab4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    2ab4:	df 93       	push	r29
    2ab6:	cf 93       	push	r28
    2ab8:	cd b7       	in	r28, 0x3d	; 61
    2aba:	de b7       	in	r29, 0x3e	; 62
    2abc:	2c 97       	sbiw	r28, 0x0c	; 12
    2abe:	0f b6       	in	r0, 0x3f	; 63
    2ac0:	f8 94       	cli
    2ac2:	de bf       	out	0x3e, r29	; 62
    2ac4:	0f be       	out	0x3f, r0	; 63
    2ac6:	cd bf       	out	0x3d, r28	; 61
    2ac8:	9e 83       	std	Y+6, r25	; 0x06
    2aca:	8d 83       	std	Y+5, r24	; 0x05
    2acc:	78 87       	std	Y+8, r23	; 0x08
    2ace:	6f 83       	std	Y+7, r22	; 0x07
    2ad0:	5a 87       	std	Y+10, r21	; 0x0a
    2ad2:	49 87       	std	Y+9, r20	; 0x09
    2ad4:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    2ad6:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2ad8:	0f b6       	in	r0, 0x3f	; 63
    2ada:	f8 94       	cli
    2adc:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2ade:	ed 81       	ldd	r30, Y+5	; 0x05
    2ae0:	fe 81       	ldd	r31, Y+6	; 0x06
    2ae2:	92 8d       	ldd	r25, Z+26	; 0x1a
    2ae4:	ed 81       	ldd	r30, Y+5	; 0x05
    2ae6:	fe 81       	ldd	r31, Y+6	; 0x06
    2ae8:	83 8d       	ldd	r24, Z+27	; 0x1b
    2aea:	98 17       	cp	r25, r24
    2aec:	d8 f4       	brcc	.+54     	; 0x2b24 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2aee:	8d 81       	ldd	r24, Y+5	; 0x05
    2af0:	9e 81       	ldd	r25, Y+6	; 0x06
    2af2:	2f 81       	ldd	r18, Y+7	; 0x07
    2af4:	38 85       	ldd	r19, Y+8	; 0x08
    2af6:	b9 01       	movw	r22, r18
    2af8:	4b 85       	ldd	r20, Y+11	; 0x0b
    2afa:	0e 94 95 17 	call	0x2f2a	; 0x2f2a <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2afe:	ed 81       	ldd	r30, Y+5	; 0x05
    2b00:	fe 81       	ldd	r31, Y+6	; 0x06
    2b02:	81 89       	ldd	r24, Z+17	; 0x11
    2b04:	88 23       	and	r24, r24
    2b06:	49 f0       	breq	.+18     	; 0x2b1a <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    2b08:	8d 81       	ldd	r24, Y+5	; 0x05
    2b0a:	9e 81       	ldd	r25, Y+6	; 0x06
    2b0c:	41 96       	adiw	r24, 0x11	; 17
    2b0e:	0e 94 aa 1d 	call	0x3b54	; 0x3b54 <xTaskRemoveFromEventList>
    2b12:	81 30       	cpi	r24, 0x01	; 1
    2b14:	11 f4       	brne	.+4      	; 0x2b1a <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    2b16:	0e 94 9e 13 	call	0x273c	; 0x273c <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    2b1a:	0f 90       	pop	r0
    2b1c:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    2b1e:	81 e0       	ldi	r24, 0x01	; 1
    2b20:	8c 87       	std	Y+12, r24	; 0x0c
    2b22:	5c c0       	rjmp	.+184    	; 0x2bdc <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    2b24:	89 85       	ldd	r24, Y+9	; 0x09
    2b26:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b28:	00 97       	sbiw	r24, 0x00	; 0
    2b2a:	21 f4       	brne	.+8      	; 0x2b34 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2b2c:	0f 90       	pop	r0
    2b2e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2b30:	1c 86       	std	Y+12, r1	; 0x0c
    2b32:	54 c0       	rjmp	.+168    	; 0x2bdc <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    2b34:	89 81       	ldd	r24, Y+1	; 0x01
    2b36:	88 23       	and	r24, r24
    2b38:	31 f4       	brne	.+12     	; 0x2b46 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2b3a:	ce 01       	movw	r24, r28
    2b3c:	02 96       	adiw	r24, 0x02	; 2
    2b3e:	0e 94 12 1e 	call	0x3c24	; 0x3c24 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2b42:	81 e0       	ldi	r24, 0x01	; 1
    2b44:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    2b46:	0f 90       	pop	r0
    2b48:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2b4a:	0e 94 6e 1b 	call	0x36dc	; 0x36dc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2b4e:	0f b6       	in	r0, 0x3f	; 63
    2b50:	f8 94       	cli
    2b52:	0f 92       	push	r0
    2b54:	ed 81       	ldd	r30, Y+5	; 0x05
    2b56:	fe 81       	ldd	r31, Y+6	; 0x06
    2b58:	85 8d       	ldd	r24, Z+29	; 0x1d
    2b5a:	8f 3f       	cpi	r24, 0xFF	; 255
    2b5c:	19 f4       	brne	.+6      	; 0x2b64 <xQueueGenericSend+0xb0>
    2b5e:	ed 81       	ldd	r30, Y+5	; 0x05
    2b60:	fe 81       	ldd	r31, Y+6	; 0x06
    2b62:	15 8e       	std	Z+29, r1	; 0x1d
    2b64:	ed 81       	ldd	r30, Y+5	; 0x05
    2b66:	fe 81       	ldd	r31, Y+6	; 0x06
    2b68:	86 8d       	ldd	r24, Z+30	; 0x1e
    2b6a:	8f 3f       	cpi	r24, 0xFF	; 255
    2b6c:	19 f4       	brne	.+6      	; 0x2b74 <xQueueGenericSend+0xc0>
    2b6e:	ed 81       	ldd	r30, Y+5	; 0x05
    2b70:	fe 81       	ldd	r31, Y+6	; 0x06
    2b72:	16 8e       	std	Z+30, r1	; 0x1e
    2b74:	0f 90       	pop	r0
    2b76:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2b78:	ce 01       	movw	r24, r28
    2b7a:	02 96       	adiw	r24, 0x02	; 2
    2b7c:	9e 01       	movw	r18, r28
    2b7e:	27 5f       	subi	r18, 0xF7	; 247
    2b80:	3f 4f       	sbci	r19, 0xFF	; 255
    2b82:	b9 01       	movw	r22, r18
    2b84:	0e 94 2b 1e 	call	0x3c56	; 0x3c56 <xTaskCheckForTimeOut>
    2b88:	88 23       	and	r24, r24
    2b8a:	09 f5       	brne	.+66     	; 0x2bce <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2b8c:	8d 81       	ldd	r24, Y+5	; 0x05
    2b8e:	9e 81       	ldd	r25, Y+6	; 0x06
    2b90:	0e 94 f9 18 	call	0x31f2	; 0x31f2 <prvIsQueueFull>
    2b94:	88 23       	and	r24, r24
    2b96:	a1 f0       	breq	.+40     	; 0x2bc0 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2b98:	8d 81       	ldd	r24, Y+5	; 0x05
    2b9a:	9e 81       	ldd	r25, Y+6	; 0x06
    2b9c:	08 96       	adiw	r24, 0x08	; 8
    2b9e:	29 85       	ldd	r18, Y+9	; 0x09
    2ba0:	3a 85       	ldd	r19, Y+10	; 0x0a
    2ba2:	b9 01       	movw	r22, r18
    2ba4:	0e 94 74 1d 	call	0x3ae8	; 0x3ae8 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2ba8:	8d 81       	ldd	r24, Y+5	; 0x05
    2baa:	9e 81       	ldd	r25, Y+6	; 0x06
    2bac:	0e 94 72 18 	call	0x30e4	; 0x30e4 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2bb0:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <xTaskResumeAll>
    2bb4:	88 23       	and	r24, r24
    2bb6:	09 f0       	breq	.+2      	; 0x2bba <xQueueGenericSend+0x106>
    2bb8:	8f cf       	rjmp	.-226    	; 0x2ad8 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    2bba:	0e 94 9e 13 	call	0x273c	; 0x273c <vPortYield>
    2bbe:	8c cf       	rjmp	.-232    	; 0x2ad8 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2bc0:	8d 81       	ldd	r24, Y+5	; 0x05
    2bc2:	9e 81       	ldd	r25, Y+6	; 0x06
    2bc4:	0e 94 72 18 	call	0x30e4	; 0x30e4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2bc8:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <xTaskResumeAll>
    2bcc:	85 cf       	rjmp	.-246    	; 0x2ad8 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2bce:	8d 81       	ldd	r24, Y+5	; 0x05
    2bd0:	9e 81       	ldd	r25, Y+6	; 0x06
    2bd2:	0e 94 72 18 	call	0x30e4	; 0x30e4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2bd6:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2bda:	1c 86       	std	Y+12, r1	; 0x0c
    2bdc:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    2bde:	2c 96       	adiw	r28, 0x0c	; 12
    2be0:	0f b6       	in	r0, 0x3f	; 63
    2be2:	f8 94       	cli
    2be4:	de bf       	out	0x3e, r29	; 62
    2be6:	0f be       	out	0x3f, r0	; 63
    2be8:	cd bf       	out	0x3d, r28	; 61
    2bea:	cf 91       	pop	r28
    2bec:	df 91       	pop	r29
    2bee:	08 95       	ret

00002bf0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    2bf0:	df 93       	push	r29
    2bf2:	cf 93       	push	r28
    2bf4:	cd b7       	in	r28, 0x3d	; 61
    2bf6:	de b7       	in	r29, 0x3e	; 62
    2bf8:	29 97       	sbiw	r28, 0x09	; 9
    2bfa:	0f b6       	in	r0, 0x3f	; 63
    2bfc:	f8 94       	cli
    2bfe:	de bf       	out	0x3e, r29	; 62
    2c00:	0f be       	out	0x3f, r0	; 63
    2c02:	cd bf       	out	0x3d, r28	; 61
    2c04:	9c 83       	std	Y+4, r25	; 0x04
    2c06:	8b 83       	std	Y+3, r24	; 0x03
    2c08:	7e 83       	std	Y+6, r23	; 0x06
    2c0a:	6d 83       	std	Y+5, r22	; 0x05
    2c0c:	58 87       	std	Y+8, r21	; 0x08
    2c0e:	4f 83       	std	Y+7, r20	; 0x07
    2c10:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2c12:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2c14:	eb 81       	ldd	r30, Y+3	; 0x03
    2c16:	fc 81       	ldd	r31, Y+4	; 0x04
    2c18:	92 8d       	ldd	r25, Z+26	; 0x1a
    2c1a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c1c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c1e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2c20:	98 17       	cp	r25, r24
    2c22:	40 f5       	brcc	.+80     	; 0x2c74 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2c24:	8b 81       	ldd	r24, Y+3	; 0x03
    2c26:	9c 81       	ldd	r25, Y+4	; 0x04
    2c28:	2d 81       	ldd	r18, Y+5	; 0x05
    2c2a:	3e 81       	ldd	r19, Y+6	; 0x06
    2c2c:	b9 01       	movw	r22, r18
    2c2e:	49 85       	ldd	r20, Y+9	; 0x09
    2c30:	0e 94 95 17 	call	0x2f2a	; 0x2f2a <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    2c34:	eb 81       	ldd	r30, Y+3	; 0x03
    2c36:	fc 81       	ldd	r31, Y+4	; 0x04
    2c38:	86 8d       	ldd	r24, Z+30	; 0x1e
    2c3a:	8f 3f       	cpi	r24, 0xFF	; 255
    2c3c:	89 f4       	brne	.+34     	; 0x2c60 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2c3e:	eb 81       	ldd	r30, Y+3	; 0x03
    2c40:	fc 81       	ldd	r31, Y+4	; 0x04
    2c42:	81 89       	ldd	r24, Z+17	; 0x11
    2c44:	88 23       	and	r24, r24
    2c46:	99 f0       	breq	.+38     	; 0x2c6e <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2c48:	8b 81       	ldd	r24, Y+3	; 0x03
    2c4a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c4c:	41 96       	adiw	r24, 0x11	; 17
    2c4e:	0e 94 aa 1d 	call	0x3b54	; 0x3b54 <xTaskRemoveFromEventList>
    2c52:	88 23       	and	r24, r24
    2c54:	61 f0       	breq	.+24     	; 0x2c6e <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    2c56:	ef 81       	ldd	r30, Y+7	; 0x07
    2c58:	f8 85       	ldd	r31, Y+8	; 0x08
    2c5a:	81 e0       	ldi	r24, 0x01	; 1
    2c5c:	80 83       	st	Z, r24
    2c5e:	07 c0       	rjmp	.+14     	; 0x2c6e <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    2c60:	eb 81       	ldd	r30, Y+3	; 0x03
    2c62:	fc 81       	ldd	r31, Y+4	; 0x04
    2c64:	86 8d       	ldd	r24, Z+30	; 0x1e
    2c66:	8f 5f       	subi	r24, 0xFF	; 255
    2c68:	eb 81       	ldd	r30, Y+3	; 0x03
    2c6a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c6c:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2c6e:	81 e0       	ldi	r24, 0x01	; 1
    2c70:	8a 83       	std	Y+2, r24	; 0x02
    2c72:	01 c0       	rjmp	.+2      	; 0x2c76 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2c74:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2c76:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2c78:	29 96       	adiw	r28, 0x09	; 9
    2c7a:	0f b6       	in	r0, 0x3f	; 63
    2c7c:	f8 94       	cli
    2c7e:	de bf       	out	0x3e, r29	; 62
    2c80:	0f be       	out	0x3f, r0	; 63
    2c82:	cd bf       	out	0x3d, r28	; 61
    2c84:	cf 91       	pop	r28
    2c86:	df 91       	pop	r29
    2c88:	08 95       	ret

00002c8a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    2c8a:	df 93       	push	r29
    2c8c:	cf 93       	push	r28
    2c8e:	cd b7       	in	r28, 0x3d	; 61
    2c90:	de b7       	in	r29, 0x3e	; 62
    2c92:	2e 97       	sbiw	r28, 0x0e	; 14
    2c94:	0f b6       	in	r0, 0x3f	; 63
    2c96:	f8 94       	cli
    2c98:	de bf       	out	0x3e, r29	; 62
    2c9a:	0f be       	out	0x3f, r0	; 63
    2c9c:	cd bf       	out	0x3d, r28	; 61
    2c9e:	98 87       	std	Y+8, r25	; 0x08
    2ca0:	8f 83       	std	Y+7, r24	; 0x07
    2ca2:	7a 87       	std	Y+10, r23	; 0x0a
    2ca4:	69 87       	std	Y+9, r22	; 0x09
    2ca6:	5c 87       	std	Y+12, r21	; 0x0c
    2ca8:	4b 87       	std	Y+11, r20	; 0x0b
    2caa:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    2cac:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2cae:	0f b6       	in	r0, 0x3f	; 63
    2cb0:	f8 94       	cli
    2cb2:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2cb4:	ef 81       	ldd	r30, Y+7	; 0x07
    2cb6:	f8 85       	ldd	r31, Y+8	; 0x08
    2cb8:	82 8d       	ldd	r24, Z+26	; 0x1a
    2cba:	88 23       	and	r24, r24
    2cbc:	09 f4       	brne	.+2      	; 0x2cc0 <xQueueGenericReceive+0x36>
    2cbe:	3f c0       	rjmp	.+126    	; 0x2d3e <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    2cc0:	ef 81       	ldd	r30, Y+7	; 0x07
    2cc2:	f8 85       	ldd	r31, Y+8	; 0x08
    2cc4:	86 81       	ldd	r24, Z+6	; 0x06
    2cc6:	97 81       	ldd	r25, Z+7	; 0x07
    2cc8:	9a 83       	std	Y+2, r25	; 0x02
    2cca:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2ccc:	8f 81       	ldd	r24, Y+7	; 0x07
    2cce:	98 85       	ldd	r25, Y+8	; 0x08
    2cd0:	29 85       	ldd	r18, Y+9	; 0x09
    2cd2:	3a 85       	ldd	r19, Y+10	; 0x0a
    2cd4:	b9 01       	movw	r22, r18
    2cd6:	0e 94 2a 18 	call	0x3054	; 0x3054 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2cda:	8d 85       	ldd	r24, Y+13	; 0x0d
    2cdc:	88 23       	and	r24, r24
    2cde:	b1 f4       	brne	.+44     	; 0x2d0c <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    2ce0:	ef 81       	ldd	r30, Y+7	; 0x07
    2ce2:	f8 85       	ldd	r31, Y+8	; 0x08
    2ce4:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ce6:	81 50       	subi	r24, 0x01	; 1
    2ce8:	ef 81       	ldd	r30, Y+7	; 0x07
    2cea:	f8 85       	ldd	r31, Y+8	; 0x08
    2cec:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2cee:	ef 81       	ldd	r30, Y+7	; 0x07
    2cf0:	f8 85       	ldd	r31, Y+8	; 0x08
    2cf2:	80 85       	ldd	r24, Z+8	; 0x08
    2cf4:	88 23       	and	r24, r24
    2cf6:	f1 f0       	breq	.+60     	; 0x2d34 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2cf8:	8f 81       	ldd	r24, Y+7	; 0x07
    2cfa:	98 85       	ldd	r25, Y+8	; 0x08
    2cfc:	08 96       	adiw	r24, 0x08	; 8
    2cfe:	0e 94 aa 1d 	call	0x3b54	; 0x3b54 <xTaskRemoveFromEventList>
    2d02:	81 30       	cpi	r24, 0x01	; 1
    2d04:	b9 f4       	brne	.+46     	; 0x2d34 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    2d06:	0e 94 9e 13 	call	0x273c	; 0x273c <vPortYield>
    2d0a:	14 c0       	rjmp	.+40     	; 0x2d34 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    2d0c:	ef 81       	ldd	r30, Y+7	; 0x07
    2d0e:	f8 85       	ldd	r31, Y+8	; 0x08
    2d10:	89 81       	ldd	r24, Y+1	; 0x01
    2d12:	9a 81       	ldd	r25, Y+2	; 0x02
    2d14:	97 83       	std	Z+7, r25	; 0x07
    2d16:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2d18:	ef 81       	ldd	r30, Y+7	; 0x07
    2d1a:	f8 85       	ldd	r31, Y+8	; 0x08
    2d1c:	81 89       	ldd	r24, Z+17	; 0x11
    2d1e:	88 23       	and	r24, r24
    2d20:	49 f0       	breq	.+18     	; 0x2d34 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2d22:	8f 81       	ldd	r24, Y+7	; 0x07
    2d24:	98 85       	ldd	r25, Y+8	; 0x08
    2d26:	41 96       	adiw	r24, 0x11	; 17
    2d28:	0e 94 aa 1d 	call	0x3b54	; 0x3b54 <xTaskRemoveFromEventList>
    2d2c:	88 23       	and	r24, r24
    2d2e:	11 f0       	breq	.+4      	; 0x2d34 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    2d30:	0e 94 9e 13 	call	0x273c	; 0x273c <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    2d34:	0f 90       	pop	r0
    2d36:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2d38:	81 e0       	ldi	r24, 0x01	; 1
    2d3a:	8e 87       	std	Y+14, r24	; 0x0e
    2d3c:	5c c0       	rjmp	.+184    	; 0x2df6 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    2d3e:	8b 85       	ldd	r24, Y+11	; 0x0b
    2d40:	9c 85       	ldd	r25, Y+12	; 0x0c
    2d42:	00 97       	sbiw	r24, 0x00	; 0
    2d44:	21 f4       	brne	.+8      	; 0x2d4e <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2d46:	0f 90       	pop	r0
    2d48:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2d4a:	1e 86       	std	Y+14, r1	; 0x0e
    2d4c:	54 c0       	rjmp	.+168    	; 0x2df6 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    2d4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d50:	88 23       	and	r24, r24
    2d52:	31 f4       	brne	.+12     	; 0x2d60 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2d54:	ce 01       	movw	r24, r28
    2d56:	04 96       	adiw	r24, 0x04	; 4
    2d58:	0e 94 12 1e 	call	0x3c24	; 0x3c24 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2d5c:	81 e0       	ldi	r24, 0x01	; 1
    2d5e:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    2d60:	0f 90       	pop	r0
    2d62:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2d64:	0e 94 6e 1b 	call	0x36dc	; 0x36dc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2d68:	0f b6       	in	r0, 0x3f	; 63
    2d6a:	f8 94       	cli
    2d6c:	0f 92       	push	r0
    2d6e:	ef 81       	ldd	r30, Y+7	; 0x07
    2d70:	f8 85       	ldd	r31, Y+8	; 0x08
    2d72:	85 8d       	ldd	r24, Z+29	; 0x1d
    2d74:	8f 3f       	cpi	r24, 0xFF	; 255
    2d76:	19 f4       	brne	.+6      	; 0x2d7e <xQueueGenericReceive+0xf4>
    2d78:	ef 81       	ldd	r30, Y+7	; 0x07
    2d7a:	f8 85       	ldd	r31, Y+8	; 0x08
    2d7c:	15 8e       	std	Z+29, r1	; 0x1d
    2d7e:	ef 81       	ldd	r30, Y+7	; 0x07
    2d80:	f8 85       	ldd	r31, Y+8	; 0x08
    2d82:	86 8d       	ldd	r24, Z+30	; 0x1e
    2d84:	8f 3f       	cpi	r24, 0xFF	; 255
    2d86:	19 f4       	brne	.+6      	; 0x2d8e <xQueueGenericReceive+0x104>
    2d88:	ef 81       	ldd	r30, Y+7	; 0x07
    2d8a:	f8 85       	ldd	r31, Y+8	; 0x08
    2d8c:	16 8e       	std	Z+30, r1	; 0x1e
    2d8e:	0f 90       	pop	r0
    2d90:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2d92:	ce 01       	movw	r24, r28
    2d94:	04 96       	adiw	r24, 0x04	; 4
    2d96:	9e 01       	movw	r18, r28
    2d98:	25 5f       	subi	r18, 0xF5	; 245
    2d9a:	3f 4f       	sbci	r19, 0xFF	; 255
    2d9c:	b9 01       	movw	r22, r18
    2d9e:	0e 94 2b 1e 	call	0x3c56	; 0x3c56 <xTaskCheckForTimeOut>
    2da2:	88 23       	and	r24, r24
    2da4:	09 f5       	brne	.+66     	; 0x2de8 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2da6:	8f 81       	ldd	r24, Y+7	; 0x07
    2da8:	98 85       	ldd	r25, Y+8	; 0x08
    2daa:	0e 94 c6 18 	call	0x318c	; 0x318c <prvIsQueueEmpty>
    2dae:	88 23       	and	r24, r24
    2db0:	a1 f0       	breq	.+40     	; 0x2dda <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2db2:	8f 81       	ldd	r24, Y+7	; 0x07
    2db4:	98 85       	ldd	r25, Y+8	; 0x08
    2db6:	41 96       	adiw	r24, 0x11	; 17
    2db8:	2b 85       	ldd	r18, Y+11	; 0x0b
    2dba:	3c 85       	ldd	r19, Y+12	; 0x0c
    2dbc:	b9 01       	movw	r22, r18
    2dbe:	0e 94 74 1d 	call	0x3ae8	; 0x3ae8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2dc2:	8f 81       	ldd	r24, Y+7	; 0x07
    2dc4:	98 85       	ldd	r25, Y+8	; 0x08
    2dc6:	0e 94 72 18 	call	0x30e4	; 0x30e4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2dca:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <xTaskResumeAll>
    2dce:	88 23       	and	r24, r24
    2dd0:	09 f0       	breq	.+2      	; 0x2dd4 <xQueueGenericReceive+0x14a>
    2dd2:	6d cf       	rjmp	.-294    	; 0x2cae <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    2dd4:	0e 94 9e 13 	call	0x273c	; 0x273c <vPortYield>
    2dd8:	6a cf       	rjmp	.-300    	; 0x2cae <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2dda:	8f 81       	ldd	r24, Y+7	; 0x07
    2ddc:	98 85       	ldd	r25, Y+8	; 0x08
    2dde:	0e 94 72 18 	call	0x30e4	; 0x30e4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2de2:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <xTaskResumeAll>
    2de6:	63 cf       	rjmp	.-314    	; 0x2cae <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2de8:	8f 81       	ldd	r24, Y+7	; 0x07
    2dea:	98 85       	ldd	r25, Y+8	; 0x08
    2dec:	0e 94 72 18 	call	0x30e4	; 0x30e4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2df0:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    2df4:	1e 86       	std	Y+14, r1	; 0x0e
    2df6:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    2df8:	2e 96       	adiw	r28, 0x0e	; 14
    2dfa:	0f b6       	in	r0, 0x3f	; 63
    2dfc:	f8 94       	cli
    2dfe:	de bf       	out	0x3e, r29	; 62
    2e00:	0f be       	out	0x3f, r0	; 63
    2e02:	cd bf       	out	0x3d, r28	; 61
    2e04:	cf 91       	pop	r28
    2e06:	df 91       	pop	r29
    2e08:	08 95       	ret

00002e0a <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    2e0a:	df 93       	push	r29
    2e0c:	cf 93       	push	r28
    2e0e:	cd b7       	in	r28, 0x3d	; 61
    2e10:	de b7       	in	r29, 0x3e	; 62
    2e12:	28 97       	sbiw	r28, 0x08	; 8
    2e14:	0f b6       	in	r0, 0x3f	; 63
    2e16:	f8 94       	cli
    2e18:	de bf       	out	0x3e, r29	; 62
    2e1a:	0f be       	out	0x3f, r0	; 63
    2e1c:	cd bf       	out	0x3d, r28	; 61
    2e1e:	9c 83       	std	Y+4, r25	; 0x04
    2e20:	8b 83       	std	Y+3, r24	; 0x03
    2e22:	7e 83       	std	Y+6, r23	; 0x06
    2e24:	6d 83       	std	Y+5, r22	; 0x05
    2e26:	58 87       	std	Y+8, r21	; 0x08
    2e28:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2e2a:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2e2c:	eb 81       	ldd	r30, Y+3	; 0x03
    2e2e:	fc 81       	ldd	r31, Y+4	; 0x04
    2e30:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e32:	88 23       	and	r24, r24
    2e34:	71 f1       	breq	.+92     	; 0x2e92 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2e36:	8b 81       	ldd	r24, Y+3	; 0x03
    2e38:	9c 81       	ldd	r25, Y+4	; 0x04
    2e3a:	2d 81       	ldd	r18, Y+5	; 0x05
    2e3c:	3e 81       	ldd	r19, Y+6	; 0x06
    2e3e:	b9 01       	movw	r22, r18
    2e40:	0e 94 2a 18 	call	0x3054	; 0x3054 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    2e44:	eb 81       	ldd	r30, Y+3	; 0x03
    2e46:	fc 81       	ldd	r31, Y+4	; 0x04
    2e48:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e4a:	81 50       	subi	r24, 0x01	; 1
    2e4c:	eb 81       	ldd	r30, Y+3	; 0x03
    2e4e:	fc 81       	ldd	r31, Y+4	; 0x04
    2e50:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    2e52:	eb 81       	ldd	r30, Y+3	; 0x03
    2e54:	fc 81       	ldd	r31, Y+4	; 0x04
    2e56:	85 8d       	ldd	r24, Z+29	; 0x1d
    2e58:	8f 3f       	cpi	r24, 0xFF	; 255
    2e5a:	89 f4       	brne	.+34     	; 0x2e7e <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2e5c:	eb 81       	ldd	r30, Y+3	; 0x03
    2e5e:	fc 81       	ldd	r31, Y+4	; 0x04
    2e60:	80 85       	ldd	r24, Z+8	; 0x08
    2e62:	88 23       	and	r24, r24
    2e64:	99 f0       	breq	.+38     	; 0x2e8c <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2e66:	8b 81       	ldd	r24, Y+3	; 0x03
    2e68:	9c 81       	ldd	r25, Y+4	; 0x04
    2e6a:	08 96       	adiw	r24, 0x08	; 8
    2e6c:	0e 94 aa 1d 	call	0x3b54	; 0x3b54 <xTaskRemoveFromEventList>
    2e70:	88 23       	and	r24, r24
    2e72:	61 f0       	breq	.+24     	; 0x2e8c <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    2e74:	ef 81       	ldd	r30, Y+7	; 0x07
    2e76:	f8 85       	ldd	r31, Y+8	; 0x08
    2e78:	81 e0       	ldi	r24, 0x01	; 1
    2e7a:	80 83       	st	Z, r24
    2e7c:	07 c0       	rjmp	.+14     	; 0x2e8c <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2e7e:	eb 81       	ldd	r30, Y+3	; 0x03
    2e80:	fc 81       	ldd	r31, Y+4	; 0x04
    2e82:	85 8d       	ldd	r24, Z+29	; 0x1d
    2e84:	8f 5f       	subi	r24, 0xFF	; 255
    2e86:	eb 81       	ldd	r30, Y+3	; 0x03
    2e88:	fc 81       	ldd	r31, Y+4	; 0x04
    2e8a:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2e8c:	81 e0       	ldi	r24, 0x01	; 1
    2e8e:	8a 83       	std	Y+2, r24	; 0x02
    2e90:	01 c0       	rjmp	.+2      	; 0x2e94 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    2e92:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2e94:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2e96:	28 96       	adiw	r28, 0x08	; 8
    2e98:	0f b6       	in	r0, 0x3f	; 63
    2e9a:	f8 94       	cli
    2e9c:	de bf       	out	0x3e, r29	; 62
    2e9e:	0f be       	out	0x3f, r0	; 63
    2ea0:	cd bf       	out	0x3d, r28	; 61
    2ea2:	cf 91       	pop	r28
    2ea4:	df 91       	pop	r29
    2ea6:	08 95       	ret

00002ea8 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    2ea8:	df 93       	push	r29
    2eaa:	cf 93       	push	r28
    2eac:	00 d0       	rcall	.+0      	; 0x2eae <uxQueueMessagesWaiting+0x6>
    2eae:	0f 92       	push	r0
    2eb0:	cd b7       	in	r28, 0x3d	; 61
    2eb2:	de b7       	in	r29, 0x3e	; 62
    2eb4:	9b 83       	std	Y+3, r25	; 0x03
    2eb6:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2eb8:	0f b6       	in	r0, 0x3f	; 63
    2eba:	f8 94       	cli
    2ebc:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2ebe:	ea 81       	ldd	r30, Y+2	; 0x02
    2ec0:	fb 81       	ldd	r31, Y+3	; 0x03
    2ec2:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ec4:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2ec6:	0f 90       	pop	r0
    2ec8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2eca:	89 81       	ldd	r24, Y+1	; 0x01
}
    2ecc:	0f 90       	pop	r0
    2ece:	0f 90       	pop	r0
    2ed0:	0f 90       	pop	r0
    2ed2:	cf 91       	pop	r28
    2ed4:	df 91       	pop	r29
    2ed6:	08 95       	ret

00002ed8 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    2ed8:	df 93       	push	r29
    2eda:	cf 93       	push	r28
    2edc:	00 d0       	rcall	.+0      	; 0x2ede <uxQueueMessagesWaitingFromISR+0x6>
    2ede:	0f 92       	push	r0
    2ee0:	cd b7       	in	r28, 0x3d	; 61
    2ee2:	de b7       	in	r29, 0x3e	; 62
    2ee4:	9b 83       	std	Y+3, r25	; 0x03
    2ee6:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    2ee8:	ea 81       	ldd	r30, Y+2	; 0x02
    2eea:	fb 81       	ldd	r31, Y+3	; 0x03
    2eec:	82 8d       	ldd	r24, Z+26	; 0x1a
    2eee:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    2ef0:	89 81       	ldd	r24, Y+1	; 0x01
}
    2ef2:	0f 90       	pop	r0
    2ef4:	0f 90       	pop	r0
    2ef6:	0f 90       	pop	r0
    2ef8:	cf 91       	pop	r28
    2efa:	df 91       	pop	r29
    2efc:	08 95       	ret

00002efe <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    2efe:	df 93       	push	r29
    2f00:	cf 93       	push	r28
    2f02:	00 d0       	rcall	.+0      	; 0x2f04 <vQueueDelete+0x6>
    2f04:	cd b7       	in	r28, 0x3d	; 61
    2f06:	de b7       	in	r29, 0x3e	; 62
    2f08:	9a 83       	std	Y+2, r25	; 0x02
    2f0a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    2f0c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f0e:	fa 81       	ldd	r31, Y+2	; 0x02
    2f10:	80 81       	ld	r24, Z
    2f12:	91 81       	ldd	r25, Z+1	; 0x01
    2f14:	0e 94 7e 10 	call	0x20fc	; 0x20fc <vPortFree>
	vPortFree( pxQueue );
    2f18:	89 81       	ldd	r24, Y+1	; 0x01
    2f1a:	9a 81       	ldd	r25, Y+2	; 0x02
    2f1c:	0e 94 7e 10 	call	0x20fc	; 0x20fc <vPortFree>
}
    2f20:	0f 90       	pop	r0
    2f22:	0f 90       	pop	r0
    2f24:	cf 91       	pop	r28
    2f26:	df 91       	pop	r29
    2f28:	08 95       	ret

00002f2a <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    2f2a:	df 93       	push	r29
    2f2c:	cf 93       	push	r28
    2f2e:	00 d0       	rcall	.+0      	; 0x2f30 <prvCopyDataToQueue+0x6>
    2f30:	00 d0       	rcall	.+0      	; 0x2f32 <prvCopyDataToQueue+0x8>
    2f32:	0f 92       	push	r0
    2f34:	cd b7       	in	r28, 0x3d	; 61
    2f36:	de b7       	in	r29, 0x3e	; 62
    2f38:	9a 83       	std	Y+2, r25	; 0x02
    2f3a:	89 83       	std	Y+1, r24	; 0x01
    2f3c:	7c 83       	std	Y+4, r23	; 0x04
    2f3e:	6b 83       	std	Y+3, r22	; 0x03
    2f40:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    2f42:	e9 81       	ldd	r30, Y+1	; 0x01
    2f44:	fa 81       	ldd	r31, Y+2	; 0x02
    2f46:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f48:	88 23       	and	r24, r24
    2f4a:	09 f4       	brne	.+2      	; 0x2f4e <prvCopyDataToQueue+0x24>
    2f4c:	74 c0       	rjmp	.+232    	; 0x3036 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    2f4e:	8d 81       	ldd	r24, Y+5	; 0x05
    2f50:	88 23       	and	r24, r24
    2f52:	99 f5       	brne	.+102    	; 0x2fba <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2f54:	e9 81       	ldd	r30, Y+1	; 0x01
    2f56:	fa 81       	ldd	r31, Y+2	; 0x02
    2f58:	64 81       	ldd	r22, Z+4	; 0x04
    2f5a:	75 81       	ldd	r23, Z+5	; 0x05
    2f5c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f5e:	fa 81       	ldd	r31, Y+2	; 0x02
    2f60:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f62:	48 2f       	mov	r20, r24
    2f64:	50 e0       	ldi	r21, 0x00	; 0
    2f66:	2b 81       	ldd	r18, Y+3	; 0x03
    2f68:	3c 81       	ldd	r19, Y+4	; 0x04
    2f6a:	cb 01       	movw	r24, r22
    2f6c:	b9 01       	movw	r22, r18
    2f6e:	0e 94 95 20 	call	0x412a	; 0x412a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2f72:	e9 81       	ldd	r30, Y+1	; 0x01
    2f74:	fa 81       	ldd	r31, Y+2	; 0x02
    2f76:	24 81       	ldd	r18, Z+4	; 0x04
    2f78:	35 81       	ldd	r19, Z+5	; 0x05
    2f7a:	e9 81       	ldd	r30, Y+1	; 0x01
    2f7c:	fa 81       	ldd	r31, Y+2	; 0x02
    2f7e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f80:	88 2f       	mov	r24, r24
    2f82:	90 e0       	ldi	r25, 0x00	; 0
    2f84:	82 0f       	add	r24, r18
    2f86:	93 1f       	adc	r25, r19
    2f88:	e9 81       	ldd	r30, Y+1	; 0x01
    2f8a:	fa 81       	ldd	r31, Y+2	; 0x02
    2f8c:	95 83       	std	Z+5, r25	; 0x05
    2f8e:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    2f90:	e9 81       	ldd	r30, Y+1	; 0x01
    2f92:	fa 81       	ldd	r31, Y+2	; 0x02
    2f94:	24 81       	ldd	r18, Z+4	; 0x04
    2f96:	35 81       	ldd	r19, Z+5	; 0x05
    2f98:	e9 81       	ldd	r30, Y+1	; 0x01
    2f9a:	fa 81       	ldd	r31, Y+2	; 0x02
    2f9c:	82 81       	ldd	r24, Z+2	; 0x02
    2f9e:	93 81       	ldd	r25, Z+3	; 0x03
    2fa0:	28 17       	cp	r18, r24
    2fa2:	39 07       	cpc	r19, r25
    2fa4:	08 f4       	brcc	.+2      	; 0x2fa8 <prvCopyDataToQueue+0x7e>
    2fa6:	47 c0       	rjmp	.+142    	; 0x3036 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2fa8:	e9 81       	ldd	r30, Y+1	; 0x01
    2faa:	fa 81       	ldd	r31, Y+2	; 0x02
    2fac:	80 81       	ld	r24, Z
    2fae:	91 81       	ldd	r25, Z+1	; 0x01
    2fb0:	e9 81       	ldd	r30, Y+1	; 0x01
    2fb2:	fa 81       	ldd	r31, Y+2	; 0x02
    2fb4:	95 83       	std	Z+5, r25	; 0x05
    2fb6:	84 83       	std	Z+4, r24	; 0x04
    2fb8:	3e c0       	rjmp	.+124    	; 0x3036 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2fba:	e9 81       	ldd	r30, Y+1	; 0x01
    2fbc:	fa 81       	ldd	r31, Y+2	; 0x02
    2fbe:	66 81       	ldd	r22, Z+6	; 0x06
    2fc0:	77 81       	ldd	r23, Z+7	; 0x07
    2fc2:	e9 81       	ldd	r30, Y+1	; 0x01
    2fc4:	fa 81       	ldd	r31, Y+2	; 0x02
    2fc6:	84 8d       	ldd	r24, Z+28	; 0x1c
    2fc8:	48 2f       	mov	r20, r24
    2fca:	50 e0       	ldi	r21, 0x00	; 0
    2fcc:	2b 81       	ldd	r18, Y+3	; 0x03
    2fce:	3c 81       	ldd	r19, Y+4	; 0x04
    2fd0:	cb 01       	movw	r24, r22
    2fd2:	b9 01       	movw	r22, r18
    2fd4:	0e 94 95 20 	call	0x412a	; 0x412a <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    2fd8:	e9 81       	ldd	r30, Y+1	; 0x01
    2fda:	fa 81       	ldd	r31, Y+2	; 0x02
    2fdc:	26 81       	ldd	r18, Z+6	; 0x06
    2fde:	37 81       	ldd	r19, Z+7	; 0x07
    2fe0:	e9 81       	ldd	r30, Y+1	; 0x01
    2fe2:	fa 81       	ldd	r31, Y+2	; 0x02
    2fe4:	84 8d       	ldd	r24, Z+28	; 0x1c
    2fe6:	88 2f       	mov	r24, r24
    2fe8:	90 e0       	ldi	r25, 0x00	; 0
    2fea:	90 95       	com	r25
    2fec:	81 95       	neg	r24
    2fee:	9f 4f       	sbci	r25, 0xFF	; 255
    2ff0:	82 0f       	add	r24, r18
    2ff2:	93 1f       	adc	r25, r19
    2ff4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ff6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ff8:	97 83       	std	Z+7, r25	; 0x07
    2ffa:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    2ffc:	e9 81       	ldd	r30, Y+1	; 0x01
    2ffe:	fa 81       	ldd	r31, Y+2	; 0x02
    3000:	26 81       	ldd	r18, Z+6	; 0x06
    3002:	37 81       	ldd	r19, Z+7	; 0x07
    3004:	e9 81       	ldd	r30, Y+1	; 0x01
    3006:	fa 81       	ldd	r31, Y+2	; 0x02
    3008:	80 81       	ld	r24, Z
    300a:	91 81       	ldd	r25, Z+1	; 0x01
    300c:	28 17       	cp	r18, r24
    300e:	39 07       	cpc	r19, r25
    3010:	90 f4       	brcc	.+36     	; 0x3036 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    3012:	e9 81       	ldd	r30, Y+1	; 0x01
    3014:	fa 81       	ldd	r31, Y+2	; 0x02
    3016:	22 81       	ldd	r18, Z+2	; 0x02
    3018:	33 81       	ldd	r19, Z+3	; 0x03
    301a:	e9 81       	ldd	r30, Y+1	; 0x01
    301c:	fa 81       	ldd	r31, Y+2	; 0x02
    301e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3020:	88 2f       	mov	r24, r24
    3022:	90 e0       	ldi	r25, 0x00	; 0
    3024:	90 95       	com	r25
    3026:	81 95       	neg	r24
    3028:	9f 4f       	sbci	r25, 0xFF	; 255
    302a:	82 0f       	add	r24, r18
    302c:	93 1f       	adc	r25, r19
    302e:	e9 81       	ldd	r30, Y+1	; 0x01
    3030:	fa 81       	ldd	r31, Y+2	; 0x02
    3032:	97 83       	std	Z+7, r25	; 0x07
    3034:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    3036:	e9 81       	ldd	r30, Y+1	; 0x01
    3038:	fa 81       	ldd	r31, Y+2	; 0x02
    303a:	82 8d       	ldd	r24, Z+26	; 0x1a
    303c:	8f 5f       	subi	r24, 0xFF	; 255
    303e:	e9 81       	ldd	r30, Y+1	; 0x01
    3040:	fa 81       	ldd	r31, Y+2	; 0x02
    3042:	82 8f       	std	Z+26, r24	; 0x1a
}
    3044:	0f 90       	pop	r0
    3046:	0f 90       	pop	r0
    3048:	0f 90       	pop	r0
    304a:	0f 90       	pop	r0
    304c:	0f 90       	pop	r0
    304e:	cf 91       	pop	r28
    3050:	df 91       	pop	r29
    3052:	08 95       	ret

00003054 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    3054:	df 93       	push	r29
    3056:	cf 93       	push	r28
    3058:	00 d0       	rcall	.+0      	; 0x305a <prvCopyDataFromQueue+0x6>
    305a:	00 d0       	rcall	.+0      	; 0x305c <prvCopyDataFromQueue+0x8>
    305c:	cd b7       	in	r28, 0x3d	; 61
    305e:	de b7       	in	r29, 0x3e	; 62
    3060:	9a 83       	std	Y+2, r25	; 0x02
    3062:	89 83       	std	Y+1, r24	; 0x01
    3064:	7c 83       	std	Y+4, r23	; 0x04
    3066:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    3068:	e9 81       	ldd	r30, Y+1	; 0x01
    306a:	fa 81       	ldd	r31, Y+2	; 0x02
    306c:	80 81       	ld	r24, Z
    306e:	91 81       	ldd	r25, Z+1	; 0x01
    3070:	00 97       	sbiw	r24, 0x00	; 0
    3072:	89 f1       	breq	.+98     	; 0x30d6 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    3074:	e9 81       	ldd	r30, Y+1	; 0x01
    3076:	fa 81       	ldd	r31, Y+2	; 0x02
    3078:	26 81       	ldd	r18, Z+6	; 0x06
    307a:	37 81       	ldd	r19, Z+7	; 0x07
    307c:	e9 81       	ldd	r30, Y+1	; 0x01
    307e:	fa 81       	ldd	r31, Y+2	; 0x02
    3080:	84 8d       	ldd	r24, Z+28	; 0x1c
    3082:	88 2f       	mov	r24, r24
    3084:	90 e0       	ldi	r25, 0x00	; 0
    3086:	82 0f       	add	r24, r18
    3088:	93 1f       	adc	r25, r19
    308a:	e9 81       	ldd	r30, Y+1	; 0x01
    308c:	fa 81       	ldd	r31, Y+2	; 0x02
    308e:	97 83       	std	Z+7, r25	; 0x07
    3090:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    3092:	e9 81       	ldd	r30, Y+1	; 0x01
    3094:	fa 81       	ldd	r31, Y+2	; 0x02
    3096:	26 81       	ldd	r18, Z+6	; 0x06
    3098:	37 81       	ldd	r19, Z+7	; 0x07
    309a:	e9 81       	ldd	r30, Y+1	; 0x01
    309c:	fa 81       	ldd	r31, Y+2	; 0x02
    309e:	82 81       	ldd	r24, Z+2	; 0x02
    30a0:	93 81       	ldd	r25, Z+3	; 0x03
    30a2:	28 17       	cp	r18, r24
    30a4:	39 07       	cpc	r19, r25
    30a6:	40 f0       	brcs	.+16     	; 0x30b8 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    30a8:	e9 81       	ldd	r30, Y+1	; 0x01
    30aa:	fa 81       	ldd	r31, Y+2	; 0x02
    30ac:	80 81       	ld	r24, Z
    30ae:	91 81       	ldd	r25, Z+1	; 0x01
    30b0:	e9 81       	ldd	r30, Y+1	; 0x01
    30b2:	fa 81       	ldd	r31, Y+2	; 0x02
    30b4:	97 83       	std	Z+7, r25	; 0x07
    30b6:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    30b8:	e9 81       	ldd	r30, Y+1	; 0x01
    30ba:	fa 81       	ldd	r31, Y+2	; 0x02
    30bc:	46 81       	ldd	r20, Z+6	; 0x06
    30be:	57 81       	ldd	r21, Z+7	; 0x07
    30c0:	e9 81       	ldd	r30, Y+1	; 0x01
    30c2:	fa 81       	ldd	r31, Y+2	; 0x02
    30c4:	84 8d       	ldd	r24, Z+28	; 0x1c
    30c6:	28 2f       	mov	r18, r24
    30c8:	30 e0       	ldi	r19, 0x00	; 0
    30ca:	8b 81       	ldd	r24, Y+3	; 0x03
    30cc:	9c 81       	ldd	r25, Y+4	; 0x04
    30ce:	ba 01       	movw	r22, r20
    30d0:	a9 01       	movw	r20, r18
    30d2:	0e 94 95 20 	call	0x412a	; 0x412a <memcpy>
	}
}
    30d6:	0f 90       	pop	r0
    30d8:	0f 90       	pop	r0
    30da:	0f 90       	pop	r0
    30dc:	0f 90       	pop	r0
    30de:	cf 91       	pop	r28
    30e0:	df 91       	pop	r29
    30e2:	08 95       	ret

000030e4 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    30e4:	df 93       	push	r29
    30e6:	cf 93       	push	r28
    30e8:	00 d0       	rcall	.+0      	; 0x30ea <prvUnlockQueue+0x6>
    30ea:	cd b7       	in	r28, 0x3d	; 61
    30ec:	de b7       	in	r29, 0x3e	; 62
    30ee:	9a 83       	std	Y+2, r25	; 0x02
    30f0:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    30f2:	0f b6       	in	r0, 0x3f	; 63
    30f4:	f8 94       	cli
    30f6:	0f 92       	push	r0
    30f8:	15 c0       	rjmp	.+42     	; 0x3124 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    30fa:	e9 81       	ldd	r30, Y+1	; 0x01
    30fc:	fa 81       	ldd	r31, Y+2	; 0x02
    30fe:	81 89       	ldd	r24, Z+17	; 0x11
    3100:	88 23       	and	r24, r24
    3102:	a9 f0       	breq	.+42     	; 0x312e <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3104:	89 81       	ldd	r24, Y+1	; 0x01
    3106:	9a 81       	ldd	r25, Y+2	; 0x02
    3108:	41 96       	adiw	r24, 0x11	; 17
    310a:	0e 94 aa 1d 	call	0x3b54	; 0x3b54 <xTaskRemoveFromEventList>
    310e:	88 23       	and	r24, r24
    3110:	11 f0       	breq	.+4      	; 0x3116 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    3112:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    3116:	e9 81       	ldd	r30, Y+1	; 0x01
    3118:	fa 81       	ldd	r31, Y+2	; 0x02
    311a:	86 8d       	ldd	r24, Z+30	; 0x1e
    311c:	81 50       	subi	r24, 0x01	; 1
    311e:	e9 81       	ldd	r30, Y+1	; 0x01
    3120:	fa 81       	ldd	r31, Y+2	; 0x02
    3122:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3124:	e9 81       	ldd	r30, Y+1	; 0x01
    3126:	fa 81       	ldd	r31, Y+2	; 0x02
    3128:	86 8d       	ldd	r24, Z+30	; 0x1e
    312a:	18 16       	cp	r1, r24
    312c:	34 f3       	brlt	.-52     	; 0x30fa <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    312e:	e9 81       	ldd	r30, Y+1	; 0x01
    3130:	fa 81       	ldd	r31, Y+2	; 0x02
    3132:	8f ef       	ldi	r24, 0xFF	; 255
    3134:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    3136:	0f 90       	pop	r0
    3138:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    313a:	0f b6       	in	r0, 0x3f	; 63
    313c:	f8 94       	cli
    313e:	0f 92       	push	r0
    3140:	15 c0       	rjmp	.+42     	; 0x316c <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3142:	e9 81       	ldd	r30, Y+1	; 0x01
    3144:	fa 81       	ldd	r31, Y+2	; 0x02
    3146:	80 85       	ldd	r24, Z+8	; 0x08
    3148:	88 23       	and	r24, r24
    314a:	a9 f0       	breq	.+42     	; 0x3176 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    314c:	89 81       	ldd	r24, Y+1	; 0x01
    314e:	9a 81       	ldd	r25, Y+2	; 0x02
    3150:	08 96       	adiw	r24, 0x08	; 8
    3152:	0e 94 aa 1d 	call	0x3b54	; 0x3b54 <xTaskRemoveFromEventList>
    3156:	88 23       	and	r24, r24
    3158:	11 f0       	breq	.+4      	; 0x315e <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    315a:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    315e:	e9 81       	ldd	r30, Y+1	; 0x01
    3160:	fa 81       	ldd	r31, Y+2	; 0x02
    3162:	85 8d       	ldd	r24, Z+29	; 0x1d
    3164:	81 50       	subi	r24, 0x01	; 1
    3166:	e9 81       	ldd	r30, Y+1	; 0x01
    3168:	fa 81       	ldd	r31, Y+2	; 0x02
    316a:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    316c:	e9 81       	ldd	r30, Y+1	; 0x01
    316e:	fa 81       	ldd	r31, Y+2	; 0x02
    3170:	85 8d       	ldd	r24, Z+29	; 0x1d
    3172:	18 16       	cp	r1, r24
    3174:	34 f3       	brlt	.-52     	; 0x3142 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    3176:	e9 81       	ldd	r30, Y+1	; 0x01
    3178:	fa 81       	ldd	r31, Y+2	; 0x02
    317a:	8f ef       	ldi	r24, 0xFF	; 255
    317c:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    317e:	0f 90       	pop	r0
    3180:	0f be       	out	0x3f, r0	; 63
}
    3182:	0f 90       	pop	r0
    3184:	0f 90       	pop	r0
    3186:	cf 91       	pop	r28
    3188:	df 91       	pop	r29
    318a:	08 95       	ret

0000318c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    318c:	df 93       	push	r29
    318e:	cf 93       	push	r28
    3190:	00 d0       	rcall	.+0      	; 0x3192 <prvIsQueueEmpty+0x6>
    3192:	0f 92       	push	r0
    3194:	cd b7       	in	r28, 0x3d	; 61
    3196:	de b7       	in	r29, 0x3e	; 62
    3198:	9b 83       	std	Y+3, r25	; 0x03
    319a:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    319c:	0f b6       	in	r0, 0x3f	; 63
    319e:	f8 94       	cli
    31a0:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    31a2:	ea 81       	ldd	r30, Y+2	; 0x02
    31a4:	fb 81       	ldd	r31, Y+3	; 0x03
    31a6:	82 8d       	ldd	r24, Z+26	; 0x1a
    31a8:	19 82       	std	Y+1, r1	; 0x01
    31aa:	88 23       	and	r24, r24
    31ac:	11 f4       	brne	.+4      	; 0x31b2 <prvIsQueueEmpty+0x26>
    31ae:	81 e0       	ldi	r24, 0x01	; 1
    31b0:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    31b2:	0f 90       	pop	r0
    31b4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    31b6:	89 81       	ldd	r24, Y+1	; 0x01
}
    31b8:	0f 90       	pop	r0
    31ba:	0f 90       	pop	r0
    31bc:	0f 90       	pop	r0
    31be:	cf 91       	pop	r28
    31c0:	df 91       	pop	r29
    31c2:	08 95       	ret

000031c4 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    31c4:	df 93       	push	r29
    31c6:	cf 93       	push	r28
    31c8:	00 d0       	rcall	.+0      	; 0x31ca <xQueueIsQueueEmptyFromISR+0x6>
    31ca:	0f 92       	push	r0
    31cc:	cd b7       	in	r28, 0x3d	; 61
    31ce:	de b7       	in	r29, 0x3e	; 62
    31d0:	9b 83       	std	Y+3, r25	; 0x03
    31d2:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    31d4:	ea 81       	ldd	r30, Y+2	; 0x02
    31d6:	fb 81       	ldd	r31, Y+3	; 0x03
    31d8:	82 8d       	ldd	r24, Z+26	; 0x1a
    31da:	19 82       	std	Y+1, r1	; 0x01
    31dc:	88 23       	and	r24, r24
    31de:	11 f4       	brne	.+4      	; 0x31e4 <xQueueIsQueueEmptyFromISR+0x20>
    31e0:	81 e0       	ldi	r24, 0x01	; 1
    31e2:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    31e4:	89 81       	ldd	r24, Y+1	; 0x01
}
    31e6:	0f 90       	pop	r0
    31e8:	0f 90       	pop	r0
    31ea:	0f 90       	pop	r0
    31ec:	cf 91       	pop	r28
    31ee:	df 91       	pop	r29
    31f0:	08 95       	ret

000031f2 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    31f2:	df 93       	push	r29
    31f4:	cf 93       	push	r28
    31f6:	00 d0       	rcall	.+0      	; 0x31f8 <prvIsQueueFull+0x6>
    31f8:	0f 92       	push	r0
    31fa:	cd b7       	in	r28, 0x3d	; 61
    31fc:	de b7       	in	r29, 0x3e	; 62
    31fe:	9b 83       	std	Y+3, r25	; 0x03
    3200:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    3202:	0f b6       	in	r0, 0x3f	; 63
    3204:	f8 94       	cli
    3206:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    3208:	ea 81       	ldd	r30, Y+2	; 0x02
    320a:	fb 81       	ldd	r31, Y+3	; 0x03
    320c:	92 8d       	ldd	r25, Z+26	; 0x1a
    320e:	ea 81       	ldd	r30, Y+2	; 0x02
    3210:	fb 81       	ldd	r31, Y+3	; 0x03
    3212:	83 8d       	ldd	r24, Z+27	; 0x1b
    3214:	19 82       	std	Y+1, r1	; 0x01
    3216:	98 17       	cp	r25, r24
    3218:	11 f4       	brne	.+4      	; 0x321e <prvIsQueueFull+0x2c>
    321a:	81 e0       	ldi	r24, 0x01	; 1
    321c:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    321e:	0f 90       	pop	r0
    3220:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3222:	89 81       	ldd	r24, Y+1	; 0x01
}
    3224:	0f 90       	pop	r0
    3226:	0f 90       	pop	r0
    3228:	0f 90       	pop	r0
    322a:	cf 91       	pop	r28
    322c:	df 91       	pop	r29
    322e:	08 95       	ret

00003230 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    3230:	df 93       	push	r29
    3232:	cf 93       	push	r28
    3234:	00 d0       	rcall	.+0      	; 0x3236 <xQueueIsQueueFullFromISR+0x6>
    3236:	0f 92       	push	r0
    3238:	cd b7       	in	r28, 0x3d	; 61
    323a:	de b7       	in	r29, 0x3e	; 62
    323c:	9b 83       	std	Y+3, r25	; 0x03
    323e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    3240:	ea 81       	ldd	r30, Y+2	; 0x02
    3242:	fb 81       	ldd	r31, Y+3	; 0x03
    3244:	92 8d       	ldd	r25, Z+26	; 0x1a
    3246:	ea 81       	ldd	r30, Y+2	; 0x02
    3248:	fb 81       	ldd	r31, Y+3	; 0x03
    324a:	83 8d       	ldd	r24, Z+27	; 0x1b
    324c:	19 82       	std	Y+1, r1	; 0x01
    324e:	98 17       	cp	r25, r24
    3250:	11 f4       	brne	.+4      	; 0x3256 <xQueueIsQueueFullFromISR+0x26>
    3252:	81 e0       	ldi	r24, 0x01	; 1
    3254:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    3256:	89 81       	ldd	r24, Y+1	; 0x01
}
    3258:	0f 90       	pop	r0
    325a:	0f 90       	pop	r0
    325c:	0f 90       	pop	r0
    325e:	cf 91       	pop	r28
    3260:	df 91       	pop	r29
    3262:	08 95       	ret

00003264 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    3264:	af 92       	push	r10
    3266:	bf 92       	push	r11
    3268:	cf 92       	push	r12
    326a:	df 92       	push	r13
    326c:	ef 92       	push	r14
    326e:	ff 92       	push	r15
    3270:	0f 93       	push	r16
    3272:	1f 93       	push	r17
    3274:	df 93       	push	r29
    3276:	cf 93       	push	r28
    3278:	cd b7       	in	r28, 0x3d	; 61
    327a:	de b7       	in	r29, 0x3e	; 62
    327c:	64 97       	sbiw	r28, 0x14	; 20
    327e:	0f b6       	in	r0, 0x3f	; 63
    3280:	f8 94       	cli
    3282:	de bf       	out	0x3e, r29	; 62
    3284:	0f be       	out	0x3f, r0	; 63
    3286:	cd bf       	out	0x3d, r28	; 61
    3288:	9f 83       	std	Y+7, r25	; 0x07
    328a:	8e 83       	std	Y+6, r24	; 0x06
    328c:	79 87       	std	Y+9, r23	; 0x09
    328e:	68 87       	std	Y+8, r22	; 0x08
    3290:	5b 87       	std	Y+11, r21	; 0x0b
    3292:	4a 87       	std	Y+10, r20	; 0x0a
    3294:	3d 87       	std	Y+13, r19	; 0x0d
    3296:	2c 87       	std	Y+12, r18	; 0x0c
    3298:	0e 87       	std	Y+14, r16	; 0x0e
    329a:	f8 8a       	std	Y+16, r15	; 0x10
    329c:	ef 86       	std	Y+15, r14	; 0x0f
    329e:	da 8a       	std	Y+18, r13	; 0x12
    32a0:	c9 8a       	std	Y+17, r12	; 0x11
    32a2:	bc 8a       	std	Y+20, r11	; 0x14
    32a4:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    32a6:	8a 85       	ldd	r24, Y+10	; 0x0a
    32a8:	9b 85       	ldd	r25, Y+11	; 0x0b
    32aa:	29 89       	ldd	r18, Y+17	; 0x11
    32ac:	3a 89       	ldd	r19, Y+18	; 0x12
    32ae:	b9 01       	movw	r22, r18
    32b0:	0e 94 b7 1f 	call	0x3f6e	; 0x3f6e <prvAllocateTCBAndStack>
    32b4:	9c 83       	std	Y+4, r25	; 0x04
    32b6:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    32b8:	8b 81       	ldd	r24, Y+3	; 0x03
    32ba:	9c 81       	ldd	r25, Y+4	; 0x04
    32bc:	00 97       	sbiw	r24, 0x00	; 0
    32be:	09 f4       	brne	.+2      	; 0x32c2 <xTaskGenericCreate+0x5e>
    32c0:	99 c0       	rjmp	.+306    	; 0x33f4 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    32c2:	eb 81       	ldd	r30, Y+3	; 0x03
    32c4:	fc 81       	ldd	r31, Y+4	; 0x04
    32c6:	27 89       	ldd	r18, Z+23	; 0x17
    32c8:	30 8d       	ldd	r19, Z+24	; 0x18
    32ca:	8a 85       	ldd	r24, Y+10	; 0x0a
    32cc:	9b 85       	ldd	r25, Y+11	; 0x0b
    32ce:	01 97       	sbiw	r24, 0x01	; 1
    32d0:	82 0f       	add	r24, r18
    32d2:	93 1f       	adc	r25, r19
    32d4:	9a 83       	std	Y+2, r25	; 0x02
    32d6:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    32d8:	8b 81       	ldd	r24, Y+3	; 0x03
    32da:	9c 81       	ldd	r25, Y+4	; 0x04
    32dc:	28 85       	ldd	r18, Y+8	; 0x08
    32de:	39 85       	ldd	r19, Y+9	; 0x09
    32e0:	eb 89       	ldd	r30, Y+19	; 0x13
    32e2:	fc 89       	ldd	r31, Y+20	; 0x14
    32e4:	aa 85       	ldd	r26, Y+10	; 0x0a
    32e6:	bb 85       	ldd	r27, Y+11	; 0x0b
    32e8:	b9 01       	movw	r22, r18
    32ea:	4e 85       	ldd	r20, Y+14	; 0x0e
    32ec:	9f 01       	movw	r18, r30
    32ee:	8d 01       	movw	r16, r26
    32f0:	0e 94 9c 1e 	call	0x3d38	; 0x3d38 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    32f4:	89 81       	ldd	r24, Y+1	; 0x01
    32f6:	9a 81       	ldd	r25, Y+2	; 0x02
    32f8:	2e 81       	ldd	r18, Y+6	; 0x06
    32fa:	3f 81       	ldd	r19, Y+7	; 0x07
    32fc:	4c 85       	ldd	r20, Y+12	; 0x0c
    32fe:	5d 85       	ldd	r21, Y+13	; 0x0d
    3300:	b9 01       	movw	r22, r18
    3302:	0e 94 df 11 	call	0x23be	; 0x23be <pxPortInitialiseStack>
    3306:	eb 81       	ldd	r30, Y+3	; 0x03
    3308:	fc 81       	ldd	r31, Y+4	; 0x04
    330a:	91 83       	std	Z+1, r25	; 0x01
    330c:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    330e:	8f 85       	ldd	r24, Y+15	; 0x0f
    3310:	98 89       	ldd	r25, Y+16	; 0x10
    3312:	00 97       	sbiw	r24, 0x00	; 0
    3314:	31 f0       	breq	.+12     	; 0x3322 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    3316:	ef 85       	ldd	r30, Y+15	; 0x0f
    3318:	f8 89       	ldd	r31, Y+16	; 0x10
    331a:	8b 81       	ldd	r24, Y+3	; 0x03
    331c:	9c 81       	ldd	r25, Y+4	; 0x04
    331e:	91 83       	std	Z+1, r25	; 0x01
    3320:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    3322:	0f b6       	in	r0, 0x3f	; 63
    3324:	f8 94       	cli
    3326:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    3328:	80 91 07 03 	lds	r24, 0x0307
    332c:	8f 5f       	subi	r24, 0xFF	; 255
    332e:	80 93 07 03 	sts	0x0307, r24
			if( pxCurrentTCB == NULL )
    3332:	80 91 04 03 	lds	r24, 0x0304
    3336:	90 91 05 03 	lds	r25, 0x0305
    333a:	00 97       	sbiw	r24, 0x00	; 0
    333c:	69 f4       	brne	.+26     	; 0x3358 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    333e:	8b 81       	ldd	r24, Y+3	; 0x03
    3340:	9c 81       	ldd	r25, Y+4	; 0x04
    3342:	90 93 05 03 	sts	0x0305, r25
    3346:	80 93 04 03 	sts	0x0304, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    334a:	80 91 07 03 	lds	r24, 0x0307
    334e:	81 30       	cpi	r24, 0x01	; 1
    3350:	a9 f4       	brne	.+42     	; 0x337c <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    3352:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <prvInitialiseTaskLists>
    3356:	12 c0       	rjmp	.+36     	; 0x337c <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    3358:	80 91 0c 03 	lds	r24, 0x030C
    335c:	88 23       	and	r24, r24
    335e:	71 f4       	brne	.+28     	; 0x337c <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    3360:	e0 91 04 03 	lds	r30, 0x0304
    3364:	f0 91 05 03 	lds	r31, 0x0305
    3368:	96 89       	ldd	r25, Z+22	; 0x16
    336a:	8e 85       	ldd	r24, Y+14	; 0x0e
    336c:	89 17       	cp	r24, r25
    336e:	30 f0       	brcs	.+12     	; 0x337c <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    3370:	8b 81       	ldd	r24, Y+3	; 0x03
    3372:	9c 81       	ldd	r25, Y+4	; 0x04
    3374:	90 93 05 03 	sts	0x0305, r25
    3378:	80 93 04 03 	sts	0x0304, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    337c:	eb 81       	ldd	r30, Y+3	; 0x03
    337e:	fc 81       	ldd	r31, Y+4	; 0x04
    3380:	96 89       	ldd	r25, Z+22	; 0x16
    3382:	80 91 0a 03 	lds	r24, 0x030A
    3386:	89 17       	cp	r24, r25
    3388:	28 f4       	brcc	.+10     	; 0x3394 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    338a:	eb 81       	ldd	r30, Y+3	; 0x03
    338c:	fc 81       	ldd	r31, Y+4	; 0x04
    338e:	86 89       	ldd	r24, Z+22	; 0x16
    3390:	80 93 0a 03 	sts	0x030A, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    3394:	80 91 11 03 	lds	r24, 0x0311
    3398:	8f 5f       	subi	r24, 0xFF	; 255
    339a:	80 93 11 03 	sts	0x0311, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    339e:	eb 81       	ldd	r30, Y+3	; 0x03
    33a0:	fc 81       	ldd	r31, Y+4	; 0x04
    33a2:	96 89       	ldd	r25, Z+22	; 0x16
    33a4:	80 91 0b 03 	lds	r24, 0x030B
    33a8:	89 17       	cp	r24, r25
    33aa:	28 f4       	brcc	.+10     	; 0x33b6 <xTaskGenericCreate+0x152>
    33ac:	eb 81       	ldd	r30, Y+3	; 0x03
    33ae:	fc 81       	ldd	r31, Y+4	; 0x04
    33b0:	86 89       	ldd	r24, Z+22	; 0x16
    33b2:	80 93 0b 03 	sts	0x030B, r24
    33b6:	eb 81       	ldd	r30, Y+3	; 0x03
    33b8:	fc 81       	ldd	r31, Y+4	; 0x04
    33ba:	86 89       	ldd	r24, Z+22	; 0x16
    33bc:	28 2f       	mov	r18, r24
    33be:	30 e0       	ldi	r19, 0x00	; 0
    33c0:	c9 01       	movw	r24, r18
    33c2:	88 0f       	add	r24, r24
    33c4:	99 1f       	adc	r25, r25
    33c6:	88 0f       	add	r24, r24
    33c8:	99 1f       	adc	r25, r25
    33ca:	88 0f       	add	r24, r24
    33cc:	99 1f       	adc	r25, r25
    33ce:	82 0f       	add	r24, r18
    33d0:	93 1f       	adc	r25, r19
    33d2:	ac 01       	movw	r20, r24
    33d4:	4e 5e       	subi	r20, 0xEE	; 238
    33d6:	5c 4f       	sbci	r21, 0xFC	; 252
    33d8:	8b 81       	ldd	r24, Y+3	; 0x03
    33da:	9c 81       	ldd	r25, Y+4	; 0x04
    33dc:	9c 01       	movw	r18, r24
    33de:	2e 5f       	subi	r18, 0xFE	; 254
    33e0:	3f 4f       	sbci	r19, 0xFF	; 255
    33e2:	ca 01       	movw	r24, r20
    33e4:	b9 01       	movw	r22, r18
    33e6:	0e 94 de 10 	call	0x21bc	; 0x21bc <vListInsertEnd>

			xReturn = pdPASS;
    33ea:	81 e0       	ldi	r24, 0x01	; 1
    33ec:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    33ee:	0f 90       	pop	r0
    33f0:	0f be       	out	0x3f, r0	; 63
    33f2:	02 c0       	rjmp	.+4      	; 0x33f8 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    33f4:	8f ef       	ldi	r24, 0xFF	; 255
    33f6:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    33f8:	8d 81       	ldd	r24, Y+5	; 0x05
    33fa:	81 30       	cpi	r24, 0x01	; 1
    33fc:	71 f4       	brne	.+28     	; 0x341a <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    33fe:	80 91 0c 03 	lds	r24, 0x030C
    3402:	88 23       	and	r24, r24
    3404:	51 f0       	breq	.+20     	; 0x341a <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    3406:	e0 91 04 03 	lds	r30, 0x0304
    340a:	f0 91 05 03 	lds	r31, 0x0305
    340e:	96 89       	ldd	r25, Z+22	; 0x16
    3410:	8e 85       	ldd	r24, Y+14	; 0x0e
    3412:	98 17       	cp	r25, r24
    3414:	10 f4       	brcc	.+4      	; 0x341a <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    3416:	0e 94 9e 13 	call	0x273c	; 0x273c <vPortYield>
			}
		}
	}

	return xReturn;
    341a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    341c:	64 96       	adiw	r28, 0x14	; 20
    341e:	0f b6       	in	r0, 0x3f	; 63
    3420:	f8 94       	cli
    3422:	de bf       	out	0x3e, r29	; 62
    3424:	0f be       	out	0x3f, r0	; 63
    3426:	cd bf       	out	0x3d, r28	; 61
    3428:	cf 91       	pop	r28
    342a:	df 91       	pop	r29
    342c:	1f 91       	pop	r17
    342e:	0f 91       	pop	r16
    3430:	ff 90       	pop	r15
    3432:	ef 90       	pop	r14
    3434:	df 90       	pop	r13
    3436:	cf 90       	pop	r12
    3438:	bf 90       	pop	r11
    343a:	af 90       	pop	r10
    343c:	08 95       	ret

0000343e <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    343e:	df 93       	push	r29
    3440:	cf 93       	push	r28
    3442:	00 d0       	rcall	.+0      	; 0x3444 <vTaskDelete+0x6>
    3444:	00 d0       	rcall	.+0      	; 0x3446 <vTaskDelete+0x8>
    3446:	00 d0       	rcall	.+0      	; 0x3448 <vTaskDelete+0xa>
    3448:	cd b7       	in	r28, 0x3d	; 61
    344a:	de b7       	in	r29, 0x3e	; 62
    344c:	9c 83       	std	Y+4, r25	; 0x04
    344e:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    3450:	0f b6       	in	r0, 0x3f	; 63
    3452:	f8 94       	cli
    3454:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    3456:	20 91 04 03 	lds	r18, 0x0304
    345a:	30 91 05 03 	lds	r19, 0x0305
    345e:	8b 81       	ldd	r24, Y+3	; 0x03
    3460:	9c 81       	ldd	r25, Y+4	; 0x04
    3462:	82 17       	cp	r24, r18
    3464:	93 07       	cpc	r25, r19
    3466:	11 f4       	brne	.+4      	; 0x346c <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    3468:	1c 82       	std	Y+4, r1	; 0x04
    346a:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    346c:	8b 81       	ldd	r24, Y+3	; 0x03
    346e:	9c 81       	ldd	r25, Y+4	; 0x04
    3470:	00 97       	sbiw	r24, 0x00	; 0
    3472:	39 f4       	brne	.+14     	; 0x3482 <vTaskDelete+0x44>
    3474:	80 91 04 03 	lds	r24, 0x0304
    3478:	90 91 05 03 	lds	r25, 0x0305
    347c:	9e 83       	std	Y+6, r25	; 0x06
    347e:	8d 83       	std	Y+5, r24	; 0x05
    3480:	04 c0       	rjmp	.+8      	; 0x348a <vTaskDelete+0x4c>
    3482:	8b 81       	ldd	r24, Y+3	; 0x03
    3484:	9c 81       	ldd	r25, Y+4	; 0x04
    3486:	9e 83       	std	Y+6, r25	; 0x06
    3488:	8d 83       	std	Y+5, r24	; 0x05
    348a:	8d 81       	ldd	r24, Y+5	; 0x05
    348c:	9e 81       	ldd	r25, Y+6	; 0x06
    348e:	9a 83       	std	Y+2, r25	; 0x02
    3490:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    3492:	89 81       	ldd	r24, Y+1	; 0x01
    3494:	9a 81       	ldd	r25, Y+2	; 0x02
    3496:	02 96       	adiw	r24, 0x02	; 2
    3498:	0e 94 96 11 	call	0x232c	; 0x232c <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    349c:	e9 81       	ldd	r30, Y+1	; 0x01
    349e:	fa 81       	ldd	r31, Y+2	; 0x02
    34a0:	84 89       	ldd	r24, Z+20	; 0x14
    34a2:	95 89       	ldd	r25, Z+21	; 0x15
    34a4:	00 97       	sbiw	r24, 0x00	; 0
    34a6:	29 f0       	breq	.+10     	; 0x34b2 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    34a8:	89 81       	ldd	r24, Y+1	; 0x01
    34aa:	9a 81       	ldd	r25, Y+2	; 0x02
    34ac:	0c 96       	adiw	r24, 0x0c	; 12
    34ae:	0e 94 96 11 	call	0x232c	; 0x232c <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    34b2:	89 81       	ldd	r24, Y+1	; 0x01
    34b4:	9a 81       	ldd	r25, Y+2	; 0x02
    34b6:	9c 01       	movw	r18, r24
    34b8:	2e 5f       	subi	r18, 0xFE	; 254
    34ba:	3f 4f       	sbci	r19, 0xFF	; 255
    34bc:	8c e4       	ldi	r24, 0x4C	; 76
    34be:	93 e0       	ldi	r25, 0x03	; 3
    34c0:	b9 01       	movw	r22, r18
    34c2:	0e 94 de 10 	call	0x21bc	; 0x21bc <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    34c6:	80 91 06 03 	lds	r24, 0x0306
    34ca:	8f 5f       	subi	r24, 0xFF	; 255
    34cc:	80 93 06 03 	sts	0x0306, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    34d0:	80 91 11 03 	lds	r24, 0x0311
    34d4:	8f 5f       	subi	r24, 0xFF	; 255
    34d6:	80 93 11 03 	sts	0x0311, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    34da:	0f 90       	pop	r0
    34dc:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    34de:	80 91 0c 03 	lds	r24, 0x030C
    34e2:	88 23       	and	r24, r24
    34e4:	31 f0       	breq	.+12     	; 0x34f2 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    34e6:	8b 81       	ldd	r24, Y+3	; 0x03
    34e8:	9c 81       	ldd	r25, Y+4	; 0x04
    34ea:	00 97       	sbiw	r24, 0x00	; 0
    34ec:	11 f4       	brne	.+4      	; 0x34f2 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    34ee:	0e 94 9e 13 	call	0x273c	; 0x273c <vPortYield>
			}
		}
	}
    34f2:	26 96       	adiw	r28, 0x06	; 6
    34f4:	0f b6       	in	r0, 0x3f	; 63
    34f6:	f8 94       	cli
    34f8:	de bf       	out	0x3e, r29	; 62
    34fa:	0f be       	out	0x3f, r0	; 63
    34fc:	cd bf       	out	0x3d, r28	; 61
    34fe:	cf 91       	pop	r28
    3500:	df 91       	pop	r29
    3502:	08 95       	ret

00003504 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    3504:	df 93       	push	r29
    3506:	cf 93       	push	r28
    3508:	cd b7       	in	r28, 0x3d	; 61
    350a:	de b7       	in	r29, 0x3e	; 62
    350c:	28 97       	sbiw	r28, 0x08	; 8
    350e:	0f b6       	in	r0, 0x3f	; 63
    3510:	f8 94       	cli
    3512:	de bf       	out	0x3e, r29	; 62
    3514:	0f be       	out	0x3f, r0	; 63
    3516:	cd bf       	out	0x3d, r28	; 61
    3518:	9e 83       	std	Y+6, r25	; 0x06
    351a:	8d 83       	std	Y+5, r24	; 0x05
    351c:	78 87       	std	Y+8, r23	; 0x08
    351e:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    3520:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    3522:	0e 94 6e 1b 	call	0x36dc	; 0x36dc <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3526:	ed 81       	ldd	r30, Y+5	; 0x05
    3528:	fe 81       	ldd	r31, Y+6	; 0x06
    352a:	20 81       	ld	r18, Z
    352c:	31 81       	ldd	r19, Z+1	; 0x01
    352e:	8f 81       	ldd	r24, Y+7	; 0x07
    3530:	98 85       	ldd	r25, Y+8	; 0x08
    3532:	82 0f       	add	r24, r18
    3534:	93 1f       	adc	r25, r19
    3536:	9c 83       	std	Y+4, r25	; 0x04
    3538:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    353a:	ed 81       	ldd	r30, Y+5	; 0x05
    353c:	fe 81       	ldd	r31, Y+6	; 0x06
    353e:	20 81       	ld	r18, Z
    3540:	31 81       	ldd	r19, Z+1	; 0x01
    3542:	80 91 08 03 	lds	r24, 0x0308
    3546:	90 91 09 03 	lds	r25, 0x0309
    354a:	82 17       	cp	r24, r18
    354c:	93 07       	cpc	r25, r19
    354e:	a8 f4       	brcc	.+42     	; 0x357a <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    3550:	ed 81       	ldd	r30, Y+5	; 0x05
    3552:	fe 81       	ldd	r31, Y+6	; 0x06
    3554:	20 81       	ld	r18, Z
    3556:	31 81       	ldd	r19, Z+1	; 0x01
    3558:	8b 81       	ldd	r24, Y+3	; 0x03
    355a:	9c 81       	ldd	r25, Y+4	; 0x04
    355c:	82 17       	cp	r24, r18
    355e:	93 07       	cpc	r25, r19
    3560:	00 f5       	brcc	.+64     	; 0x35a2 <vTaskDelayUntil+0x9e>
    3562:	20 91 08 03 	lds	r18, 0x0308
    3566:	30 91 09 03 	lds	r19, 0x0309
    356a:	8b 81       	ldd	r24, Y+3	; 0x03
    356c:	9c 81       	ldd	r25, Y+4	; 0x04
    356e:	28 17       	cp	r18, r24
    3570:	39 07       	cpc	r19, r25
    3572:	b8 f4       	brcc	.+46     	; 0x35a2 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    3574:	81 e0       	ldi	r24, 0x01	; 1
    3576:	89 83       	std	Y+1, r24	; 0x01
    3578:	14 c0       	rjmp	.+40     	; 0x35a2 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    357a:	ed 81       	ldd	r30, Y+5	; 0x05
    357c:	fe 81       	ldd	r31, Y+6	; 0x06
    357e:	20 81       	ld	r18, Z
    3580:	31 81       	ldd	r19, Z+1	; 0x01
    3582:	8b 81       	ldd	r24, Y+3	; 0x03
    3584:	9c 81       	ldd	r25, Y+4	; 0x04
    3586:	82 17       	cp	r24, r18
    3588:	93 07       	cpc	r25, r19
    358a:	48 f0       	brcs	.+18     	; 0x359e <vTaskDelayUntil+0x9a>
    358c:	20 91 08 03 	lds	r18, 0x0308
    3590:	30 91 09 03 	lds	r19, 0x0309
    3594:	8b 81       	ldd	r24, Y+3	; 0x03
    3596:	9c 81       	ldd	r25, Y+4	; 0x04
    3598:	28 17       	cp	r18, r24
    359a:	39 07       	cpc	r19, r25
    359c:	10 f4       	brcc	.+4      	; 0x35a2 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    359e:	81 e0       	ldi	r24, 0x01	; 1
    35a0:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    35a2:	ed 81       	ldd	r30, Y+5	; 0x05
    35a4:	fe 81       	ldd	r31, Y+6	; 0x06
    35a6:	8b 81       	ldd	r24, Y+3	; 0x03
    35a8:	9c 81       	ldd	r25, Y+4	; 0x04
    35aa:	91 83       	std	Z+1, r25	; 0x01
    35ac:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    35ae:	89 81       	ldd	r24, Y+1	; 0x01
    35b0:	88 23       	and	r24, r24
    35b2:	59 f0       	breq	.+22     	; 0x35ca <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    35b4:	80 91 04 03 	lds	r24, 0x0304
    35b8:	90 91 05 03 	lds	r25, 0x0305
    35bc:	02 96       	adiw	r24, 0x02	; 2
    35be:	0e 94 96 11 	call	0x232c	; 0x232c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    35c2:	8b 81       	ldd	r24, Y+3	; 0x03
    35c4:	9c 81       	ldd	r25, Y+4	; 0x04
    35c6:	0e 94 6e 1f 	call	0x3edc	; 0x3edc <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    35ca:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <xTaskResumeAll>
    35ce:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    35d0:	8a 81       	ldd	r24, Y+2	; 0x02
    35d2:	88 23       	and	r24, r24
    35d4:	11 f4       	brne	.+4      	; 0x35da <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    35d6:	0e 94 9e 13 	call	0x273c	; 0x273c <vPortYield>
		}
	}
    35da:	28 96       	adiw	r28, 0x08	; 8
    35dc:	0f b6       	in	r0, 0x3f	; 63
    35de:	f8 94       	cli
    35e0:	de bf       	out	0x3e, r29	; 62
    35e2:	0f be       	out	0x3f, r0	; 63
    35e4:	cd bf       	out	0x3d, r28	; 61
    35e6:	cf 91       	pop	r28
    35e8:	df 91       	pop	r29
    35ea:	08 95       	ret

000035ec <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    35ec:	df 93       	push	r29
    35ee:	cf 93       	push	r28
    35f0:	00 d0       	rcall	.+0      	; 0x35f2 <vTaskDelay+0x6>
    35f2:	00 d0       	rcall	.+0      	; 0x35f4 <vTaskDelay+0x8>
    35f4:	0f 92       	push	r0
    35f6:	cd b7       	in	r28, 0x3d	; 61
    35f8:	de b7       	in	r29, 0x3e	; 62
    35fa:	9d 83       	std	Y+5, r25	; 0x05
    35fc:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    35fe:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    3600:	8c 81       	ldd	r24, Y+4	; 0x04
    3602:	9d 81       	ldd	r25, Y+5	; 0x05
    3604:	00 97       	sbiw	r24, 0x00	; 0
    3606:	d1 f0       	breq	.+52     	; 0x363c <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    3608:	0e 94 6e 1b 	call	0x36dc	; 0x36dc <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    360c:	20 91 08 03 	lds	r18, 0x0308
    3610:	30 91 09 03 	lds	r19, 0x0309
    3614:	8c 81       	ldd	r24, Y+4	; 0x04
    3616:	9d 81       	ldd	r25, Y+5	; 0x05
    3618:	82 0f       	add	r24, r18
    361a:	93 1f       	adc	r25, r19
    361c:	9b 83       	std	Y+3, r25	; 0x03
    361e:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3620:	80 91 04 03 	lds	r24, 0x0304
    3624:	90 91 05 03 	lds	r25, 0x0305
    3628:	02 96       	adiw	r24, 0x02	; 2
    362a:	0e 94 96 11 	call	0x232c	; 0x232c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    362e:	8a 81       	ldd	r24, Y+2	; 0x02
    3630:	9b 81       	ldd	r25, Y+3	; 0x03
    3632:	0e 94 6e 1f 	call	0x3edc	; 0x3edc <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3636:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <xTaskResumeAll>
    363a:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    363c:	89 81       	ldd	r24, Y+1	; 0x01
    363e:	88 23       	and	r24, r24
    3640:	11 f4       	brne	.+4      	; 0x3646 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    3642:	0e 94 9e 13 	call	0x273c	; 0x273c <vPortYield>
		}
	}
    3646:	0f 90       	pop	r0
    3648:	0f 90       	pop	r0
    364a:	0f 90       	pop	r0
    364c:	0f 90       	pop	r0
    364e:	0f 90       	pop	r0
    3650:	cf 91       	pop	r28
    3652:	df 91       	pop	r29
    3654:	08 95       	ret

00003656 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    3656:	af 92       	push	r10
    3658:	bf 92       	push	r11
    365a:	cf 92       	push	r12
    365c:	df 92       	push	r13
    365e:	ef 92       	push	r14
    3660:	ff 92       	push	r15
    3662:	0f 93       	push	r16
    3664:	df 93       	push	r29
    3666:	cf 93       	push	r28
    3668:	0f 92       	push	r0
    366a:	cd b7       	in	r28, 0x3d	; 61
    366c:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    366e:	20 e6       	ldi	r18, 0x60	; 96
    3670:	30 e0       	ldi	r19, 0x00	; 0
    3672:	82 e9       	ldi	r24, 0x92	; 146
    3674:	9e e1       	ldi	r25, 0x1E	; 30
    3676:	b9 01       	movw	r22, r18
    3678:	45 e5       	ldi	r20, 0x55	; 85
    367a:	50 e0       	ldi	r21, 0x00	; 0
    367c:	20 e0       	ldi	r18, 0x00	; 0
    367e:	30 e0       	ldi	r19, 0x00	; 0
    3680:	00 e0       	ldi	r16, 0x00	; 0
    3682:	ee 24       	eor	r14, r14
    3684:	ff 24       	eor	r15, r15
    3686:	cc 24       	eor	r12, r12
    3688:	dd 24       	eor	r13, r13
    368a:	aa 24       	eor	r10, r10
    368c:	bb 24       	eor	r11, r11
    368e:	0e 94 32 19 	call	0x3264	; 0x3264 <xTaskGenericCreate>
    3692:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    3694:	89 81       	ldd	r24, Y+1	; 0x01
    3696:	81 30       	cpi	r24, 0x01	; 1
    3698:	51 f4       	brne	.+20     	; 0x36ae <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    369a:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    369c:	81 e0       	ldi	r24, 0x01	; 1
    369e:	80 93 0c 03 	sts	0x030C, r24
		xTickCount = ( portTickType ) 0U;
    36a2:	10 92 09 03 	sts	0x0309, r1
    36a6:	10 92 08 03 	sts	0x0308, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    36aa:	0e 94 62 13 	call	0x26c4	; 0x26c4 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    36ae:	0f 90       	pop	r0
    36b0:	cf 91       	pop	r28
    36b2:	df 91       	pop	r29
    36b4:	0f 91       	pop	r16
    36b6:	ff 90       	pop	r15
    36b8:	ef 90       	pop	r14
    36ba:	df 90       	pop	r13
    36bc:	cf 90       	pop	r12
    36be:	bf 90       	pop	r11
    36c0:	af 90       	pop	r10
    36c2:	08 95       	ret

000036c4 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    36c4:	df 93       	push	r29
    36c6:	cf 93       	push	r28
    36c8:	cd b7       	in	r28, 0x3d	; 61
    36ca:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    36cc:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    36ce:	10 92 0c 03 	sts	0x030C, r1
	vPortEndScheduler();
    36d2:	0e 94 97 13 	call	0x272e	; 0x272e <vPortEndScheduler>
}
    36d6:	cf 91       	pop	r28
    36d8:	df 91       	pop	r29
    36da:	08 95       	ret

000036dc <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    36dc:	df 93       	push	r29
    36de:	cf 93       	push	r28
    36e0:	cd b7       	in	r28, 0x3d	; 61
    36e2:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    36e4:	80 91 0d 03 	lds	r24, 0x030D
    36e8:	8f 5f       	subi	r24, 0xFF	; 255
    36ea:	80 93 0d 03 	sts	0x030D, r24
}
    36ee:	cf 91       	pop	r28
    36f0:	df 91       	pop	r29
    36f2:	08 95       	ret

000036f4 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    36f4:	df 93       	push	r29
    36f6:	cf 93       	push	r28
    36f8:	00 d0       	rcall	.+0      	; 0x36fa <xTaskResumeAll+0x6>
    36fa:	00 d0       	rcall	.+0      	; 0x36fc <xTaskResumeAll+0x8>
    36fc:	cd b7       	in	r28, 0x3d	; 61
    36fe:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    3700:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    3702:	0f b6       	in	r0, 0x3f	; 63
    3704:	f8 94       	cli
    3706:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    3708:	80 91 0d 03 	lds	r24, 0x030D
    370c:	81 50       	subi	r24, 0x01	; 1
    370e:	80 93 0d 03 	sts	0x030D, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3712:	80 91 0d 03 	lds	r24, 0x030D
    3716:	88 23       	and	r24, r24
    3718:	09 f0       	breq	.+2      	; 0x371c <xTaskResumeAll+0x28>
    371a:	6c c0       	rjmp	.+216    	; 0x37f4 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    371c:	80 91 07 03 	lds	r24, 0x0307
    3720:	88 23       	and	r24, r24
    3722:	09 f4       	brne	.+2      	; 0x3726 <xTaskResumeAll+0x32>
    3724:	67 c0       	rjmp	.+206    	; 0x37f4 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    3726:	19 82       	std	Y+1, r1	; 0x01
    3728:	41 c0       	rjmp	.+130    	; 0x37ac <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    372a:	e0 91 48 03 	lds	r30, 0x0348
    372e:	f0 91 49 03 	lds	r31, 0x0349
    3732:	86 81       	ldd	r24, Z+6	; 0x06
    3734:	97 81       	ldd	r25, Z+7	; 0x07
    3736:	9c 83       	std	Y+4, r25	; 0x04
    3738:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    373a:	8b 81       	ldd	r24, Y+3	; 0x03
    373c:	9c 81       	ldd	r25, Y+4	; 0x04
    373e:	0c 96       	adiw	r24, 0x0c	; 12
    3740:	0e 94 96 11 	call	0x232c	; 0x232c <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    3744:	8b 81       	ldd	r24, Y+3	; 0x03
    3746:	9c 81       	ldd	r25, Y+4	; 0x04
    3748:	02 96       	adiw	r24, 0x02	; 2
    374a:	0e 94 96 11 	call	0x232c	; 0x232c <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    374e:	eb 81       	ldd	r30, Y+3	; 0x03
    3750:	fc 81       	ldd	r31, Y+4	; 0x04
    3752:	96 89       	ldd	r25, Z+22	; 0x16
    3754:	80 91 0b 03 	lds	r24, 0x030B
    3758:	89 17       	cp	r24, r25
    375a:	28 f4       	brcc	.+10     	; 0x3766 <xTaskResumeAll+0x72>
    375c:	eb 81       	ldd	r30, Y+3	; 0x03
    375e:	fc 81       	ldd	r31, Y+4	; 0x04
    3760:	86 89       	ldd	r24, Z+22	; 0x16
    3762:	80 93 0b 03 	sts	0x030B, r24
    3766:	eb 81       	ldd	r30, Y+3	; 0x03
    3768:	fc 81       	ldd	r31, Y+4	; 0x04
    376a:	86 89       	ldd	r24, Z+22	; 0x16
    376c:	28 2f       	mov	r18, r24
    376e:	30 e0       	ldi	r19, 0x00	; 0
    3770:	c9 01       	movw	r24, r18
    3772:	88 0f       	add	r24, r24
    3774:	99 1f       	adc	r25, r25
    3776:	88 0f       	add	r24, r24
    3778:	99 1f       	adc	r25, r25
    377a:	88 0f       	add	r24, r24
    377c:	99 1f       	adc	r25, r25
    377e:	82 0f       	add	r24, r18
    3780:	93 1f       	adc	r25, r19
    3782:	8e 5e       	subi	r24, 0xEE	; 238
    3784:	9c 4f       	sbci	r25, 0xFC	; 252
    3786:	2b 81       	ldd	r18, Y+3	; 0x03
    3788:	3c 81       	ldd	r19, Y+4	; 0x04
    378a:	2e 5f       	subi	r18, 0xFE	; 254
    378c:	3f 4f       	sbci	r19, 0xFF	; 255
    378e:	b9 01       	movw	r22, r18
    3790:	0e 94 de 10 	call	0x21bc	; 0x21bc <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3794:	eb 81       	ldd	r30, Y+3	; 0x03
    3796:	fc 81       	ldd	r31, Y+4	; 0x04
    3798:	96 89       	ldd	r25, Z+22	; 0x16
    379a:	e0 91 04 03 	lds	r30, 0x0304
    379e:	f0 91 05 03 	lds	r31, 0x0305
    37a2:	86 89       	ldd	r24, Z+22	; 0x16
    37a4:	98 17       	cp	r25, r24
    37a6:	10 f0       	brcs	.+4      	; 0x37ac <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    37a8:	81 e0       	ldi	r24, 0x01	; 1
    37aa:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    37ac:	80 91 43 03 	lds	r24, 0x0343
    37b0:	88 23       	and	r24, r24
    37b2:	09 f0       	breq	.+2      	; 0x37b6 <xTaskResumeAll+0xc2>
    37b4:	ba cf       	rjmp	.-140    	; 0x372a <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    37b6:	80 91 0e 03 	lds	r24, 0x030E
    37ba:	88 23       	and	r24, r24
    37bc:	71 f0       	breq	.+28     	; 0x37da <xTaskResumeAll+0xe6>
    37be:	07 c0       	rjmp	.+14     	; 0x37ce <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    37c0:	0e 94 39 1c 	call	0x3872	; 0x3872 <vTaskIncrementTick>
						--uxMissedTicks;
    37c4:	80 91 0e 03 	lds	r24, 0x030E
    37c8:	81 50       	subi	r24, 0x01	; 1
    37ca:	80 93 0e 03 	sts	0x030E, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    37ce:	80 91 0e 03 	lds	r24, 0x030E
    37d2:	88 23       	and	r24, r24
    37d4:	a9 f7       	brne	.-22     	; 0x37c0 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    37d6:	81 e0       	ldi	r24, 0x01	; 1
    37d8:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    37da:	89 81       	ldd	r24, Y+1	; 0x01
    37dc:	81 30       	cpi	r24, 0x01	; 1
    37de:	21 f0       	breq	.+8      	; 0x37e8 <xTaskResumeAll+0xf4>
    37e0:	80 91 0f 03 	lds	r24, 0x030F
    37e4:	81 30       	cpi	r24, 0x01	; 1
    37e6:	31 f4       	brne	.+12     	; 0x37f4 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    37e8:	81 e0       	ldi	r24, 0x01	; 1
    37ea:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    37ec:	10 92 0f 03 	sts	0x030F, r1
					portYIELD_WITHIN_API();
    37f0:	0e 94 9e 13 	call	0x273c	; 0x273c <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    37f4:	0f 90       	pop	r0
    37f6:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    37f8:	8a 81       	ldd	r24, Y+2	; 0x02
}
    37fa:	0f 90       	pop	r0
    37fc:	0f 90       	pop	r0
    37fe:	0f 90       	pop	r0
    3800:	0f 90       	pop	r0
    3802:	cf 91       	pop	r28
    3804:	df 91       	pop	r29
    3806:	08 95       	ret

00003808 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    3808:	df 93       	push	r29
    380a:	cf 93       	push	r28
    380c:	00 d0       	rcall	.+0      	; 0x380e <xTaskGetTickCount+0x6>
    380e:	cd b7       	in	r28, 0x3d	; 61
    3810:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    3812:	0f b6       	in	r0, 0x3f	; 63
    3814:	f8 94       	cli
    3816:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    3818:	80 91 08 03 	lds	r24, 0x0308
    381c:	90 91 09 03 	lds	r25, 0x0309
    3820:	9a 83       	std	Y+2, r25	; 0x02
    3822:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3824:	0f 90       	pop	r0
    3826:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3828:	89 81       	ldd	r24, Y+1	; 0x01
    382a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    382c:	0f 90       	pop	r0
    382e:	0f 90       	pop	r0
    3830:	cf 91       	pop	r28
    3832:	df 91       	pop	r29
    3834:	08 95       	ret

00003836 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    3836:	df 93       	push	r29
    3838:	cf 93       	push	r28
    383a:	00 d0       	rcall	.+0      	; 0x383c <xTaskGetTickCountFromISR+0x6>
    383c:	0f 92       	push	r0
    383e:	cd b7       	in	r28, 0x3d	; 61
    3840:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3842:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    3844:	80 91 08 03 	lds	r24, 0x0308
    3848:	90 91 09 03 	lds	r25, 0x0309
    384c:	9b 83       	std	Y+3, r25	; 0x03
    384e:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3850:	8a 81       	ldd	r24, Y+2	; 0x02
    3852:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3854:	0f 90       	pop	r0
    3856:	0f 90       	pop	r0
    3858:	0f 90       	pop	r0
    385a:	cf 91       	pop	r28
    385c:	df 91       	pop	r29
    385e:	08 95       	ret

00003860 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    3860:	df 93       	push	r29
    3862:	cf 93       	push	r28
    3864:	cd b7       	in	r28, 0x3d	; 61
    3866:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    3868:	80 91 07 03 	lds	r24, 0x0307
}
    386c:	cf 91       	pop	r28
    386e:	df 91       	pop	r29
    3870:	08 95       	ret

00003872 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    3872:	df 93       	push	r29
    3874:	cf 93       	push	r28
    3876:	00 d0       	rcall	.+0      	; 0x3878 <vTaskIncrementTick+0x6>
    3878:	00 d0       	rcall	.+0      	; 0x387a <vTaskIncrementTick+0x8>
    387a:	00 d0       	rcall	.+0      	; 0x387c <vTaskIncrementTick+0xa>
    387c:	cd b7       	in	r28, 0x3d	; 61
    387e:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3880:	80 91 0d 03 	lds	r24, 0x030D
    3884:	88 23       	and	r24, r24
    3886:	09 f0       	breq	.+2      	; 0x388a <vTaskIncrementTick+0x18>
    3888:	bb c0       	rjmp	.+374    	; 0x3a00 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    388a:	80 91 08 03 	lds	r24, 0x0308
    388e:	90 91 09 03 	lds	r25, 0x0309
    3892:	01 96       	adiw	r24, 0x01	; 1
    3894:	90 93 09 03 	sts	0x0309, r25
    3898:	80 93 08 03 	sts	0x0308, r24
		if( xTickCount == ( portTickType ) 0U )
    389c:	80 91 08 03 	lds	r24, 0x0308
    38a0:	90 91 09 03 	lds	r25, 0x0309
    38a4:	00 97       	sbiw	r24, 0x00	; 0
    38a6:	d1 f5       	brne	.+116    	; 0x391c <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    38a8:	80 91 3f 03 	lds	r24, 0x033F
    38ac:	90 91 40 03 	lds	r25, 0x0340
    38b0:	9c 83       	std	Y+4, r25	; 0x04
    38b2:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    38b4:	80 91 41 03 	lds	r24, 0x0341
    38b8:	90 91 42 03 	lds	r25, 0x0342
    38bc:	90 93 40 03 	sts	0x0340, r25
    38c0:	80 93 3f 03 	sts	0x033F, r24
			pxOverflowDelayedTaskList = pxTemp;
    38c4:	8b 81       	ldd	r24, Y+3	; 0x03
    38c6:	9c 81       	ldd	r25, Y+4	; 0x04
    38c8:	90 93 42 03 	sts	0x0342, r25
    38cc:	80 93 41 03 	sts	0x0341, r24
			xNumOfOverflows++;
    38d0:	80 91 10 03 	lds	r24, 0x0310
    38d4:	8f 5f       	subi	r24, 0xFF	; 255
    38d6:	80 93 10 03 	sts	0x0310, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    38da:	e0 91 3f 03 	lds	r30, 0x033F
    38de:	f0 91 40 03 	lds	r31, 0x0340
    38e2:	80 81       	ld	r24, Z
    38e4:	88 23       	and	r24, r24
    38e6:	39 f4       	brne	.+14     	; 0x38f6 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    38e8:	8f ef       	ldi	r24, 0xFF	; 255
    38ea:	9f ef       	ldi	r25, 0xFF	; 255
    38ec:	90 93 6e 00 	sts	0x006E, r25
    38f0:	80 93 6d 00 	sts	0x006D, r24
    38f4:	13 c0       	rjmp	.+38     	; 0x391c <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    38f6:	e0 91 3f 03 	lds	r30, 0x033F
    38fa:	f0 91 40 03 	lds	r31, 0x0340
    38fe:	05 80       	ldd	r0, Z+5	; 0x05
    3900:	f6 81       	ldd	r31, Z+6	; 0x06
    3902:	e0 2d       	mov	r30, r0
    3904:	86 81       	ldd	r24, Z+6	; 0x06
    3906:	97 81       	ldd	r25, Z+7	; 0x07
    3908:	9e 83       	std	Y+6, r25	; 0x06
    390a:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    390c:	ed 81       	ldd	r30, Y+5	; 0x05
    390e:	fe 81       	ldd	r31, Y+6	; 0x06
    3910:	82 81       	ldd	r24, Z+2	; 0x02
    3912:	93 81       	ldd	r25, Z+3	; 0x03
    3914:	90 93 6e 00 	sts	0x006E, r25
    3918:	80 93 6d 00 	sts	0x006D, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    391c:	20 91 08 03 	lds	r18, 0x0308
    3920:	30 91 09 03 	lds	r19, 0x0309
    3924:	80 91 6d 00 	lds	r24, 0x006D
    3928:	90 91 6e 00 	lds	r25, 0x006E
    392c:	28 17       	cp	r18, r24
    392e:	39 07       	cpc	r19, r25
    3930:	08 f4       	brcc	.+2      	; 0x3934 <vTaskIncrementTick+0xc2>
    3932:	6b c0       	rjmp	.+214    	; 0x3a0a <vTaskIncrementTick+0x198>
    3934:	e0 91 3f 03 	lds	r30, 0x033F
    3938:	f0 91 40 03 	lds	r31, 0x0340
    393c:	80 81       	ld	r24, Z
    393e:	88 23       	and	r24, r24
    3940:	39 f4       	brne	.+14     	; 0x3950 <vTaskIncrementTick+0xde>
    3942:	8f ef       	ldi	r24, 0xFF	; 255
    3944:	9f ef       	ldi	r25, 0xFF	; 255
    3946:	90 93 6e 00 	sts	0x006E, r25
    394a:	80 93 6d 00 	sts	0x006D, r24
    394e:	5d c0       	rjmp	.+186    	; 0x3a0a <vTaskIncrementTick+0x198>
    3950:	e0 91 3f 03 	lds	r30, 0x033F
    3954:	f0 91 40 03 	lds	r31, 0x0340
    3958:	05 80       	ldd	r0, Z+5	; 0x05
    395a:	f6 81       	ldd	r31, Z+6	; 0x06
    395c:	e0 2d       	mov	r30, r0
    395e:	86 81       	ldd	r24, Z+6	; 0x06
    3960:	97 81       	ldd	r25, Z+7	; 0x07
    3962:	9e 83       	std	Y+6, r25	; 0x06
    3964:	8d 83       	std	Y+5, r24	; 0x05
    3966:	ed 81       	ldd	r30, Y+5	; 0x05
    3968:	fe 81       	ldd	r31, Y+6	; 0x06
    396a:	82 81       	ldd	r24, Z+2	; 0x02
    396c:	93 81       	ldd	r25, Z+3	; 0x03
    396e:	9a 83       	std	Y+2, r25	; 0x02
    3970:	89 83       	std	Y+1, r24	; 0x01
    3972:	20 91 08 03 	lds	r18, 0x0308
    3976:	30 91 09 03 	lds	r19, 0x0309
    397a:	89 81       	ldd	r24, Y+1	; 0x01
    397c:	9a 81       	ldd	r25, Y+2	; 0x02
    397e:	28 17       	cp	r18, r24
    3980:	39 07       	cpc	r19, r25
    3982:	38 f4       	brcc	.+14     	; 0x3992 <vTaskIncrementTick+0x120>
    3984:	89 81       	ldd	r24, Y+1	; 0x01
    3986:	9a 81       	ldd	r25, Y+2	; 0x02
    3988:	90 93 6e 00 	sts	0x006E, r25
    398c:	80 93 6d 00 	sts	0x006D, r24
    3990:	3c c0       	rjmp	.+120    	; 0x3a0a <vTaskIncrementTick+0x198>
    3992:	8d 81       	ldd	r24, Y+5	; 0x05
    3994:	9e 81       	ldd	r25, Y+6	; 0x06
    3996:	02 96       	adiw	r24, 0x02	; 2
    3998:	0e 94 96 11 	call	0x232c	; 0x232c <vListRemove>
    399c:	ed 81       	ldd	r30, Y+5	; 0x05
    399e:	fe 81       	ldd	r31, Y+6	; 0x06
    39a0:	84 89       	ldd	r24, Z+20	; 0x14
    39a2:	95 89       	ldd	r25, Z+21	; 0x15
    39a4:	00 97       	sbiw	r24, 0x00	; 0
    39a6:	29 f0       	breq	.+10     	; 0x39b2 <vTaskIncrementTick+0x140>
    39a8:	8d 81       	ldd	r24, Y+5	; 0x05
    39aa:	9e 81       	ldd	r25, Y+6	; 0x06
    39ac:	0c 96       	adiw	r24, 0x0c	; 12
    39ae:	0e 94 96 11 	call	0x232c	; 0x232c <vListRemove>
    39b2:	ed 81       	ldd	r30, Y+5	; 0x05
    39b4:	fe 81       	ldd	r31, Y+6	; 0x06
    39b6:	96 89       	ldd	r25, Z+22	; 0x16
    39b8:	80 91 0b 03 	lds	r24, 0x030B
    39bc:	89 17       	cp	r24, r25
    39be:	28 f4       	brcc	.+10     	; 0x39ca <vTaskIncrementTick+0x158>
    39c0:	ed 81       	ldd	r30, Y+5	; 0x05
    39c2:	fe 81       	ldd	r31, Y+6	; 0x06
    39c4:	86 89       	ldd	r24, Z+22	; 0x16
    39c6:	80 93 0b 03 	sts	0x030B, r24
    39ca:	ed 81       	ldd	r30, Y+5	; 0x05
    39cc:	fe 81       	ldd	r31, Y+6	; 0x06
    39ce:	86 89       	ldd	r24, Z+22	; 0x16
    39d0:	28 2f       	mov	r18, r24
    39d2:	30 e0       	ldi	r19, 0x00	; 0
    39d4:	c9 01       	movw	r24, r18
    39d6:	88 0f       	add	r24, r24
    39d8:	99 1f       	adc	r25, r25
    39da:	88 0f       	add	r24, r24
    39dc:	99 1f       	adc	r25, r25
    39de:	88 0f       	add	r24, r24
    39e0:	99 1f       	adc	r25, r25
    39e2:	82 0f       	add	r24, r18
    39e4:	93 1f       	adc	r25, r19
    39e6:	ac 01       	movw	r20, r24
    39e8:	4e 5e       	subi	r20, 0xEE	; 238
    39ea:	5c 4f       	sbci	r21, 0xFC	; 252
    39ec:	8d 81       	ldd	r24, Y+5	; 0x05
    39ee:	9e 81       	ldd	r25, Y+6	; 0x06
    39f0:	9c 01       	movw	r18, r24
    39f2:	2e 5f       	subi	r18, 0xFE	; 254
    39f4:	3f 4f       	sbci	r19, 0xFF	; 255
    39f6:	ca 01       	movw	r24, r20
    39f8:	b9 01       	movw	r22, r18
    39fa:	0e 94 de 10 	call	0x21bc	; 0x21bc <vListInsertEnd>
    39fe:	9a cf       	rjmp	.-204    	; 0x3934 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    3a00:	80 91 0e 03 	lds	r24, 0x030E
    3a04:	8f 5f       	subi	r24, 0xFF	; 255
    3a06:	80 93 0e 03 	sts	0x030E, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    3a0a:	26 96       	adiw	r28, 0x06	; 6
    3a0c:	0f b6       	in	r0, 0x3f	; 63
    3a0e:	f8 94       	cli
    3a10:	de bf       	out	0x3e, r29	; 62
    3a12:	0f be       	out	0x3f, r0	; 63
    3a14:	cd bf       	out	0x3d, r28	; 61
    3a16:	cf 91       	pop	r28
    3a18:	df 91       	pop	r29
    3a1a:	08 95       	ret

00003a1c <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3a1c:	df 93       	push	r29
    3a1e:	cf 93       	push	r28
    3a20:	00 d0       	rcall	.+0      	; 0x3a22 <vTaskSwitchContext+0x6>
    3a22:	cd b7       	in	r28, 0x3d	; 61
    3a24:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    3a26:	80 91 0d 03 	lds	r24, 0x030D
    3a2a:	88 23       	and	r24, r24
    3a2c:	49 f0       	breq	.+18     	; 0x3a40 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    3a2e:	81 e0       	ldi	r24, 0x01	; 1
    3a30:	80 93 0f 03 	sts	0x030F, r24
    3a34:	54 c0       	rjmp	.+168    	; 0x3ade <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    3a36:	80 91 0b 03 	lds	r24, 0x030B
    3a3a:	81 50       	subi	r24, 0x01	; 1
    3a3c:	80 93 0b 03 	sts	0x030B, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    3a40:	80 91 0b 03 	lds	r24, 0x030B
    3a44:	28 2f       	mov	r18, r24
    3a46:	30 e0       	ldi	r19, 0x00	; 0
    3a48:	c9 01       	movw	r24, r18
    3a4a:	88 0f       	add	r24, r24
    3a4c:	99 1f       	adc	r25, r25
    3a4e:	88 0f       	add	r24, r24
    3a50:	99 1f       	adc	r25, r25
    3a52:	88 0f       	add	r24, r24
    3a54:	99 1f       	adc	r25, r25
    3a56:	82 0f       	add	r24, r18
    3a58:	93 1f       	adc	r25, r19
    3a5a:	fc 01       	movw	r30, r24
    3a5c:	ee 5e       	subi	r30, 0xEE	; 238
    3a5e:	fc 4f       	sbci	r31, 0xFC	; 252
    3a60:	80 81       	ld	r24, Z
    3a62:	88 23       	and	r24, r24
    3a64:	41 f3       	breq	.-48     	; 0x3a36 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    3a66:	80 91 0b 03 	lds	r24, 0x030B
    3a6a:	28 2f       	mov	r18, r24
    3a6c:	30 e0       	ldi	r19, 0x00	; 0
    3a6e:	c9 01       	movw	r24, r18
    3a70:	88 0f       	add	r24, r24
    3a72:	99 1f       	adc	r25, r25
    3a74:	88 0f       	add	r24, r24
    3a76:	99 1f       	adc	r25, r25
    3a78:	88 0f       	add	r24, r24
    3a7a:	99 1f       	adc	r25, r25
    3a7c:	82 0f       	add	r24, r18
    3a7e:	93 1f       	adc	r25, r19
    3a80:	8e 5e       	subi	r24, 0xEE	; 238
    3a82:	9c 4f       	sbci	r25, 0xFC	; 252
    3a84:	9a 83       	std	Y+2, r25	; 0x02
    3a86:	89 83       	std	Y+1, r24	; 0x01
    3a88:	e9 81       	ldd	r30, Y+1	; 0x01
    3a8a:	fa 81       	ldd	r31, Y+2	; 0x02
    3a8c:	01 80       	ldd	r0, Z+1	; 0x01
    3a8e:	f2 81       	ldd	r31, Z+2	; 0x02
    3a90:	e0 2d       	mov	r30, r0
    3a92:	82 81       	ldd	r24, Z+2	; 0x02
    3a94:	93 81       	ldd	r25, Z+3	; 0x03
    3a96:	e9 81       	ldd	r30, Y+1	; 0x01
    3a98:	fa 81       	ldd	r31, Y+2	; 0x02
    3a9a:	92 83       	std	Z+2, r25	; 0x02
    3a9c:	81 83       	std	Z+1, r24	; 0x01
    3a9e:	e9 81       	ldd	r30, Y+1	; 0x01
    3aa0:	fa 81       	ldd	r31, Y+2	; 0x02
    3aa2:	21 81       	ldd	r18, Z+1	; 0x01
    3aa4:	32 81       	ldd	r19, Z+2	; 0x02
    3aa6:	89 81       	ldd	r24, Y+1	; 0x01
    3aa8:	9a 81       	ldd	r25, Y+2	; 0x02
    3aaa:	03 96       	adiw	r24, 0x03	; 3
    3aac:	28 17       	cp	r18, r24
    3aae:	39 07       	cpc	r19, r25
    3ab0:	59 f4       	brne	.+22     	; 0x3ac8 <vTaskSwitchContext+0xac>
    3ab2:	e9 81       	ldd	r30, Y+1	; 0x01
    3ab4:	fa 81       	ldd	r31, Y+2	; 0x02
    3ab6:	01 80       	ldd	r0, Z+1	; 0x01
    3ab8:	f2 81       	ldd	r31, Z+2	; 0x02
    3aba:	e0 2d       	mov	r30, r0
    3abc:	82 81       	ldd	r24, Z+2	; 0x02
    3abe:	93 81       	ldd	r25, Z+3	; 0x03
    3ac0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ac2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ac4:	92 83       	std	Z+2, r25	; 0x02
    3ac6:	81 83       	std	Z+1, r24	; 0x01
    3ac8:	e9 81       	ldd	r30, Y+1	; 0x01
    3aca:	fa 81       	ldd	r31, Y+2	; 0x02
    3acc:	01 80       	ldd	r0, Z+1	; 0x01
    3ace:	f2 81       	ldd	r31, Z+2	; 0x02
    3ad0:	e0 2d       	mov	r30, r0
    3ad2:	86 81       	ldd	r24, Z+6	; 0x06
    3ad4:	97 81       	ldd	r25, Z+7	; 0x07
    3ad6:	90 93 05 03 	sts	0x0305, r25
    3ada:	80 93 04 03 	sts	0x0304, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    3ade:	0f 90       	pop	r0
    3ae0:	0f 90       	pop	r0
    3ae2:	cf 91       	pop	r28
    3ae4:	df 91       	pop	r29
    3ae6:	08 95       	ret

00003ae8 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    3ae8:	df 93       	push	r29
    3aea:	cf 93       	push	r28
    3aec:	00 d0       	rcall	.+0      	; 0x3aee <vTaskPlaceOnEventList+0x6>
    3aee:	00 d0       	rcall	.+0      	; 0x3af0 <vTaskPlaceOnEventList+0x8>
    3af0:	00 d0       	rcall	.+0      	; 0x3af2 <vTaskPlaceOnEventList+0xa>
    3af2:	cd b7       	in	r28, 0x3d	; 61
    3af4:	de b7       	in	r29, 0x3e	; 62
    3af6:	9c 83       	std	Y+4, r25	; 0x04
    3af8:	8b 83       	std	Y+3, r24	; 0x03
    3afa:	7e 83       	std	Y+6, r23	; 0x06
    3afc:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    3afe:	4b 81       	ldd	r20, Y+3	; 0x03
    3b00:	5c 81       	ldd	r21, Y+4	; 0x04
    3b02:	80 91 04 03 	lds	r24, 0x0304
    3b06:	90 91 05 03 	lds	r25, 0x0305
    3b0a:	9c 01       	movw	r18, r24
    3b0c:	24 5f       	subi	r18, 0xF4	; 244
    3b0e:	3f 4f       	sbci	r19, 0xFF	; 255
    3b10:	ca 01       	movw	r24, r20
    3b12:	b9 01       	movw	r22, r18
    3b14:	0e 94 2a 11 	call	0x2254	; 0x2254 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3b18:	80 91 04 03 	lds	r24, 0x0304
    3b1c:	90 91 05 03 	lds	r25, 0x0305
    3b20:	02 96       	adiw	r24, 0x02	; 2
    3b22:	0e 94 96 11 	call	0x232c	; 0x232c <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    3b26:	20 91 08 03 	lds	r18, 0x0308
    3b2a:	30 91 09 03 	lds	r19, 0x0309
    3b2e:	8d 81       	ldd	r24, Y+5	; 0x05
    3b30:	9e 81       	ldd	r25, Y+6	; 0x06
    3b32:	82 0f       	add	r24, r18
    3b34:	93 1f       	adc	r25, r19
    3b36:	9a 83       	std	Y+2, r25	; 0x02
    3b38:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3b3a:	89 81       	ldd	r24, Y+1	; 0x01
    3b3c:	9a 81       	ldd	r25, Y+2	; 0x02
    3b3e:	0e 94 6e 1f 	call	0x3edc	; 0x3edc <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    3b42:	26 96       	adiw	r28, 0x06	; 6
    3b44:	0f b6       	in	r0, 0x3f	; 63
    3b46:	f8 94       	cli
    3b48:	de bf       	out	0x3e, r29	; 62
    3b4a:	0f be       	out	0x3f, r0	; 63
    3b4c:	cd bf       	out	0x3d, r28	; 61
    3b4e:	cf 91       	pop	r28
    3b50:	df 91       	pop	r29
    3b52:	08 95       	ret

00003b54 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    3b54:	df 93       	push	r29
    3b56:	cf 93       	push	r28
    3b58:	00 d0       	rcall	.+0      	; 0x3b5a <xTaskRemoveFromEventList+0x6>
    3b5a:	00 d0       	rcall	.+0      	; 0x3b5c <xTaskRemoveFromEventList+0x8>
    3b5c:	0f 92       	push	r0
    3b5e:	cd b7       	in	r28, 0x3d	; 61
    3b60:	de b7       	in	r29, 0x3e	; 62
    3b62:	9d 83       	std	Y+5, r25	; 0x05
    3b64:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3b66:	ec 81       	ldd	r30, Y+4	; 0x04
    3b68:	fd 81       	ldd	r31, Y+5	; 0x05
    3b6a:	05 80       	ldd	r0, Z+5	; 0x05
    3b6c:	f6 81       	ldd	r31, Z+6	; 0x06
    3b6e:	e0 2d       	mov	r30, r0
    3b70:	86 81       	ldd	r24, Z+6	; 0x06
    3b72:	97 81       	ldd	r25, Z+7	; 0x07
    3b74:	9b 83       	std	Y+3, r25	; 0x03
    3b76:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3b78:	8a 81       	ldd	r24, Y+2	; 0x02
    3b7a:	9b 81       	ldd	r25, Y+3	; 0x03
    3b7c:	0c 96       	adiw	r24, 0x0c	; 12
    3b7e:	0e 94 96 11 	call	0x232c	; 0x232c <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3b82:	80 91 0d 03 	lds	r24, 0x030D
    3b86:	88 23       	and	r24, r24
    3b88:	61 f5       	brne	.+88     	; 0x3be2 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3b8a:	8a 81       	ldd	r24, Y+2	; 0x02
    3b8c:	9b 81       	ldd	r25, Y+3	; 0x03
    3b8e:	02 96       	adiw	r24, 0x02	; 2
    3b90:	0e 94 96 11 	call	0x232c	; 0x232c <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    3b94:	ea 81       	ldd	r30, Y+2	; 0x02
    3b96:	fb 81       	ldd	r31, Y+3	; 0x03
    3b98:	96 89       	ldd	r25, Z+22	; 0x16
    3b9a:	80 91 0b 03 	lds	r24, 0x030B
    3b9e:	89 17       	cp	r24, r25
    3ba0:	28 f4       	brcc	.+10     	; 0x3bac <xTaskRemoveFromEventList+0x58>
    3ba2:	ea 81       	ldd	r30, Y+2	; 0x02
    3ba4:	fb 81       	ldd	r31, Y+3	; 0x03
    3ba6:	86 89       	ldd	r24, Z+22	; 0x16
    3ba8:	80 93 0b 03 	sts	0x030B, r24
    3bac:	ea 81       	ldd	r30, Y+2	; 0x02
    3bae:	fb 81       	ldd	r31, Y+3	; 0x03
    3bb0:	86 89       	ldd	r24, Z+22	; 0x16
    3bb2:	28 2f       	mov	r18, r24
    3bb4:	30 e0       	ldi	r19, 0x00	; 0
    3bb6:	c9 01       	movw	r24, r18
    3bb8:	88 0f       	add	r24, r24
    3bba:	99 1f       	adc	r25, r25
    3bbc:	88 0f       	add	r24, r24
    3bbe:	99 1f       	adc	r25, r25
    3bc0:	88 0f       	add	r24, r24
    3bc2:	99 1f       	adc	r25, r25
    3bc4:	82 0f       	add	r24, r18
    3bc6:	93 1f       	adc	r25, r19
    3bc8:	ac 01       	movw	r20, r24
    3bca:	4e 5e       	subi	r20, 0xEE	; 238
    3bcc:	5c 4f       	sbci	r21, 0xFC	; 252
    3bce:	8a 81       	ldd	r24, Y+2	; 0x02
    3bd0:	9b 81       	ldd	r25, Y+3	; 0x03
    3bd2:	9c 01       	movw	r18, r24
    3bd4:	2e 5f       	subi	r18, 0xFE	; 254
    3bd6:	3f 4f       	sbci	r19, 0xFF	; 255
    3bd8:	ca 01       	movw	r24, r20
    3bda:	b9 01       	movw	r22, r18
    3bdc:	0e 94 de 10 	call	0x21bc	; 0x21bc <vListInsertEnd>
    3be0:	0a c0       	rjmp	.+20     	; 0x3bf6 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3be2:	8a 81       	ldd	r24, Y+2	; 0x02
    3be4:	9b 81       	ldd	r25, Y+3	; 0x03
    3be6:	9c 01       	movw	r18, r24
    3be8:	24 5f       	subi	r18, 0xF4	; 244
    3bea:	3f 4f       	sbci	r19, 0xFF	; 255
    3bec:	83 e4       	ldi	r24, 0x43	; 67
    3bee:	93 e0       	ldi	r25, 0x03	; 3
    3bf0:	b9 01       	movw	r22, r18
    3bf2:	0e 94 de 10 	call	0x21bc	; 0x21bc <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3bf6:	ea 81       	ldd	r30, Y+2	; 0x02
    3bf8:	fb 81       	ldd	r31, Y+3	; 0x03
    3bfa:	96 89       	ldd	r25, Z+22	; 0x16
    3bfc:	e0 91 04 03 	lds	r30, 0x0304
    3c00:	f0 91 05 03 	lds	r31, 0x0305
    3c04:	86 89       	ldd	r24, Z+22	; 0x16
    3c06:	98 17       	cp	r25, r24
    3c08:	18 f0       	brcs	.+6      	; 0x3c10 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    3c0a:	81 e0       	ldi	r24, 0x01	; 1
    3c0c:	89 83       	std	Y+1, r24	; 0x01
    3c0e:	01 c0       	rjmp	.+2      	; 0x3c12 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    3c10:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3c12:	89 81       	ldd	r24, Y+1	; 0x01
}
    3c14:	0f 90       	pop	r0
    3c16:	0f 90       	pop	r0
    3c18:	0f 90       	pop	r0
    3c1a:	0f 90       	pop	r0
    3c1c:	0f 90       	pop	r0
    3c1e:	cf 91       	pop	r28
    3c20:	df 91       	pop	r29
    3c22:	08 95       	ret

00003c24 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    3c24:	df 93       	push	r29
    3c26:	cf 93       	push	r28
    3c28:	00 d0       	rcall	.+0      	; 0x3c2a <vTaskSetTimeOutState+0x6>
    3c2a:	cd b7       	in	r28, 0x3d	; 61
    3c2c:	de b7       	in	r29, 0x3e	; 62
    3c2e:	9a 83       	std	Y+2, r25	; 0x02
    3c30:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3c32:	80 91 10 03 	lds	r24, 0x0310
    3c36:	e9 81       	ldd	r30, Y+1	; 0x01
    3c38:	fa 81       	ldd	r31, Y+2	; 0x02
    3c3a:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3c3c:	80 91 08 03 	lds	r24, 0x0308
    3c40:	90 91 09 03 	lds	r25, 0x0309
    3c44:	e9 81       	ldd	r30, Y+1	; 0x01
    3c46:	fa 81       	ldd	r31, Y+2	; 0x02
    3c48:	92 83       	std	Z+2, r25	; 0x02
    3c4a:	81 83       	std	Z+1, r24	; 0x01
}
    3c4c:	0f 90       	pop	r0
    3c4e:	0f 90       	pop	r0
    3c50:	cf 91       	pop	r28
    3c52:	df 91       	pop	r29
    3c54:	08 95       	ret

00003c56 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    3c56:	df 93       	push	r29
    3c58:	cf 93       	push	r28
    3c5a:	00 d0       	rcall	.+0      	; 0x3c5c <xTaskCheckForTimeOut+0x6>
    3c5c:	00 d0       	rcall	.+0      	; 0x3c5e <xTaskCheckForTimeOut+0x8>
    3c5e:	0f 92       	push	r0
    3c60:	cd b7       	in	r28, 0x3d	; 61
    3c62:	de b7       	in	r29, 0x3e	; 62
    3c64:	9b 83       	std	Y+3, r25	; 0x03
    3c66:	8a 83       	std	Y+2, r24	; 0x02
    3c68:	7d 83       	std	Y+5, r23	; 0x05
    3c6a:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3c6c:	0f b6       	in	r0, 0x3f	; 63
    3c6e:	f8 94       	cli
    3c70:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    3c72:	ea 81       	ldd	r30, Y+2	; 0x02
    3c74:	fb 81       	ldd	r31, Y+3	; 0x03
    3c76:	90 81       	ld	r25, Z
    3c78:	80 91 10 03 	lds	r24, 0x0310
    3c7c:	98 17       	cp	r25, r24
    3c7e:	71 f0       	breq	.+28     	; 0x3c9c <xTaskCheckForTimeOut+0x46>
    3c80:	ea 81       	ldd	r30, Y+2	; 0x02
    3c82:	fb 81       	ldd	r31, Y+3	; 0x03
    3c84:	21 81       	ldd	r18, Z+1	; 0x01
    3c86:	32 81       	ldd	r19, Z+2	; 0x02
    3c88:	80 91 08 03 	lds	r24, 0x0308
    3c8c:	90 91 09 03 	lds	r25, 0x0309
    3c90:	82 17       	cp	r24, r18
    3c92:	93 07       	cpc	r25, r19
    3c94:	18 f0       	brcs	.+6      	; 0x3c9c <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    3c96:	81 e0       	ldi	r24, 0x01	; 1
    3c98:	89 83       	std	Y+1, r24	; 0x01
    3c9a:	2f c0       	rjmp	.+94     	; 0x3cfa <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    3c9c:	20 91 08 03 	lds	r18, 0x0308
    3ca0:	30 91 09 03 	lds	r19, 0x0309
    3ca4:	ea 81       	ldd	r30, Y+2	; 0x02
    3ca6:	fb 81       	ldd	r31, Y+3	; 0x03
    3ca8:	81 81       	ldd	r24, Z+1	; 0x01
    3caa:	92 81       	ldd	r25, Z+2	; 0x02
    3cac:	28 1b       	sub	r18, r24
    3cae:	39 0b       	sbc	r19, r25
    3cb0:	ec 81       	ldd	r30, Y+4	; 0x04
    3cb2:	fd 81       	ldd	r31, Y+5	; 0x05
    3cb4:	80 81       	ld	r24, Z
    3cb6:	91 81       	ldd	r25, Z+1	; 0x01
    3cb8:	28 17       	cp	r18, r24
    3cba:	39 07       	cpc	r19, r25
    3cbc:	e0 f4       	brcc	.+56     	; 0x3cf6 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    3cbe:	ec 81       	ldd	r30, Y+4	; 0x04
    3cc0:	fd 81       	ldd	r31, Y+5	; 0x05
    3cc2:	40 81       	ld	r20, Z
    3cc4:	51 81       	ldd	r21, Z+1	; 0x01
    3cc6:	ea 81       	ldd	r30, Y+2	; 0x02
    3cc8:	fb 81       	ldd	r31, Y+3	; 0x03
    3cca:	21 81       	ldd	r18, Z+1	; 0x01
    3ccc:	32 81       	ldd	r19, Z+2	; 0x02
    3cce:	80 91 08 03 	lds	r24, 0x0308
    3cd2:	90 91 09 03 	lds	r25, 0x0309
    3cd6:	b9 01       	movw	r22, r18
    3cd8:	68 1b       	sub	r22, r24
    3cda:	79 0b       	sbc	r23, r25
    3cdc:	cb 01       	movw	r24, r22
    3cde:	84 0f       	add	r24, r20
    3ce0:	95 1f       	adc	r25, r21
    3ce2:	ec 81       	ldd	r30, Y+4	; 0x04
    3ce4:	fd 81       	ldd	r31, Y+5	; 0x05
    3ce6:	91 83       	std	Z+1, r25	; 0x01
    3ce8:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    3cea:	8a 81       	ldd	r24, Y+2	; 0x02
    3cec:	9b 81       	ldd	r25, Y+3	; 0x03
    3cee:	0e 94 12 1e 	call	0x3c24	; 0x3c24 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    3cf2:	19 82       	std	Y+1, r1	; 0x01
    3cf4:	02 c0       	rjmp	.+4      	; 0x3cfa <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    3cf6:	81 e0       	ldi	r24, 0x01	; 1
    3cf8:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3cfa:	0f 90       	pop	r0
    3cfc:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3cfe:	89 81       	ldd	r24, Y+1	; 0x01
}
    3d00:	0f 90       	pop	r0
    3d02:	0f 90       	pop	r0
    3d04:	0f 90       	pop	r0
    3d06:	0f 90       	pop	r0
    3d08:	0f 90       	pop	r0
    3d0a:	cf 91       	pop	r28
    3d0c:	df 91       	pop	r29
    3d0e:	08 95       	ret

00003d10 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    3d10:	df 93       	push	r29
    3d12:	cf 93       	push	r28
    3d14:	cd b7       	in	r28, 0x3d	; 61
    3d16:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    3d18:	81 e0       	ldi	r24, 0x01	; 1
    3d1a:	80 93 0f 03 	sts	0x030F, r24
}
    3d1e:	cf 91       	pop	r28
    3d20:	df 91       	pop	r29
    3d22:	08 95       	ret

00003d24 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    3d24:	df 93       	push	r29
    3d26:	cf 93       	push	r28
    3d28:	00 d0       	rcall	.+0      	; 0x3d2a <prvIdleTask+0x6>
    3d2a:	cd b7       	in	r28, 0x3d	; 61
    3d2c:	de b7       	in	r29, 0x3e	; 62
    3d2e:	9a 83       	std	Y+2, r25	; 0x02
    3d30:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    3d32:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <prvCheckTasksWaitingTermination>
    3d36:	fd cf       	rjmp	.-6      	; 0x3d32 <prvIdleTask+0xe>

00003d38 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    3d38:	0f 93       	push	r16
    3d3a:	1f 93       	push	r17
    3d3c:	df 93       	push	r29
    3d3e:	cf 93       	push	r28
    3d40:	cd b7       	in	r28, 0x3d	; 61
    3d42:	de b7       	in	r29, 0x3e	; 62
    3d44:	29 97       	sbiw	r28, 0x09	; 9
    3d46:	0f b6       	in	r0, 0x3f	; 63
    3d48:	f8 94       	cli
    3d4a:	de bf       	out	0x3e, r29	; 62
    3d4c:	0f be       	out	0x3f, r0	; 63
    3d4e:	cd bf       	out	0x3d, r28	; 61
    3d50:	9a 83       	std	Y+2, r25	; 0x02
    3d52:	89 83       	std	Y+1, r24	; 0x01
    3d54:	7c 83       	std	Y+4, r23	; 0x04
    3d56:	6b 83       	std	Y+3, r22	; 0x03
    3d58:	4d 83       	std	Y+5, r20	; 0x05
    3d5a:	3f 83       	std	Y+7, r19	; 0x07
    3d5c:	2e 83       	std	Y+6, r18	; 0x06
    3d5e:	19 87       	std	Y+9, r17	; 0x09
    3d60:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    3d62:	89 81       	ldd	r24, Y+1	; 0x01
    3d64:	9a 81       	ldd	r25, Y+2	; 0x02
    3d66:	49 96       	adiw	r24, 0x19	; 25
    3d68:	2b 81       	ldd	r18, Y+3	; 0x03
    3d6a:	3c 81       	ldd	r19, Y+4	; 0x04
    3d6c:	b9 01       	movw	r22, r18
    3d6e:	48 e0       	ldi	r20, 0x08	; 8
    3d70:	50 e0       	ldi	r21, 0x00	; 0
    3d72:	0e 94 a5 20 	call	0x414a	; 0x414a <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    3d76:	e9 81       	ldd	r30, Y+1	; 0x01
    3d78:	fa 81       	ldd	r31, Y+2	; 0x02
    3d7a:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    3d7c:	8d 81       	ldd	r24, Y+5	; 0x05
    3d7e:	83 30       	cpi	r24, 0x03	; 3
    3d80:	10 f0       	brcs	.+4      	; 0x3d86 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    3d82:	82 e0       	ldi	r24, 0x02	; 2
    3d84:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    3d86:	e9 81       	ldd	r30, Y+1	; 0x01
    3d88:	fa 81       	ldd	r31, Y+2	; 0x02
    3d8a:	8d 81       	ldd	r24, Y+5	; 0x05
    3d8c:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    3d8e:	89 81       	ldd	r24, Y+1	; 0x01
    3d90:	9a 81       	ldd	r25, Y+2	; 0x02
    3d92:	02 96       	adiw	r24, 0x02	; 2
    3d94:	0e 94 ce 10 	call	0x219c	; 0x219c <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    3d98:	89 81       	ldd	r24, Y+1	; 0x01
    3d9a:	9a 81       	ldd	r25, Y+2	; 0x02
    3d9c:	0c 96       	adiw	r24, 0x0c	; 12
    3d9e:	0e 94 ce 10 	call	0x219c	; 0x219c <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    3da2:	e9 81       	ldd	r30, Y+1	; 0x01
    3da4:	fa 81       	ldd	r31, Y+2	; 0x02
    3da6:	89 81       	ldd	r24, Y+1	; 0x01
    3da8:	9a 81       	ldd	r25, Y+2	; 0x02
    3daa:	91 87       	std	Z+9, r25	; 0x09
    3dac:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    3dae:	8d 81       	ldd	r24, Y+5	; 0x05
    3db0:	28 2f       	mov	r18, r24
    3db2:	30 e0       	ldi	r19, 0x00	; 0
    3db4:	83 e0       	ldi	r24, 0x03	; 3
    3db6:	90 e0       	ldi	r25, 0x00	; 0
    3db8:	82 1b       	sub	r24, r18
    3dba:	93 0b       	sbc	r25, r19
    3dbc:	e9 81       	ldd	r30, Y+1	; 0x01
    3dbe:	fa 81       	ldd	r31, Y+2	; 0x02
    3dc0:	95 87       	std	Z+13, r25	; 0x0d
    3dc2:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    3dc4:	e9 81       	ldd	r30, Y+1	; 0x01
    3dc6:	fa 81       	ldd	r31, Y+2	; 0x02
    3dc8:	89 81       	ldd	r24, Y+1	; 0x01
    3dca:	9a 81       	ldd	r25, Y+2	; 0x02
    3dcc:	93 8b       	std	Z+19, r25	; 0x13
    3dce:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    3dd0:	29 96       	adiw	r28, 0x09	; 9
    3dd2:	0f b6       	in	r0, 0x3f	; 63
    3dd4:	f8 94       	cli
    3dd6:	de bf       	out	0x3e, r29	; 62
    3dd8:	0f be       	out	0x3f, r0	; 63
    3dda:	cd bf       	out	0x3d, r28	; 61
    3ddc:	cf 91       	pop	r28
    3dde:	df 91       	pop	r29
    3de0:	1f 91       	pop	r17
    3de2:	0f 91       	pop	r16
    3de4:	08 95       	ret

00003de6 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    3de6:	df 93       	push	r29
    3de8:	cf 93       	push	r28
    3dea:	0f 92       	push	r0
    3dec:	cd b7       	in	r28, 0x3d	; 61
    3dee:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    3df0:	19 82       	std	Y+1, r1	; 0x01
    3df2:	13 c0       	rjmp	.+38     	; 0x3e1a <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    3df4:	89 81       	ldd	r24, Y+1	; 0x01
    3df6:	28 2f       	mov	r18, r24
    3df8:	30 e0       	ldi	r19, 0x00	; 0
    3dfa:	c9 01       	movw	r24, r18
    3dfc:	88 0f       	add	r24, r24
    3dfe:	99 1f       	adc	r25, r25
    3e00:	88 0f       	add	r24, r24
    3e02:	99 1f       	adc	r25, r25
    3e04:	88 0f       	add	r24, r24
    3e06:	99 1f       	adc	r25, r25
    3e08:	82 0f       	add	r24, r18
    3e0a:	93 1f       	adc	r25, r19
    3e0c:	8e 5e       	subi	r24, 0xEE	; 238
    3e0e:	9c 4f       	sbci	r25, 0xFC	; 252
    3e10:	0e 94 a4 10 	call	0x2148	; 0x2148 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    3e14:	89 81       	ldd	r24, Y+1	; 0x01
    3e16:	8f 5f       	subi	r24, 0xFF	; 255
    3e18:	89 83       	std	Y+1, r24	; 0x01
    3e1a:	89 81       	ldd	r24, Y+1	; 0x01
    3e1c:	83 30       	cpi	r24, 0x03	; 3
    3e1e:	50 f3       	brcs	.-44     	; 0x3df4 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    3e20:	8d e2       	ldi	r24, 0x2D	; 45
    3e22:	93 e0       	ldi	r25, 0x03	; 3
    3e24:	0e 94 a4 10 	call	0x2148	; 0x2148 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    3e28:	86 e3       	ldi	r24, 0x36	; 54
    3e2a:	93 e0       	ldi	r25, 0x03	; 3
    3e2c:	0e 94 a4 10 	call	0x2148	; 0x2148 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    3e30:	83 e4       	ldi	r24, 0x43	; 67
    3e32:	93 e0       	ldi	r25, 0x03	; 3
    3e34:	0e 94 a4 10 	call	0x2148	; 0x2148 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    3e38:	8c e4       	ldi	r24, 0x4C	; 76
    3e3a:	93 e0       	ldi	r25, 0x03	; 3
    3e3c:	0e 94 a4 10 	call	0x2148	; 0x2148 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    3e40:	8d e2       	ldi	r24, 0x2D	; 45
    3e42:	93 e0       	ldi	r25, 0x03	; 3
    3e44:	90 93 40 03 	sts	0x0340, r25
    3e48:	80 93 3f 03 	sts	0x033F, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3e4c:	86 e3       	ldi	r24, 0x36	; 54
    3e4e:	93 e0       	ldi	r25, 0x03	; 3
    3e50:	90 93 42 03 	sts	0x0342, r25
    3e54:	80 93 41 03 	sts	0x0341, r24
}
    3e58:	0f 90       	pop	r0
    3e5a:	cf 91       	pop	r28
    3e5c:	df 91       	pop	r29
    3e5e:	08 95       	ret

00003e60 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    3e60:	df 93       	push	r29
    3e62:	cf 93       	push	r28
    3e64:	00 d0       	rcall	.+0      	; 0x3e66 <prvCheckTasksWaitingTermination+0x6>
    3e66:	0f 92       	push	r0
    3e68:	cd b7       	in	r28, 0x3d	; 61
    3e6a:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    3e6c:	80 91 06 03 	lds	r24, 0x0306
    3e70:	88 23       	and	r24, r24
    3e72:	71 f1       	breq	.+92     	; 0x3ed0 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    3e74:	0e 94 6e 1b 	call	0x36dc	; 0x36dc <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    3e78:	80 91 4c 03 	lds	r24, 0x034C
    3e7c:	1b 82       	std	Y+3, r1	; 0x03
    3e7e:	88 23       	and	r24, r24
    3e80:	11 f4       	brne	.+4      	; 0x3e86 <prvCheckTasksWaitingTermination+0x26>
    3e82:	81 e0       	ldi	r24, 0x01	; 1
    3e84:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    3e86:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    3e8a:	8b 81       	ldd	r24, Y+3	; 0x03
    3e8c:	88 23       	and	r24, r24
    3e8e:	01 f5       	brne	.+64     	; 0x3ed0 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    3e90:	0f b6       	in	r0, 0x3f	; 63
    3e92:	f8 94       	cli
    3e94:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    3e96:	e0 91 51 03 	lds	r30, 0x0351
    3e9a:	f0 91 52 03 	lds	r31, 0x0352
    3e9e:	86 81       	ldd	r24, Z+6	; 0x06
    3ea0:	97 81       	ldd	r25, Z+7	; 0x07
    3ea2:	9a 83       	std	Y+2, r25	; 0x02
    3ea4:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    3ea6:	89 81       	ldd	r24, Y+1	; 0x01
    3ea8:	9a 81       	ldd	r25, Y+2	; 0x02
    3eaa:	02 96       	adiw	r24, 0x02	; 2
    3eac:	0e 94 96 11 	call	0x232c	; 0x232c <vListRemove>
					--uxCurrentNumberOfTasks;
    3eb0:	80 91 07 03 	lds	r24, 0x0307
    3eb4:	81 50       	subi	r24, 0x01	; 1
    3eb6:	80 93 07 03 	sts	0x0307, r24
					--uxTasksDeleted;
    3eba:	80 91 06 03 	lds	r24, 0x0306
    3ebe:	81 50       	subi	r24, 0x01	; 1
    3ec0:	80 93 06 03 	sts	0x0306, r24
				}
				taskEXIT_CRITICAL();
    3ec4:	0f 90       	pop	r0
    3ec6:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    3ec8:	89 81       	ldd	r24, Y+1	; 0x01
    3eca:	9a 81       	ldd	r25, Y+2	; 0x02
    3ecc:	0e 94 07 20 	call	0x400e	; 0x400e <prvDeleteTCB>
			}
		}
	}
	#endif
}
    3ed0:	0f 90       	pop	r0
    3ed2:	0f 90       	pop	r0
    3ed4:	0f 90       	pop	r0
    3ed6:	cf 91       	pop	r28
    3ed8:	df 91       	pop	r29
    3eda:	08 95       	ret

00003edc <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    3edc:	df 93       	push	r29
    3ede:	cf 93       	push	r28
    3ee0:	00 d0       	rcall	.+0      	; 0x3ee2 <prvAddCurrentTaskToDelayedList+0x6>
    3ee2:	cd b7       	in	r28, 0x3d	; 61
    3ee4:	de b7       	in	r29, 0x3e	; 62
    3ee6:	9a 83       	std	Y+2, r25	; 0x02
    3ee8:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    3eea:	e0 91 04 03 	lds	r30, 0x0304
    3eee:	f0 91 05 03 	lds	r31, 0x0305
    3ef2:	89 81       	ldd	r24, Y+1	; 0x01
    3ef4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ef6:	93 83       	std	Z+3, r25	; 0x03
    3ef8:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    3efa:	20 91 08 03 	lds	r18, 0x0308
    3efe:	30 91 09 03 	lds	r19, 0x0309
    3f02:	89 81       	ldd	r24, Y+1	; 0x01
    3f04:	9a 81       	ldd	r25, Y+2	; 0x02
    3f06:	82 17       	cp	r24, r18
    3f08:	93 07       	cpc	r25, r19
    3f0a:	70 f4       	brcc	.+28     	; 0x3f28 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3f0c:	80 91 41 03 	lds	r24, 0x0341
    3f10:	90 91 42 03 	lds	r25, 0x0342
    3f14:	20 91 04 03 	lds	r18, 0x0304
    3f18:	30 91 05 03 	lds	r19, 0x0305
    3f1c:	2e 5f       	subi	r18, 0xFE	; 254
    3f1e:	3f 4f       	sbci	r19, 0xFF	; 255
    3f20:	b9 01       	movw	r22, r18
    3f22:	0e 94 2a 11 	call	0x2254	; 0x2254 <vListInsert>
    3f26:	1e c0       	rjmp	.+60     	; 0x3f64 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3f28:	40 91 3f 03 	lds	r20, 0x033F
    3f2c:	50 91 40 03 	lds	r21, 0x0340
    3f30:	80 91 04 03 	lds	r24, 0x0304
    3f34:	90 91 05 03 	lds	r25, 0x0305
    3f38:	9c 01       	movw	r18, r24
    3f3a:	2e 5f       	subi	r18, 0xFE	; 254
    3f3c:	3f 4f       	sbci	r19, 0xFF	; 255
    3f3e:	ca 01       	movw	r24, r20
    3f40:	b9 01       	movw	r22, r18
    3f42:	0e 94 2a 11 	call	0x2254	; 0x2254 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    3f46:	20 91 6d 00 	lds	r18, 0x006D
    3f4a:	30 91 6e 00 	lds	r19, 0x006E
    3f4e:	89 81       	ldd	r24, Y+1	; 0x01
    3f50:	9a 81       	ldd	r25, Y+2	; 0x02
    3f52:	82 17       	cp	r24, r18
    3f54:	93 07       	cpc	r25, r19
    3f56:	30 f4       	brcc	.+12     	; 0x3f64 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    3f58:	89 81       	ldd	r24, Y+1	; 0x01
    3f5a:	9a 81       	ldd	r25, Y+2	; 0x02
    3f5c:	90 93 6e 00 	sts	0x006E, r25
    3f60:	80 93 6d 00 	sts	0x006D, r24
		}
	}
}
    3f64:	0f 90       	pop	r0
    3f66:	0f 90       	pop	r0
    3f68:	cf 91       	pop	r28
    3f6a:	df 91       	pop	r29
    3f6c:	08 95       	ret

00003f6e <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    3f6e:	df 93       	push	r29
    3f70:	cf 93       	push	r28
    3f72:	cd b7       	in	r28, 0x3d	; 61
    3f74:	de b7       	in	r29, 0x3e	; 62
    3f76:	28 97       	sbiw	r28, 0x08	; 8
    3f78:	0f b6       	in	r0, 0x3f	; 63
    3f7a:	f8 94       	cli
    3f7c:	de bf       	out	0x3e, r29	; 62
    3f7e:	0f be       	out	0x3f, r0	; 63
    3f80:	cd bf       	out	0x3d, r28	; 61
    3f82:	9c 83       	std	Y+4, r25	; 0x04
    3f84:	8b 83       	std	Y+3, r24	; 0x03
    3f86:	7e 83       	std	Y+6, r23	; 0x06
    3f88:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    3f8a:	81 e2       	ldi	r24, 0x21	; 33
    3f8c:	90 e0       	ldi	r25, 0x00	; 0
    3f8e:	0e 94 38 10 	call	0x2070	; 0x2070 <pvPortMalloc>
    3f92:	9a 83       	std	Y+2, r25	; 0x02
    3f94:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    3f96:	89 81       	ldd	r24, Y+1	; 0x01
    3f98:	9a 81       	ldd	r25, Y+2	; 0x02
    3f9a:	00 97       	sbiw	r24, 0x00	; 0
    3f9c:	69 f1       	breq	.+90     	; 0x3ff8 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    3f9e:	8d 81       	ldd	r24, Y+5	; 0x05
    3fa0:	9e 81       	ldd	r25, Y+6	; 0x06
    3fa2:	00 97       	sbiw	r24, 0x00	; 0
    3fa4:	39 f4       	brne	.+14     	; 0x3fb4 <prvAllocateTCBAndStack+0x46>
    3fa6:	8b 81       	ldd	r24, Y+3	; 0x03
    3fa8:	9c 81       	ldd	r25, Y+4	; 0x04
    3faa:	0e 94 38 10 	call	0x2070	; 0x2070 <pvPortMalloc>
    3fae:	98 87       	std	Y+8, r25	; 0x08
    3fb0:	8f 83       	std	Y+7, r24	; 0x07
    3fb2:	04 c0       	rjmp	.+8      	; 0x3fbc <prvAllocateTCBAndStack+0x4e>
    3fb4:	8d 81       	ldd	r24, Y+5	; 0x05
    3fb6:	9e 81       	ldd	r25, Y+6	; 0x06
    3fb8:	98 87       	std	Y+8, r25	; 0x08
    3fba:	8f 83       	std	Y+7, r24	; 0x07
    3fbc:	e9 81       	ldd	r30, Y+1	; 0x01
    3fbe:	fa 81       	ldd	r31, Y+2	; 0x02
    3fc0:	8f 81       	ldd	r24, Y+7	; 0x07
    3fc2:	98 85       	ldd	r25, Y+8	; 0x08
    3fc4:	90 8f       	std	Z+24, r25	; 0x18
    3fc6:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    3fc8:	e9 81       	ldd	r30, Y+1	; 0x01
    3fca:	fa 81       	ldd	r31, Y+2	; 0x02
    3fcc:	87 89       	ldd	r24, Z+23	; 0x17
    3fce:	90 8d       	ldd	r25, Z+24	; 0x18
    3fd0:	00 97       	sbiw	r24, 0x00	; 0
    3fd2:	39 f4       	brne	.+14     	; 0x3fe2 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    3fd4:	89 81       	ldd	r24, Y+1	; 0x01
    3fd6:	9a 81       	ldd	r25, Y+2	; 0x02
    3fd8:	0e 94 7e 10 	call	0x20fc	; 0x20fc <vPortFree>
			pxNewTCB = NULL;
    3fdc:	1a 82       	std	Y+2, r1	; 0x02
    3fde:	19 82       	std	Y+1, r1	; 0x01
    3fe0:	0b c0       	rjmp	.+22     	; 0x3ff8 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    3fe2:	e9 81       	ldd	r30, Y+1	; 0x01
    3fe4:	fa 81       	ldd	r31, Y+2	; 0x02
    3fe6:	87 89       	ldd	r24, Z+23	; 0x17
    3fe8:	90 8d       	ldd	r25, Z+24	; 0x18
    3fea:	2b 81       	ldd	r18, Y+3	; 0x03
    3fec:	3c 81       	ldd	r19, Y+4	; 0x04
    3fee:	65 ea       	ldi	r22, 0xA5	; 165
    3ff0:	70 e0       	ldi	r23, 0x00	; 0
    3ff2:	a9 01       	movw	r20, r18
    3ff4:	0e 94 9e 20 	call	0x413c	; 0x413c <memset>
		}
	}

	return pxNewTCB;
    3ff8:	89 81       	ldd	r24, Y+1	; 0x01
    3ffa:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3ffc:	28 96       	adiw	r28, 0x08	; 8
    3ffe:	0f b6       	in	r0, 0x3f	; 63
    4000:	f8 94       	cli
    4002:	de bf       	out	0x3e, r29	; 62
    4004:	0f be       	out	0x3f, r0	; 63
    4006:	cd bf       	out	0x3d, r28	; 61
    4008:	cf 91       	pop	r28
    400a:	df 91       	pop	r29
    400c:	08 95       	ret

0000400e <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    400e:	df 93       	push	r29
    4010:	cf 93       	push	r28
    4012:	00 d0       	rcall	.+0      	; 0x4014 <prvDeleteTCB+0x6>
    4014:	cd b7       	in	r28, 0x3d	; 61
    4016:	de b7       	in	r29, 0x3e	; 62
    4018:	9a 83       	std	Y+2, r25	; 0x02
    401a:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    401c:	e9 81       	ldd	r30, Y+1	; 0x01
    401e:	fa 81       	ldd	r31, Y+2	; 0x02
    4020:	87 89       	ldd	r24, Z+23	; 0x17
    4022:	90 8d       	ldd	r25, Z+24	; 0x18
    4024:	0e 94 7e 10 	call	0x20fc	; 0x20fc <vPortFree>
		vPortFree( pxTCB );
    4028:	89 81       	ldd	r24, Y+1	; 0x01
    402a:	9a 81       	ldd	r25, Y+2	; 0x02
    402c:	0e 94 7e 10 	call	0x20fc	; 0x20fc <vPortFree>
	}
    4030:	0f 90       	pop	r0
    4032:	0f 90       	pop	r0
    4034:	cf 91       	pop	r28
    4036:	df 91       	pop	r29
    4038:	08 95       	ret

0000403a <__mulsi3>:
    403a:	62 9f       	mul	r22, r18
    403c:	d0 01       	movw	r26, r0
    403e:	73 9f       	mul	r23, r19
    4040:	f0 01       	movw	r30, r0
    4042:	82 9f       	mul	r24, r18
    4044:	e0 0d       	add	r30, r0
    4046:	f1 1d       	adc	r31, r1
    4048:	64 9f       	mul	r22, r20
    404a:	e0 0d       	add	r30, r0
    404c:	f1 1d       	adc	r31, r1
    404e:	92 9f       	mul	r25, r18
    4050:	f0 0d       	add	r31, r0
    4052:	83 9f       	mul	r24, r19
    4054:	f0 0d       	add	r31, r0
    4056:	74 9f       	mul	r23, r20
    4058:	f0 0d       	add	r31, r0
    405a:	65 9f       	mul	r22, r21
    405c:	f0 0d       	add	r31, r0
    405e:	99 27       	eor	r25, r25
    4060:	72 9f       	mul	r23, r18
    4062:	b0 0d       	add	r27, r0
    4064:	e1 1d       	adc	r30, r1
    4066:	f9 1f       	adc	r31, r25
    4068:	63 9f       	mul	r22, r19
    406a:	b0 0d       	add	r27, r0
    406c:	e1 1d       	adc	r30, r1
    406e:	f9 1f       	adc	r31, r25
    4070:	bd 01       	movw	r22, r26
    4072:	cf 01       	movw	r24, r30
    4074:	11 24       	eor	r1, r1
    4076:	08 95       	ret

00004078 <__udivmodsi4>:
    4078:	a1 e2       	ldi	r26, 0x21	; 33
    407a:	1a 2e       	mov	r1, r26
    407c:	aa 1b       	sub	r26, r26
    407e:	bb 1b       	sub	r27, r27
    4080:	fd 01       	movw	r30, r26
    4082:	0d c0       	rjmp	.+26     	; 0x409e <__udivmodsi4_ep>

00004084 <__udivmodsi4_loop>:
    4084:	aa 1f       	adc	r26, r26
    4086:	bb 1f       	adc	r27, r27
    4088:	ee 1f       	adc	r30, r30
    408a:	ff 1f       	adc	r31, r31
    408c:	a2 17       	cp	r26, r18
    408e:	b3 07       	cpc	r27, r19
    4090:	e4 07       	cpc	r30, r20
    4092:	f5 07       	cpc	r31, r21
    4094:	20 f0       	brcs	.+8      	; 0x409e <__udivmodsi4_ep>
    4096:	a2 1b       	sub	r26, r18
    4098:	b3 0b       	sbc	r27, r19
    409a:	e4 0b       	sbc	r30, r20
    409c:	f5 0b       	sbc	r31, r21

0000409e <__udivmodsi4_ep>:
    409e:	66 1f       	adc	r22, r22
    40a0:	77 1f       	adc	r23, r23
    40a2:	88 1f       	adc	r24, r24
    40a4:	99 1f       	adc	r25, r25
    40a6:	1a 94       	dec	r1
    40a8:	69 f7       	brne	.-38     	; 0x4084 <__udivmodsi4_loop>
    40aa:	60 95       	com	r22
    40ac:	70 95       	com	r23
    40ae:	80 95       	com	r24
    40b0:	90 95       	com	r25
    40b2:	9b 01       	movw	r18, r22
    40b4:	ac 01       	movw	r20, r24
    40b6:	bd 01       	movw	r22, r26
    40b8:	cf 01       	movw	r24, r30
    40ba:	08 95       	ret

000040bc <__prologue_saves__>:
    40bc:	2f 92       	push	r2
    40be:	3f 92       	push	r3
    40c0:	4f 92       	push	r4
    40c2:	5f 92       	push	r5
    40c4:	6f 92       	push	r6
    40c6:	7f 92       	push	r7
    40c8:	8f 92       	push	r8
    40ca:	9f 92       	push	r9
    40cc:	af 92       	push	r10
    40ce:	bf 92       	push	r11
    40d0:	cf 92       	push	r12
    40d2:	df 92       	push	r13
    40d4:	ef 92       	push	r14
    40d6:	ff 92       	push	r15
    40d8:	0f 93       	push	r16
    40da:	1f 93       	push	r17
    40dc:	cf 93       	push	r28
    40de:	df 93       	push	r29
    40e0:	cd b7       	in	r28, 0x3d	; 61
    40e2:	de b7       	in	r29, 0x3e	; 62
    40e4:	ca 1b       	sub	r28, r26
    40e6:	db 0b       	sbc	r29, r27
    40e8:	0f b6       	in	r0, 0x3f	; 63
    40ea:	f8 94       	cli
    40ec:	de bf       	out	0x3e, r29	; 62
    40ee:	0f be       	out	0x3f, r0	; 63
    40f0:	cd bf       	out	0x3d, r28	; 61
    40f2:	09 94       	ijmp

000040f4 <__epilogue_restores__>:
    40f4:	2a 88       	ldd	r2, Y+18	; 0x12
    40f6:	39 88       	ldd	r3, Y+17	; 0x11
    40f8:	48 88       	ldd	r4, Y+16	; 0x10
    40fa:	5f 84       	ldd	r5, Y+15	; 0x0f
    40fc:	6e 84       	ldd	r6, Y+14	; 0x0e
    40fe:	7d 84       	ldd	r7, Y+13	; 0x0d
    4100:	8c 84       	ldd	r8, Y+12	; 0x0c
    4102:	9b 84       	ldd	r9, Y+11	; 0x0b
    4104:	aa 84       	ldd	r10, Y+10	; 0x0a
    4106:	b9 84       	ldd	r11, Y+9	; 0x09
    4108:	c8 84       	ldd	r12, Y+8	; 0x08
    410a:	df 80       	ldd	r13, Y+7	; 0x07
    410c:	ee 80       	ldd	r14, Y+6	; 0x06
    410e:	fd 80       	ldd	r15, Y+5	; 0x05
    4110:	0c 81       	ldd	r16, Y+4	; 0x04
    4112:	1b 81       	ldd	r17, Y+3	; 0x03
    4114:	aa 81       	ldd	r26, Y+2	; 0x02
    4116:	b9 81       	ldd	r27, Y+1	; 0x01
    4118:	ce 0f       	add	r28, r30
    411a:	d1 1d       	adc	r29, r1
    411c:	0f b6       	in	r0, 0x3f	; 63
    411e:	f8 94       	cli
    4120:	de bf       	out	0x3e, r29	; 62
    4122:	0f be       	out	0x3f, r0	; 63
    4124:	cd bf       	out	0x3d, r28	; 61
    4126:	ed 01       	movw	r28, r26
    4128:	08 95       	ret

0000412a <memcpy>:
    412a:	fb 01       	movw	r30, r22
    412c:	dc 01       	movw	r26, r24
    412e:	02 c0       	rjmp	.+4      	; 0x4134 <memcpy+0xa>
    4130:	01 90       	ld	r0, Z+
    4132:	0d 92       	st	X+, r0
    4134:	41 50       	subi	r20, 0x01	; 1
    4136:	50 40       	sbci	r21, 0x00	; 0
    4138:	d8 f7       	brcc	.-10     	; 0x4130 <memcpy+0x6>
    413a:	08 95       	ret

0000413c <memset>:
    413c:	dc 01       	movw	r26, r24
    413e:	01 c0       	rjmp	.+2      	; 0x4142 <memset+0x6>
    4140:	6d 93       	st	X+, r22
    4142:	41 50       	subi	r20, 0x01	; 1
    4144:	50 40       	sbci	r21, 0x00	; 0
    4146:	e0 f7       	brcc	.-8      	; 0x4140 <memset+0x4>
    4148:	08 95       	ret

0000414a <strncpy>:
    414a:	fb 01       	movw	r30, r22
    414c:	dc 01       	movw	r26, r24
    414e:	41 50       	subi	r20, 0x01	; 1
    4150:	50 40       	sbci	r21, 0x00	; 0
    4152:	48 f0       	brcs	.+18     	; 0x4166 <strncpy+0x1c>
    4154:	01 90       	ld	r0, Z+
    4156:	0d 92       	st	X+, r0
    4158:	00 20       	and	r0, r0
    415a:	c9 f7       	brne	.-14     	; 0x414e <strncpy+0x4>
    415c:	01 c0       	rjmp	.+2      	; 0x4160 <strncpy+0x16>
    415e:	1d 92       	st	X+, r1
    4160:	41 50       	subi	r20, 0x01	; 1
    4162:	50 40       	sbci	r21, 0x00	; 0
    4164:	e0 f7       	brcc	.-8      	; 0x415e <strncpy+0x14>
    4166:	08 95       	ret

00004168 <_exit>:
    4168:	f8 94       	cli

0000416a <__stop_program>:
    416a:	ff cf       	rjmp	.-2      	; 0x416a <__stop_program>
