
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000177c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00800060  0000177c  00001810  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002e9  00800068  00800068  00001818  2**0
                  ALLOC
  3 .stab         00005658  00000000  00000000  00001818  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000323c  00000000  00000000  00006e70  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000a0ac  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000a0c0  2**2
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 66 04 	jmp	0x8cc	; 0x8cc <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec e7       	ldi	r30, 0x7C	; 124
      68:	f7 e1       	ldi	r31, 0x17	; 23
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a8 36       	cpi	r26, 0x68	; 104
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	23 e0       	ldi	r18, 0x03	; 3
      78:	a8 e6       	ldi	r26, 0x68	; 104
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a1 35       	cpi	r26, 0x51	; 81
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 55 0b 	call	0x16aa	; 0x16aa <main>
      8a:	0c 94 bc 0b 	jmp	0x1778	; 0x1778 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Blink_1500ms_task>:
// 		vTaskDelay(1000); //OS Delay
// 	}
// }
// //---------------------------------------------
void Blink_1500ms_task( void *pvParameters)
{u8 lReceivedValue;
      92:	cf 93       	push	r28
      94:	df 93       	push	r29
      96:	1f 92       	push	r1
      98:	cd b7       	in	r28, 0x3d	; 61
      9a:	de b7       	in	r29, 0x3e	; 62
u8 xStatus;
//const u8 xTicksToWait = pdMS_TO_TICKS( 100 );
	DDRA |=(1<<0); //PA.0 is output
      9c:	d0 9a       	sbi	0x1a, 0	; 26

	while(1)
	{xStatus = xQueueReceive( xQueue, &lReceivedValue, 50 );
     uart_send_char(lReceivedValue);
		PORTA ^= (1<<0); //toggle PA.0
      9e:	11 e0       	ldi	r17, 0x01	; 1
u8 xStatus;
//const u8 xTicksToWait = pdMS_TO_TICKS( 100 );
	DDRA |=(1<<0); //PA.0 is output

	while(1)
	{xStatus = xQueueReceive( xQueue, &lReceivedValue, 50 );
      a0:	20 e0       	ldi	r18, 0x00	; 0
      a2:	42 e3       	ldi	r20, 0x32	; 50
      a4:	50 e0       	ldi	r21, 0x00	; 0
      a6:	be 01       	movw	r22, r28
      a8:	6f 5f       	subi	r22, 0xFF	; 255
      aa:	7f 4f       	sbci	r23, 0xFF	; 255
      ac:	80 91 4f 03 	lds	r24, 0x034F
      b0:	90 91 50 03 	lds	r25, 0x0350
      b4:	0e 94 08 06 	call	0xc10	; 0xc10 <xQueueGenericReceive>
     uart_send_char(lReceivedValue);
      b8:	89 81       	ldd	r24, Y+1	; 0x01
      ba:	90 e0       	ldi	r25, 0x00	; 0
      bc:	0e 94 4d 0b 	call	0x169a	; 0x169a <uart_send_char>
		PORTA ^= (1<<0); //toggle PA.0
      c0:	8b b3       	in	r24, 0x1b	; 27
      c2:	81 27       	eor	r24, r17
      c4:	8b bb       	out	0x1b, r24	; 27
		vTaskDelay(1500); //OS Delay
      c6:	8c ed       	ldi	r24, 0xDC	; 220
      c8:	95 e0       	ldi	r25, 0x05	; 5
      ca:	0e 94 0f 0a 	call	0x141e	; 0x141e <vTaskDelay>
	}
      ce:	e8 cf       	rjmp	.-48     	; 0xa0 <Blink_1500ms_task+0xe>

000000d0 <Blink_2000ms_task>:
}
//--------------------------------------------------
void Blink_2000ms_task( void *pvParameters)
{u8 xStatus;
      d0:	cf 93       	push	r28
      d2:	df 93       	push	r29
      d4:	1f 92       	push	r1
      d6:	cd b7       	in	r28, 0x3d	; 61
      d8:	de b7       	in	r29, 0x3e	; 62
 u8	lValueToSend='a';
      da:	81 e6       	ldi	r24, 0x61	; 97
      dc:	89 83       	std	Y+1, r24	; 0x01
	DDRA |=(1<<0); //PB.0 is output
      de:	d0 9a       	sbi	0x1a, 0	; 26
	
	while(1)
	{xStatus = xQueueSendToBack( xQueue, &lValueToSend, 0 );
		
		PORTA ^= (1<<0); //toggle PB.0
      e0:	11 e0       	ldi	r17, 0x01	; 1
{u8 xStatus;
 u8	lValueToSend='a';
	DDRA |=(1<<0); //PB.0 is output
	
	while(1)
	{xStatus = xQueueSendToBack( xQueue, &lValueToSend, 0 );
      e2:	20 e0       	ldi	r18, 0x00	; 0
      e4:	40 e0       	ldi	r20, 0x00	; 0
      e6:	50 e0       	ldi	r21, 0x00	; 0
      e8:	be 01       	movw	r22, r28
      ea:	6f 5f       	subi	r22, 0xFF	; 255
      ec:	7f 4f       	sbci	r23, 0xFF	; 255
      ee:	80 91 4f 03 	lds	r24, 0x034F
      f2:	90 91 50 03 	lds	r25, 0x0350
      f6:	0e 94 4c 05 	call	0xa98	; 0xa98 <xQueueGenericSend>
		
		PORTA ^= (1<<0); //toggle PB.0
      fa:	8b b3       	in	r24, 0x1b	; 27
      fc:	81 27       	eor	r24, r17
      fe:	8b bb       	out	0x1b, r24	; 27
		vTaskDelay(2000); //OS Delay
     100:	80 ed       	ldi	r24, 0xD0	; 208
     102:	97 e0       	ldi	r25, 0x07	; 7
     104:	0e 94 0f 0a 	call	0x141e	; 0x141e <vTaskDelay>
	}
     108:	ec cf       	rjmp	.-40     	; 0xe2 <Blink_2000ms_task+0x12>

0000010a <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     10a:	cf 92       	push	r12
     10c:	df 92       	push	r13
     10e:	ef 92       	push	r14
     110:	ff 92       	push	r15
     112:	1f 93       	push	r17
     114:	cf 93       	push	r28
     116:	df 93       	push	r29
     118:	6c 01       	movw	r12, r24
     11a:	16 2f       	mov	r17, r22
     11c:	f4 2e       	mov	r15, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     11e:	8a e1       	ldi	r24, 0x1A	; 26
     120:	90 e0       	ldi	r25, 0x00	; 0
     122:	0e 94 4b 02 	call	0x496	; 0x496 <pvPortMalloc>
     126:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
     128:	89 2b       	or	r24, r25
     12a:	09 f4       	brne	.+2      	; 0x12e <xCoRoutineCreate+0x24>
     12c:	57 c0       	rjmp	.+174    	; 0x1dc <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     12e:	80 91 68 00 	lds	r24, 0x0068
     132:	90 91 69 00 	lds	r25, 0x0069
     136:	89 2b       	or	r24, r25
     138:	21 f5       	brne	.+72     	; 0x182 <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     13a:	d0 93 69 00 	sts	0x0069, r29
     13e:	c0 93 68 00 	sts	0x0068, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     142:	80 e9       	ldi	r24, 0x90	; 144
     144:	90 e0       	ldi	r25, 0x00	; 0
     146:	0e 94 80 02 	call	0x500	; 0x500 <vListInitialise>
     14a:	89 e9       	ldi	r24, 0x99	; 153
     14c:	90 e0       	ldi	r25, 0x00	; 0
     14e:	0e 94 80 02 	call	0x500	; 0x500 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     152:	87 e8       	ldi	r24, 0x87	; 135
     154:	90 e0       	ldi	r25, 0x00	; 0
     156:	0e 94 80 02 	call	0x500	; 0x500 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     15a:	8e e7       	ldi	r24, 0x7E	; 126
     15c:	90 e0       	ldi	r25, 0x00	; 0
     15e:	0e 94 80 02 	call	0x500	; 0x500 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     162:	81 e7       	ldi	r24, 0x71	; 113
     164:	90 e0       	ldi	r25, 0x00	; 0
     166:	0e 94 80 02 	call	0x500	; 0x500 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     16a:	87 e8       	ldi	r24, 0x87	; 135
     16c:	90 e0       	ldi	r25, 0x00	; 0
     16e:	90 93 7d 00 	sts	0x007D, r25
     172:	80 93 7c 00 	sts	0x007C, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     176:	8e e7       	ldi	r24, 0x7E	; 126
     178:	90 e0       	ldi	r25, 0x00	; 0
     17a:	90 93 7b 00 	sts	0x007B, r25
     17e:	80 93 7a 00 	sts	0x007A, r24
     182:	11 11       	cpse	r17, r1
     184:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     186:	19 8e       	std	Y+25, r1	; 0x19
     188:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     18a:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     18c:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     18e:	fe 01       	movw	r30, r28
     190:	c1 92       	st	Z+, r12
     192:	d1 92       	st	Z+, r13
     194:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     196:	cf 01       	movw	r24, r30
     198:	0e 94 8e 02 	call	0x51c	; 0x51c <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     19c:	ce 01       	movw	r24, r28
     19e:	0c 96       	adiw	r24, 0x0c	; 12
     1a0:	0e 94 8e 02 	call	0x51c	; 0x51c <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     1a4:	d9 87       	std	Y+9, r29	; 0x09
     1a6:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     1a8:	db 8b       	std	Y+19, r29	; 0x13
     1aa:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     1ac:	83 e0       	ldi	r24, 0x03	; 3
     1ae:	90 e0       	ldi	r25, 0x00	; 0
     1b0:	81 1b       	sub	r24, r17
     1b2:	91 09       	sbc	r25, r1
     1b4:	9d 87       	std	Y+13, r25	; 0x0d
     1b6:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     1b8:	9e 89       	ldd	r25, Y+22	; 0x16
     1ba:	80 91 70 00 	lds	r24, 0x0070
     1be:	89 17       	cp	r24, r25
     1c0:	10 f4       	brcc	.+4      	; 0x1c6 <xCoRoutineCreate+0xbc>
     1c2:	90 93 70 00 	sts	0x0070, r25
     1c6:	f9 e0       	ldi	r31, 0x09	; 9
     1c8:	9f 9f       	mul	r25, r31
     1ca:	c0 01       	movw	r24, r0
     1cc:	11 24       	eor	r1, r1
     1ce:	b7 01       	movw	r22, r14
     1d0:	80 57       	subi	r24, 0x70	; 112
     1d2:	9f 4f       	sbci	r25, 0xFF	; 255
     1d4:	0e 94 92 02 	call	0x524	; 0x524 <vListInsertEnd>

		xReturn = pdPASS;
     1d8:	81 e0       	ldi	r24, 0x01	; 1
     1da:	01 c0       	rjmp	.+2      	; 0x1de <xCoRoutineCreate+0xd4>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     1dc:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
     1de:	df 91       	pop	r29
     1e0:	cf 91       	pop	r28
     1e2:	1f 91       	pop	r17
     1e4:	ff 90       	pop	r15
     1e6:	ef 90       	pop	r14
     1e8:	df 90       	pop	r13
     1ea:	cf 90       	pop	r12
     1ec:	08 95       	ret

000001ee <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     1ee:	0f 93       	push	r16
     1f0:	1f 93       	push	r17
     1f2:	cf 93       	push	r28
     1f4:	df 93       	push	r29
     1f6:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     1f8:	c0 91 6e 00 	lds	r28, 0x006E
     1fc:	d0 91 6f 00 	lds	r29, 0x006F
     200:	c8 0f       	add	r28, r24
     202:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     204:	80 91 68 00 	lds	r24, 0x0068
     208:	90 91 69 00 	lds	r25, 0x0069
     20c:	02 96       	adiw	r24, 0x02	; 2
     20e:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     212:	e0 91 68 00 	lds	r30, 0x0068
     216:	f0 91 69 00 	lds	r31, 0x0069
     21a:	d3 83       	std	Z+3, r29	; 0x03
     21c:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     21e:	80 91 6e 00 	lds	r24, 0x006E
     222:	90 91 6f 00 	lds	r25, 0x006F
     226:	bf 01       	movw	r22, r30
     228:	6e 5f       	subi	r22, 0xFE	; 254
     22a:	7f 4f       	sbci	r23, 0xFF	; 255
     22c:	c8 17       	cp	r28, r24
     22e:	d9 07       	cpc	r29, r25
     230:	28 f4       	brcc	.+10     	; 0x23c <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     232:	80 91 7a 00 	lds	r24, 0x007A
     236:	90 91 7b 00 	lds	r25, 0x007B
     23a:	04 c0       	rjmp	.+8      	; 0x244 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     23c:	80 91 7c 00 	lds	r24, 0x007C
     240:	90 91 7d 00 	lds	r25, 0x007D
     244:	0e 94 b5 02 	call	0x56a	; 0x56a <vListInsert>
	}

	if( pxEventList )
     248:	01 15       	cp	r16, r1
     24a:	11 05       	cpc	r17, r1
     24c:	69 f0       	breq	.+26     	; 0x268 <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     24e:	60 91 68 00 	lds	r22, 0x0068
     252:	70 91 69 00 	lds	r23, 0x0069
     256:	64 5f       	subi	r22, 0xF4	; 244
     258:	7f 4f       	sbci	r23, 0xFF	; 255
     25a:	c8 01       	movw	r24, r16
	}
}
     25c:	df 91       	pop	r29
     25e:	cf 91       	pop	r28
     260:	1f 91       	pop	r17
     262:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     264:	0c 94 b5 02 	jmp	0x56a	; 0x56a <vListInsert>
	}
}
     268:	df 91       	pop	r29
     26a:	cf 91       	pop	r28
     26c:	1f 91       	pop	r17
     26e:	0f 91       	pop	r16
     270:	08 95       	ret

00000272 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     272:	ff 92       	push	r15
     274:	0f 93       	push	r16
     276:	1f 93       	push	r17
     278:	cf 93       	push	r28
     27a:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     27c:	99 e0       	ldi	r25, 0x09	; 9
     27e:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     280:	80 91 71 00 	lds	r24, 0x0071
     284:	88 23       	and	r24, r24
     286:	11 f1       	breq	.+68     	; 0x2cc <vCoRoutineSchedule+0x5a>
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     288:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     28a:	e0 91 76 00 	lds	r30, 0x0076
     28e:	f0 91 77 00 	lds	r31, 0x0077
     292:	c6 81       	ldd	r28, Z+6	; 0x06
     294:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     296:	ce 01       	movw	r24, r28
     298:	0c 96       	adiw	r24, 0x0c	; 12
     29a:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     29e:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     2a0:	8e 01       	movw	r16, r28
     2a2:	0e 5f       	subi	r16, 0xFE	; 254
     2a4:	1f 4f       	sbci	r17, 0xFF	; 255
     2a6:	c8 01       	movw	r24, r16
     2a8:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     2ac:	9e 89       	ldd	r25, Y+22	; 0x16
     2ae:	80 91 70 00 	lds	r24, 0x0070
     2b2:	89 17       	cp	r24, r25
     2b4:	10 f4       	brcc	.+4      	; 0x2ba <vCoRoutineSchedule+0x48>
     2b6:	90 93 70 00 	sts	0x0070, r25
     2ba:	f9 9e       	mul	r15, r25
     2bc:	c0 01       	movw	r24, r0
     2be:	11 24       	eor	r1, r1
     2c0:	b8 01       	movw	r22, r16
     2c2:	80 57       	subi	r24, 0x70	; 112
     2c4:	9f 4f       	sbci	r25, 0xFF	; 255
     2c6:	0e 94 92 02 	call	0x524	; 0x524 <vListInsertEnd>
     2ca:	da cf       	rjmp	.-76     	; 0x280 <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     2cc:	0e 94 af 08 	call	0x115e	; 0x115e <xTaskGetTickCount>
     2d0:	20 91 6c 00 	lds	r18, 0x006C
     2d4:	30 91 6d 00 	lds	r19, 0x006D
     2d8:	82 1b       	sub	r24, r18
     2da:	93 0b       	sbc	r25, r19
     2dc:	90 93 6b 00 	sts	0x006B, r25
     2e0:	80 93 6a 00 	sts	0x006A, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     2e4:	89 e0       	ldi	r24, 0x09	; 9
     2e6:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     2e8:	20 91 6a 00 	lds	r18, 0x006A
     2ec:	30 91 6b 00 	lds	r19, 0x006B
     2f0:	80 91 6e 00 	lds	r24, 0x006E
     2f4:	90 91 6f 00 	lds	r25, 0x006F
     2f8:	21 15       	cp	r18, r1
     2fa:	31 05       	cpc	r19, r1
     2fc:	09 f4       	brne	.+2      	; 0x300 <vCoRoutineSchedule+0x8e>
     2fe:	54 c0       	rjmp	.+168    	; 0x3a8 <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
     300:	01 96       	adiw	r24, 0x01	; 1
     302:	90 93 6f 00 	sts	0x006F, r25
     306:	80 93 6e 00 	sts	0x006E, r24
		xPassedTicks--;
     30a:	21 50       	subi	r18, 0x01	; 1
     30c:	31 09       	sbc	r19, r1
     30e:	30 93 6b 00 	sts	0x006B, r19
     312:	20 93 6a 00 	sts	0x006A, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     316:	89 2b       	or	r24, r25
     318:	09 f0       	breq	.+2      	; 0x31c <vCoRoutineSchedule+0xaa>
     31a:	3e c0       	rjmp	.+124    	; 0x398 <vCoRoutineSchedule+0x126>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     31c:	80 91 7c 00 	lds	r24, 0x007C
     320:	90 91 7d 00 	lds	r25, 0x007D
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     324:	20 91 7a 00 	lds	r18, 0x007A
     328:	30 91 7b 00 	lds	r19, 0x007B
     32c:	30 93 7d 00 	sts	0x007D, r19
     330:	20 93 7c 00 	sts	0x007C, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
     334:	90 93 7b 00 	sts	0x007B, r25
     338:	80 93 7a 00 	sts	0x007A, r24
     33c:	2d c0       	rjmp	.+90     	; 0x398 <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     33e:	05 80       	ldd	r0, Z+5	; 0x05
     340:	f6 81       	ldd	r31, Z+6	; 0x06
     342:	e0 2d       	mov	r30, r0
     344:	c6 81       	ldd	r28, Z+6	; 0x06
     346:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     348:	20 91 6e 00 	lds	r18, 0x006E
     34c:	30 91 6f 00 	lds	r19, 0x006F
     350:	8a 81       	ldd	r24, Y+2	; 0x02
     352:	9b 81       	ldd	r25, Y+3	; 0x03
     354:	28 17       	cp	r18, r24
     356:	39 07       	cpc	r19, r25
     358:	38 f2       	brcs	.-114    	; 0x2e8 <vCoRoutineSchedule+0x76>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     35a:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     35c:	8e 01       	movw	r16, r28
     35e:	0e 5f       	subi	r16, 0xFE	; 254
     360:	1f 4f       	sbci	r17, 0xFF	; 255
     362:	c8 01       	movw	r24, r16
     364:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     368:	8c 89       	ldd	r24, Y+20	; 0x14
     36a:	9d 89       	ldd	r25, Y+21	; 0x15
     36c:	89 2b       	or	r24, r25
     36e:	21 f0       	breq	.+8      	; 0x378 <vCoRoutineSchedule+0x106>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     370:	ce 01       	movw	r24, r28
     372:	0c 96       	adiw	r24, 0x0c	; 12
     374:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     378:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     37a:	9e 89       	ldd	r25, Y+22	; 0x16
     37c:	80 91 70 00 	lds	r24, 0x0070
     380:	89 17       	cp	r24, r25
     382:	10 f4       	brcc	.+4      	; 0x388 <vCoRoutineSchedule+0x116>
     384:	90 93 70 00 	sts	0x0070, r25
     388:	f9 9e       	mul	r15, r25
     38a:	c0 01       	movw	r24, r0
     38c:	11 24       	eor	r1, r1
     38e:	b8 01       	movw	r22, r16
     390:	80 57       	subi	r24, 0x70	; 112
     392:	9f 4f       	sbci	r25, 0xFF	; 255
     394:	0e 94 92 02 	call	0x524	; 0x524 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     398:	e0 91 7c 00 	lds	r30, 0x007C
     39c:	f0 91 7d 00 	lds	r31, 0x007D
     3a0:	80 81       	ld	r24, Z
     3a2:	81 11       	cpse	r24, r1
     3a4:	cc cf       	rjmp	.-104    	; 0x33e <vCoRoutineSchedule+0xcc>
     3a6:	a0 cf       	rjmp	.-192    	; 0x2e8 <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     3a8:	90 93 6d 00 	sts	0x006D, r25
     3ac:	80 93 6c 00 	sts	0x006C, r24
     3b0:	80 91 70 00 	lds	r24, 0x0070

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     3b4:	69 e0       	ldi	r22, 0x09	; 9
     3b6:	48 2f       	mov	r20, r24
     3b8:	50 e0       	ldi	r21, 0x00	; 0
     3ba:	64 9f       	mul	r22, r20
     3bc:	90 01       	movw	r18, r0
     3be:	65 9f       	mul	r22, r21
     3c0:	30 0d       	add	r19, r0
     3c2:	11 24       	eor	r1, r1
     3c4:	f9 01       	movw	r30, r18
     3c6:	e0 57       	subi	r30, 0x70	; 112
     3c8:	ff 4f       	sbci	r31, 0xFF	; 255
     3ca:	90 81       	ld	r25, Z
     3cc:	91 11       	cpse	r25, r1
     3ce:	0c c0       	rjmp	.+24     	; 0x3e8 <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     3d0:	81 11       	cpse	r24, r1
     3d2:	08 c0       	rjmp	.+16     	; 0x3e4 <vCoRoutineSchedule+0x172>
     3d4:	10 92 70 00 	sts	0x0070, r1

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
     3d8:	df 91       	pop	r29
     3da:	cf 91       	pop	r28
     3dc:	1f 91       	pop	r17
     3de:	0f 91       	pop	r16
     3e0:	ff 90       	pop	r15
     3e2:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     3e4:	81 50       	subi	r24, 0x01	; 1
     3e6:	e7 cf       	rjmp	.-50     	; 0x3b6 <vCoRoutineSchedule+0x144>
     3e8:	80 93 70 00 	sts	0x0070, r24
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     3ec:	a1 81       	ldd	r26, Z+1	; 0x01
     3ee:	b2 81       	ldd	r27, Z+2	; 0x02
     3f0:	12 96       	adiw	r26, 0x02	; 2
     3f2:	0d 90       	ld	r0, X+
     3f4:	bc 91       	ld	r27, X
     3f6:	a0 2d       	mov	r26, r0
     3f8:	b2 83       	std	Z+2, r27	; 0x02
     3fa:	a1 83       	std	Z+1, r26	; 0x01
     3fc:	2d 56       	subi	r18, 0x6D	; 109
     3fe:	3f 4f       	sbci	r19, 0xFF	; 255
     400:	a2 17       	cp	r26, r18
     402:	b3 07       	cpc	r27, r19
     404:	31 f4       	brne	.+12     	; 0x412 <vCoRoutineSchedule+0x1a0>
     406:	12 96       	adiw	r26, 0x02	; 2
     408:	8d 91       	ld	r24, X+
     40a:	9c 91       	ld	r25, X
     40c:	13 97       	sbiw	r26, 0x03	; 3
     40e:	92 83       	std	Z+2, r25	; 0x02
     410:	81 83       	std	Z+1, r24	; 0x01
     412:	89 e0       	ldi	r24, 0x09	; 9
     414:	84 9f       	mul	r24, r20
     416:	f0 01       	movw	r30, r0
     418:	85 9f       	mul	r24, r21
     41a:	f0 0d       	add	r31, r0
     41c:	11 24       	eor	r1, r1
     41e:	e0 57       	subi	r30, 0x70	; 112
     420:	ff 4f       	sbci	r31, 0xFF	; 255
     422:	01 80       	ldd	r0, Z+1	; 0x01
     424:	f2 81       	ldd	r31, Z+2	; 0x02
     426:	e0 2d       	mov	r30, r0
     428:	86 81       	ldd	r24, Z+6	; 0x06
     42a:	97 81       	ldd	r25, Z+7	; 0x07
     42c:	90 93 69 00 	sts	0x0069, r25
     430:	80 93 68 00 	sts	0x0068, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     434:	dc 01       	movw	r26, r24
     436:	ed 91       	ld	r30, X+
     438:	fc 91       	ld	r31, X
     43a:	11 97       	sbiw	r26, 0x01	; 1
     43c:	57 96       	adiw	r26, 0x17	; 23
     43e:	6c 91       	ld	r22, X

	return;
}
     440:	df 91       	pop	r29
     442:	cf 91       	pop	r28
     444:	1f 91       	pop	r17
     446:	0f 91       	pop	r16
     448:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     44a:	09 94       	ijmp

0000044c <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     44c:	0f 93       	push	r16
     44e:	1f 93       	push	r17
     450:	cf 93       	push	r28
     452:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     454:	dc 01       	movw	r26, r24
     456:	15 96       	adiw	r26, 0x05	; 5
     458:	ed 91       	ld	r30, X+
     45a:	fc 91       	ld	r31, X
     45c:	16 97       	sbiw	r26, 0x06	; 6
     45e:	c6 81       	ldd	r28, Z+6	; 0x06
     460:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     462:	8e 01       	movw	r16, r28
     464:	04 5f       	subi	r16, 0xF4	; 244
     466:	1f 4f       	sbci	r17, 0xFF	; 255
     468:	c8 01       	movw	r24, r16
     46a:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     46e:	b8 01       	movw	r22, r16
     470:	81 e7       	ldi	r24, 0x71	; 113
     472:	90 e0       	ldi	r25, 0x00	; 0
     474:	0e 94 92 02 	call	0x524	; 0x524 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     478:	e0 91 68 00 	lds	r30, 0x0068
     47c:	f0 91 69 00 	lds	r31, 0x0069
     480:	81 e0       	ldi	r24, 0x01	; 1
     482:	2e 89       	ldd	r18, Y+22	; 0x16
     484:	96 89       	ldd	r25, Z+22	; 0x16
     486:	29 17       	cp	r18, r25
     488:	08 f4       	brcc	.+2      	; 0x48c <xCoRoutineRemoveFromEventList+0x40>
     48a:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     48c:	df 91       	pop	r29
     48e:	cf 91       	pop	r28
     490:	1f 91       	pop	r17
     492:	0f 91       	pop	r16
     494:	08 95       	ret

00000496 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     496:	0f 93       	push	r16
     498:	1f 93       	push	r17
     49a:	cf 93       	push	r28
     49c:	df 93       	push	r29
     49e:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     4a0:	0e 94 a9 08 	call	0x1152	; 0x1152 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     4a4:	c0 91 a2 00 	lds	r28, 0x00A2
     4a8:	d0 91 a3 00 	lds	r29, 0x00A3
     4ac:	c8 01       	movw	r24, r16
     4ae:	8c 0f       	add	r24, r28
     4b0:	9d 1f       	adc	r25, r29
     4b2:	88 35       	cpi	r24, 0x58	; 88
     4b4:	22 e0       	ldi	r18, 0x02	; 2
     4b6:	92 07       	cpc	r25, r18
     4b8:	50 f4       	brcc	.+20     	; 0x4ce <pvPortMalloc+0x38>
     4ba:	c8 17       	cp	r28, r24
     4bc:	d9 07       	cpc	r29, r25
     4be:	38 f4       	brcc	.+14     	; 0x4ce <pvPortMalloc+0x38>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     4c0:	cc 55       	subi	r28, 0x5C	; 92
     4c2:	df 4f       	sbci	r29, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
     4c4:	90 93 a3 00 	sts	0x00A3, r25
     4c8:	80 93 a2 00 	sts	0x00A2, r24
     4cc:	02 c0       	rjmp	.+4      	; 0x4d2 <pvPortMalloc+0x3c>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     4ce:	c0 e0       	ldi	r28, 0x00	; 0
     4d0:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     4d2:	0e 94 60 09 	call	0x12c0	; 0x12c0 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     4d6:	ce 01       	movw	r24, r28
     4d8:	df 91       	pop	r29
     4da:	cf 91       	pop	r28
     4dc:	1f 91       	pop	r17
     4de:	0f 91       	pop	r16
     4e0:	08 95       	ret

000004e2 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     4e2:	08 95       	ret

000004e4 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     4e4:	10 92 a3 00 	sts	0x00A3, r1
     4e8:	10 92 a2 00 	sts	0x00A2, r1
     4ec:	08 95       	ret

000004ee <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     4ee:	20 91 a2 00 	lds	r18, 0x00A2
     4f2:	30 91 a3 00 	lds	r19, 0x00A3
}
     4f6:	88 e5       	ldi	r24, 0x58	; 88
     4f8:	92 e0       	ldi	r25, 0x02	; 2
     4fa:	82 1b       	sub	r24, r18
     4fc:	93 0b       	sbc	r25, r19
     4fe:	08 95       	ret

00000500 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     500:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     502:	03 96       	adiw	r24, 0x03	; 3
     504:	92 83       	std	Z+2, r25	; 0x02
     506:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     508:	2f ef       	ldi	r18, 0xFF	; 255
     50a:	3f ef       	ldi	r19, 0xFF	; 255
     50c:	34 83       	std	Z+4, r19	; 0x04
     50e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     510:	96 83       	std	Z+6, r25	; 0x06
     512:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     514:	90 87       	std	Z+8, r25	; 0x08
     516:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     518:	10 82       	st	Z, r1
     51a:	08 95       	ret

0000051c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     51c:	fc 01       	movw	r30, r24
     51e:	11 86       	std	Z+9, r1	; 0x09
     520:	10 86       	std	Z+8, r1	; 0x08
     522:	08 95       	ret

00000524 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     524:	cf 93       	push	r28
     526:	df 93       	push	r29
     528:	dc 01       	movw	r26, r24
     52a:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     52c:	11 96       	adiw	r26, 0x01	; 1
     52e:	2d 91       	ld	r18, X+
     530:	3c 91       	ld	r19, X
     532:	12 97       	sbiw	r26, 0x02	; 2

	pxNewListItem->pxNext = pxIndex->pxNext;
     534:	e9 01       	movw	r28, r18
     536:	8a 81       	ldd	r24, Y+2	; 0x02
     538:	9b 81       	ldd	r25, Y+3	; 0x03
     53a:	93 83       	std	Z+3, r25	; 0x03
     53c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     53e:	35 83       	std	Z+5, r19	; 0x05
     540:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     542:	8a 81       	ldd	r24, Y+2	; 0x02
     544:	9b 81       	ldd	r25, Y+3	; 0x03
     546:	ec 01       	movw	r28, r24
     548:	7d 83       	std	Y+5, r23	; 0x05
     54a:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     54c:	e9 01       	movw	r28, r18
     54e:	7b 83       	std	Y+3, r23	; 0x03
     550:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     552:	12 96       	adiw	r26, 0x02	; 2
     554:	7c 93       	st	X, r23
     556:	6e 93       	st	-X, r22
     558:	11 97       	sbiw	r26, 0x01	; 1

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     55a:	b1 87       	std	Z+9, r27	; 0x09
     55c:	a0 87       	std	Z+8, r26	; 0x08

	( pxList->uxNumberOfItems )++;
     55e:	8c 91       	ld	r24, X
     560:	8f 5f       	subi	r24, 0xFF	; 255
     562:	8c 93       	st	X, r24
}
     564:	df 91       	pop	r29
     566:	cf 91       	pop	r28
     568:	08 95       	ret

0000056a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     56a:	cf 93       	push	r28
     56c:	df 93       	push	r29
     56e:	ac 01       	movw	r20, r24
     570:	db 01       	movw	r26, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     572:	8d 91       	ld	r24, X+
     574:	9c 91       	ld	r25, X
     576:	11 97       	sbiw	r26, 0x01	; 1
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     578:	8f 3f       	cpi	r24, 0xFF	; 255
     57a:	2f ef       	ldi	r18, 0xFF	; 255
     57c:	92 07       	cpc	r25, r18
     57e:	21 f4       	brne	.+8      	; 0x588 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     580:	ea 01       	movw	r28, r20
     582:	ef 81       	ldd	r30, Y+7	; 0x07
     584:	f8 85       	ldd	r31, Y+8	; 0x08
     586:	0e c0       	rjmp	.+28     	; 0x5a4 <vListInsert+0x3a>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     588:	fa 01       	movw	r30, r20
     58a:	33 96       	adiw	r30, 0x03	; 3
     58c:	22 81       	ldd	r18, Z+2	; 0x02
     58e:	33 81       	ldd	r19, Z+3	; 0x03
     590:	e9 01       	movw	r28, r18
     592:	28 81       	ld	r18, Y
     594:	39 81       	ldd	r19, Y+1	; 0x01
     596:	82 17       	cp	r24, r18
     598:	93 07       	cpc	r25, r19
     59a:	20 f0       	brcs	.+8      	; 0x5a4 <vListInsert+0x3a>
     59c:	02 80       	ldd	r0, Z+2	; 0x02
     59e:	f3 81       	ldd	r31, Z+3	; 0x03
     5a0:	e0 2d       	mov	r30, r0
     5a2:	f4 cf       	rjmp	.-24     	; 0x58c <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     5a4:	82 81       	ldd	r24, Z+2	; 0x02
     5a6:	93 81       	ldd	r25, Z+3	; 0x03
     5a8:	13 96       	adiw	r26, 0x03	; 3
     5aa:	9c 93       	st	X, r25
     5ac:	8e 93       	st	-X, r24
     5ae:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     5b0:	ec 01       	movw	r28, r24
     5b2:	bd 83       	std	Y+5, r27	; 0x05
     5b4:	ac 83       	std	Y+4, r26	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     5b6:	15 96       	adiw	r26, 0x05	; 5
     5b8:	fc 93       	st	X, r31
     5ba:	ee 93       	st	-X, r30
     5bc:	14 97       	sbiw	r26, 0x04	; 4
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     5be:	b3 83       	std	Z+3, r27	; 0x03
     5c0:	a2 83       	std	Z+2, r26	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     5c2:	19 96       	adiw	r26, 0x09	; 9
     5c4:	5c 93       	st	X, r21
     5c6:	4e 93       	st	-X, r20
     5c8:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     5ca:	fa 01       	movw	r30, r20
     5cc:	80 81       	ld	r24, Z
     5ce:	8f 5f       	subi	r24, 0xFF	; 255
     5d0:	80 83       	st	Z, r24
}
     5d2:	df 91       	pop	r29
     5d4:	cf 91       	pop	r28
     5d6:	08 95       	ret

000005d8 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     5d8:	cf 93       	push	r28
     5da:	df 93       	push	r29
     5dc:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     5de:	a2 81       	ldd	r26, Z+2	; 0x02
     5e0:	b3 81       	ldd	r27, Z+3	; 0x03
     5e2:	84 81       	ldd	r24, Z+4	; 0x04
     5e4:	95 81       	ldd	r25, Z+5	; 0x05
     5e6:	15 96       	adiw	r26, 0x05	; 5
     5e8:	9c 93       	st	X, r25
     5ea:	8e 93       	st	-X, r24
     5ec:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     5ee:	c4 81       	ldd	r28, Z+4	; 0x04
     5f0:	d5 81       	ldd	r29, Z+5	; 0x05
     5f2:	bb 83       	std	Y+3, r27	; 0x03
     5f4:	aa 83       	std	Y+2, r26	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     5f6:	a0 85       	ldd	r26, Z+8	; 0x08
     5f8:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     5fa:	11 96       	adiw	r26, 0x01	; 1
     5fc:	8d 91       	ld	r24, X+
     5fe:	9c 91       	ld	r25, X
     600:	12 97       	sbiw	r26, 0x02	; 2
     602:	8e 17       	cp	r24, r30
     604:	9f 07       	cpc	r25, r31
     606:	21 f4       	brne	.+8      	; 0x610 <vListRemove+0x38>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     608:	12 96       	adiw	r26, 0x02	; 2
     60a:	dc 93       	st	X, r29
     60c:	ce 93       	st	-X, r28
     60e:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     610:	11 86       	std	Z+9, r1	; 0x09
     612:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     614:	8c 91       	ld	r24, X
     616:	81 50       	subi	r24, 0x01	; 1
     618:	8c 93       	st	X, r24
}
     61a:	df 91       	pop	r29
     61c:	cf 91       	pop	r28
     61e:	08 95       	ret

00000620 <pxPortInitialiseStack>:
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     620:	31 e1       	ldi	r19, 0x11	; 17
     622:	fc 01       	movw	r30, r24
     624:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     626:	31 97       	sbiw	r30, 0x01	; 1
     628:	22 e2       	ldi	r18, 0x22	; 34
     62a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     62c:	31 97       	sbiw	r30, 0x01	; 1
     62e:	a3 e3       	ldi	r26, 0x33	; 51
     630:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     632:	31 97       	sbiw	r30, 0x01	; 1
     634:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     636:	31 97       	sbiw	r30, 0x01	; 1
     638:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     63a:	31 97       	sbiw	r30, 0x01	; 1
     63c:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     63e:	31 97       	sbiw	r30, 0x01	; 1
     640:	60 e8       	ldi	r22, 0x80	; 128
     642:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     644:	31 97       	sbiw	r30, 0x01	; 1
     646:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     648:	31 97       	sbiw	r30, 0x01	; 1
     64a:	62 e0       	ldi	r22, 0x02	; 2
     64c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     64e:	31 97       	sbiw	r30, 0x01	; 1
     650:	63 e0       	ldi	r22, 0x03	; 3
     652:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     654:	31 97       	sbiw	r30, 0x01	; 1
     656:	64 e0       	ldi	r22, 0x04	; 4
     658:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     65a:	31 97       	sbiw	r30, 0x01	; 1
     65c:	65 e0       	ldi	r22, 0x05	; 5
     65e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     660:	31 97       	sbiw	r30, 0x01	; 1
     662:	66 e0       	ldi	r22, 0x06	; 6
     664:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     666:	31 97       	sbiw	r30, 0x01	; 1
     668:	67 e0       	ldi	r22, 0x07	; 7
     66a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     66c:	31 97       	sbiw	r30, 0x01	; 1
     66e:	68 e0       	ldi	r22, 0x08	; 8
     670:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     672:	31 97       	sbiw	r30, 0x01	; 1
     674:	69 e0       	ldi	r22, 0x09	; 9
     676:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     678:	31 97       	sbiw	r30, 0x01	; 1
     67a:	60 e1       	ldi	r22, 0x10	; 16
     67c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     67e:	31 97       	sbiw	r30, 0x01	; 1
     680:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     682:	31 97       	sbiw	r30, 0x01	; 1
     684:	32 e1       	ldi	r19, 0x12	; 18
     686:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     688:	31 97       	sbiw	r30, 0x01	; 1
     68a:	33 e1       	ldi	r19, 0x13	; 19
     68c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     68e:	31 97       	sbiw	r30, 0x01	; 1
     690:	34 e1       	ldi	r19, 0x14	; 20
     692:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     694:	31 97       	sbiw	r30, 0x01	; 1
     696:	35 e1       	ldi	r19, 0x15	; 21
     698:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     69a:	31 97       	sbiw	r30, 0x01	; 1
     69c:	36 e1       	ldi	r19, 0x16	; 22
     69e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     6a0:	31 97       	sbiw	r30, 0x01	; 1
     6a2:	37 e1       	ldi	r19, 0x17	; 23
     6a4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     6a6:	31 97       	sbiw	r30, 0x01	; 1
     6a8:	38 e1       	ldi	r19, 0x18	; 24
     6aa:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     6ac:	31 97       	sbiw	r30, 0x01	; 1
     6ae:	39 e1       	ldi	r19, 0x19	; 25
     6b0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     6b2:	31 97       	sbiw	r30, 0x01	; 1
     6b4:	30 e2       	ldi	r19, 0x20	; 32
     6b6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     6b8:	31 97       	sbiw	r30, 0x01	; 1
     6ba:	31 e2       	ldi	r19, 0x21	; 33
     6bc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     6be:	31 97       	sbiw	r30, 0x01	; 1
     6c0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     6c2:	31 97       	sbiw	r30, 0x01	; 1
     6c4:	23 e2       	ldi	r18, 0x23	; 35
     6c6:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     6c8:	31 97       	sbiw	r30, 0x01	; 1
     6ca:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     6cc:	31 97       	sbiw	r30, 0x01	; 1
     6ce:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     6d0:	31 97       	sbiw	r30, 0x01	; 1
     6d2:	26 e2       	ldi	r18, 0x26	; 38
     6d4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     6d6:	31 97       	sbiw	r30, 0x01	; 1
     6d8:	27 e2       	ldi	r18, 0x27	; 39
     6da:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     6dc:	31 97       	sbiw	r30, 0x01	; 1
     6de:	28 e2       	ldi	r18, 0x28	; 40
     6e0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     6e2:	31 97       	sbiw	r30, 0x01	; 1
     6e4:	29 e2       	ldi	r18, 0x29	; 41
     6e6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     6e8:	31 97       	sbiw	r30, 0x01	; 1
     6ea:	20 e3       	ldi	r18, 0x30	; 48
     6ec:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     6ee:	31 97       	sbiw	r30, 0x01	; 1
     6f0:	21 e3       	ldi	r18, 0x31	; 49
     6f2:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     6f4:	86 97       	sbiw	r24, 0x26	; 38
     6f6:	08 95       	ret

000006f8 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
     6f8:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
     6fa:	8a eb       	ldi	r24, 0xBA	; 186
     6fc:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     6fe:	8b e0       	ldi	r24, 0x0B	; 11
     700:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     702:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     704:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     706:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     708:	a0 91 fc 02 	lds	r26, 0x02FC
     70c:	b0 91 fd 02 	lds	r27, 0x02FD
     710:	cd 91       	ld	r28, X+
     712:	cd bf       	out	0x3d, r28	; 61
     714:	dd 91       	ld	r29, X+
     716:	de bf       	out	0x3e, r29	; 62
     718:	ff 91       	pop	r31
     71a:	ef 91       	pop	r30
     71c:	df 91       	pop	r29
     71e:	cf 91       	pop	r28
     720:	bf 91       	pop	r27
     722:	af 91       	pop	r26
     724:	9f 91       	pop	r25
     726:	8f 91       	pop	r24
     728:	7f 91       	pop	r23
     72a:	6f 91       	pop	r22
     72c:	5f 91       	pop	r21
     72e:	4f 91       	pop	r20
     730:	3f 91       	pop	r19
     732:	2f 91       	pop	r18
     734:	1f 91       	pop	r17
     736:	0f 91       	pop	r16
     738:	ff 90       	pop	r15
     73a:	ef 90       	pop	r14
     73c:	df 90       	pop	r13
     73e:	cf 90       	pop	r12
     740:	bf 90       	pop	r11
     742:	af 90       	pop	r10
     744:	9f 90       	pop	r9
     746:	8f 90       	pop	r8
     748:	7f 90       	pop	r7
     74a:	6f 90       	pop	r6
     74c:	5f 90       	pop	r5
     74e:	4f 90       	pop	r4
     750:	3f 90       	pop	r3
     752:	2f 90       	pop	r2
     754:	1f 90       	pop	r1
     756:	0f 90       	pop	r0
     758:	0f be       	out	0x3f, r0	; 63
     75a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     75c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     75e:	81 e0       	ldi	r24, 0x01	; 1
     760:	08 95       	ret

00000762 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     762:	08 95       	ret

00000764 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     764:	0f 92       	push	r0
     766:	0f b6       	in	r0, 0x3f	; 63
     768:	f8 94       	cli
     76a:	0f 92       	push	r0
     76c:	1f 92       	push	r1
     76e:	11 24       	eor	r1, r1
     770:	2f 92       	push	r2
     772:	3f 92       	push	r3
     774:	4f 92       	push	r4
     776:	5f 92       	push	r5
     778:	6f 92       	push	r6
     77a:	7f 92       	push	r7
     77c:	8f 92       	push	r8
     77e:	9f 92       	push	r9
     780:	af 92       	push	r10
     782:	bf 92       	push	r11
     784:	cf 92       	push	r12
     786:	df 92       	push	r13
     788:	ef 92       	push	r14
     78a:	ff 92       	push	r15
     78c:	0f 93       	push	r16
     78e:	1f 93       	push	r17
     790:	2f 93       	push	r18
     792:	3f 93       	push	r19
     794:	4f 93       	push	r20
     796:	5f 93       	push	r21
     798:	6f 93       	push	r22
     79a:	7f 93       	push	r23
     79c:	8f 93       	push	r24
     79e:	9f 93       	push	r25
     7a0:	af 93       	push	r26
     7a2:	bf 93       	push	r27
     7a4:	cf 93       	push	r28
     7a6:	df 93       	push	r29
     7a8:	ef 93       	push	r30
     7aa:	ff 93       	push	r31
     7ac:	a0 91 fc 02 	lds	r26, 0x02FC
     7b0:	b0 91 fd 02 	lds	r27, 0x02FD
     7b4:	0d b6       	in	r0, 0x3d	; 61
     7b6:	0d 92       	st	X+, r0
     7b8:	0e b6       	in	r0, 0x3e	; 62
     7ba:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     7bc:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     7c0:	a0 91 fc 02 	lds	r26, 0x02FC
     7c4:	b0 91 fd 02 	lds	r27, 0x02FD
     7c8:	cd 91       	ld	r28, X+
     7ca:	cd bf       	out	0x3d, r28	; 61
     7cc:	dd 91       	ld	r29, X+
     7ce:	de bf       	out	0x3e, r29	; 62
     7d0:	ff 91       	pop	r31
     7d2:	ef 91       	pop	r30
     7d4:	df 91       	pop	r29
     7d6:	cf 91       	pop	r28
     7d8:	bf 91       	pop	r27
     7da:	af 91       	pop	r26
     7dc:	9f 91       	pop	r25
     7de:	8f 91       	pop	r24
     7e0:	7f 91       	pop	r23
     7e2:	6f 91       	pop	r22
     7e4:	5f 91       	pop	r21
     7e6:	4f 91       	pop	r20
     7e8:	3f 91       	pop	r19
     7ea:	2f 91       	pop	r18
     7ec:	1f 91       	pop	r17
     7ee:	0f 91       	pop	r16
     7f0:	ff 90       	pop	r15
     7f2:	ef 90       	pop	r14
     7f4:	df 90       	pop	r13
     7f6:	cf 90       	pop	r12
     7f8:	bf 90       	pop	r11
     7fa:	af 90       	pop	r10
     7fc:	9f 90       	pop	r9
     7fe:	8f 90       	pop	r8
     800:	7f 90       	pop	r7
     802:	6f 90       	pop	r6
     804:	5f 90       	pop	r5
     806:	4f 90       	pop	r4
     808:	3f 90       	pop	r3
     80a:	2f 90       	pop	r2
     80c:	1f 90       	pop	r1
     80e:	0f 90       	pop	r0
     810:	0f be       	out	0x3f, r0	; 63
     812:	0f 90       	pop	r0

	asm volatile ( "ret" );
     814:	08 95       	ret

00000816 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     816:	0f 92       	push	r0
     818:	0f b6       	in	r0, 0x3f	; 63
     81a:	f8 94       	cli
     81c:	0f 92       	push	r0
     81e:	1f 92       	push	r1
     820:	11 24       	eor	r1, r1
     822:	2f 92       	push	r2
     824:	3f 92       	push	r3
     826:	4f 92       	push	r4
     828:	5f 92       	push	r5
     82a:	6f 92       	push	r6
     82c:	7f 92       	push	r7
     82e:	8f 92       	push	r8
     830:	9f 92       	push	r9
     832:	af 92       	push	r10
     834:	bf 92       	push	r11
     836:	cf 92       	push	r12
     838:	df 92       	push	r13
     83a:	ef 92       	push	r14
     83c:	ff 92       	push	r15
     83e:	0f 93       	push	r16
     840:	1f 93       	push	r17
     842:	2f 93       	push	r18
     844:	3f 93       	push	r19
     846:	4f 93       	push	r20
     848:	5f 93       	push	r21
     84a:	6f 93       	push	r22
     84c:	7f 93       	push	r23
     84e:	8f 93       	push	r24
     850:	9f 93       	push	r25
     852:	af 93       	push	r26
     854:	bf 93       	push	r27
     856:	cf 93       	push	r28
     858:	df 93       	push	r29
     85a:	ef 93       	push	r30
     85c:	ff 93       	push	r31
     85e:	a0 91 fc 02 	lds	r26, 0x02FC
     862:	b0 91 fd 02 	lds	r27, 0x02FD
     866:	0d b6       	in	r0, 0x3d	; 61
     868:	0d 92       	st	X+, r0
     86a:	0e b6       	in	r0, 0x3e	; 62
     86c:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     86e:	0e 94 c1 08 	call	0x1182	; 0x1182 <vTaskIncrementTick>
	vTaskSwitchContext();
     872:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     876:	a0 91 fc 02 	lds	r26, 0x02FC
     87a:	b0 91 fd 02 	lds	r27, 0x02FD
     87e:	cd 91       	ld	r28, X+
     880:	cd bf       	out	0x3d, r28	; 61
     882:	dd 91       	ld	r29, X+
     884:	de bf       	out	0x3e, r29	; 62
     886:	ff 91       	pop	r31
     888:	ef 91       	pop	r30
     88a:	df 91       	pop	r29
     88c:	cf 91       	pop	r28
     88e:	bf 91       	pop	r27
     890:	af 91       	pop	r26
     892:	9f 91       	pop	r25
     894:	8f 91       	pop	r24
     896:	7f 91       	pop	r23
     898:	6f 91       	pop	r22
     89a:	5f 91       	pop	r21
     89c:	4f 91       	pop	r20
     89e:	3f 91       	pop	r19
     8a0:	2f 91       	pop	r18
     8a2:	1f 91       	pop	r17
     8a4:	0f 91       	pop	r16
     8a6:	ff 90       	pop	r15
     8a8:	ef 90       	pop	r14
     8aa:	df 90       	pop	r13
     8ac:	cf 90       	pop	r12
     8ae:	bf 90       	pop	r11
     8b0:	af 90       	pop	r10
     8b2:	9f 90       	pop	r9
     8b4:	8f 90       	pop	r8
     8b6:	7f 90       	pop	r7
     8b8:	6f 90       	pop	r6
     8ba:	5f 90       	pop	r5
     8bc:	4f 90       	pop	r4
     8be:	3f 90       	pop	r3
     8c0:	2f 90       	pop	r2
     8c2:	1f 90       	pop	r1
     8c4:	0f 90       	pop	r0
     8c6:	0f be       	out	0x3f, r0	; 63
     8c8:	0f 90       	pop	r0

	asm volatile ( "ret" );
     8ca:	08 95       	ret

000008cc <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void  TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void  TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     8cc:	0e 94 0b 04 	call	0x816	; 0x816 <vPortYieldFromTick>
		asm volatile ( "reti" );
     8d0:	18 95       	reti

000008d2 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     8d2:	cf 93       	push	r28
     8d4:	df 93       	push	r29
     8d6:	ec 01       	movw	r28, r24
     8d8:	94 2f       	mov	r25, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     8da:	8c 8d       	ldd	r24, Y+28	; 0x1c
     8dc:	88 23       	and	r24, r24
     8de:	99 f1       	breq	.+102    	; 0x946 <prvCopyDataToQueue+0x74>
     8e0:	48 2f       	mov	r20, r24
     8e2:	50 e0       	ldi	r21, 0x00	; 0
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     8e4:	91 11       	cpse	r25, r1
     8e6:	15 c0       	rjmp	.+42     	; 0x912 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     8e8:	8c 81       	ldd	r24, Y+4	; 0x04
     8ea:	9d 81       	ldd	r25, Y+5	; 0x05
     8ec:	0e 94 9d 0b 	call	0x173a	; 0x173a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     8f0:	2c 8d       	ldd	r18, Y+28	; 0x1c
     8f2:	8c 81       	ldd	r24, Y+4	; 0x04
     8f4:	9d 81       	ldd	r25, Y+5	; 0x05
     8f6:	82 0f       	add	r24, r18
     8f8:	91 1d       	adc	r25, r1
     8fa:	9d 83       	std	Y+5, r25	; 0x05
     8fc:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     8fe:	2a 81       	ldd	r18, Y+2	; 0x02
     900:	3b 81       	ldd	r19, Y+3	; 0x03
     902:	82 17       	cp	r24, r18
     904:	93 07       	cpc	r25, r19
     906:	f8 f0       	brcs	.+62     	; 0x946 <prvCopyDataToQueue+0x74>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     908:	88 81       	ld	r24, Y
     90a:	99 81       	ldd	r25, Y+1	; 0x01
     90c:	9d 83       	std	Y+5, r25	; 0x05
     90e:	8c 83       	std	Y+4, r24	; 0x04
     910:	1a c0       	rjmp	.+52     	; 0x946 <prvCopyDataToQueue+0x74>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     912:	8e 81       	ldd	r24, Y+6	; 0x06
     914:	9f 81       	ldd	r25, Y+7	; 0x07
     916:	0e 94 9d 0b 	call	0x173a	; 0x173a <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     91a:	8c 8d       	ldd	r24, Y+28	; 0x1c
     91c:	90 e0       	ldi	r25, 0x00	; 0
     91e:	91 95       	neg	r25
     920:	81 95       	neg	r24
     922:	91 09       	sbc	r25, r1
     924:	2e 81       	ldd	r18, Y+6	; 0x06
     926:	3f 81       	ldd	r19, Y+7	; 0x07
     928:	28 0f       	add	r18, r24
     92a:	39 1f       	adc	r19, r25
     92c:	3f 83       	std	Y+7, r19	; 0x07
     92e:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     930:	48 81       	ld	r20, Y
     932:	59 81       	ldd	r21, Y+1	; 0x01
     934:	24 17       	cp	r18, r20
     936:	35 07       	cpc	r19, r21
     938:	30 f4       	brcc	.+12     	; 0x946 <prvCopyDataToQueue+0x74>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     93a:	2a 81       	ldd	r18, Y+2	; 0x02
     93c:	3b 81       	ldd	r19, Y+3	; 0x03
     93e:	82 0f       	add	r24, r18
     940:	93 1f       	adc	r25, r19
     942:	9f 83       	std	Y+7, r25	; 0x07
     944:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     946:	8a 8d       	ldd	r24, Y+26	; 0x1a
     948:	8f 5f       	subi	r24, 0xFF	; 255
     94a:	8a 8f       	std	Y+26, r24	; 0x1a
}
     94c:	df 91       	pop	r29
     94e:	cf 91       	pop	r28
     950:	08 95       	ret

00000952 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
     952:	fc 01       	movw	r30, r24
     954:	cb 01       	movw	r24, r22
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     956:	a0 81       	ld	r26, Z
     958:	b1 81       	ldd	r27, Z+1	; 0x01
     95a:	10 97       	sbiw	r26, 0x00	; 0
     95c:	99 f0       	breq	.+38     	; 0x984 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     95e:	44 8d       	ldd	r20, Z+28	; 0x1c
     960:	50 e0       	ldi	r21, 0x00	; 0
     962:	26 81       	ldd	r18, Z+6	; 0x06
     964:	37 81       	ldd	r19, Z+7	; 0x07
     966:	24 0f       	add	r18, r20
     968:	35 1f       	adc	r19, r21
     96a:	37 83       	std	Z+7, r19	; 0x07
     96c:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     96e:	62 81       	ldd	r22, Z+2	; 0x02
     970:	73 81       	ldd	r23, Z+3	; 0x03
     972:	26 17       	cp	r18, r22
     974:	37 07       	cpc	r19, r23
     976:	10 f0       	brcs	.+4      	; 0x97c <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     978:	b7 83       	std	Z+7, r27	; 0x07
     97a:	a6 83       	std	Z+6, r26	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     97c:	66 81       	ldd	r22, Z+6	; 0x06
     97e:	77 81       	ldd	r23, Z+7	; 0x07
     980:	0c 94 9d 0b 	jmp	0x173a	; 0x173a <memcpy>
     984:	08 95       	ret

00000986 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     986:	0f 93       	push	r16
     988:	1f 93       	push	r17
     98a:	cf 93       	push	r28
     98c:	df 93       	push	r29
     98e:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     990:	0f b6       	in	r0, 0x3f	; 63
     992:	f8 94       	cli
     994:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     996:	8c 01       	movw	r16, r24
     998:	0f 5e       	subi	r16, 0xEF	; 239
     99a:	1f 4f       	sbci	r17, 0xFF	; 255
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     99c:	9e 8d       	ldd	r25, Y+30	; 0x1e
     99e:	19 16       	cp	r1, r25
     9a0:	6c f4       	brge	.+26     	; 0x9bc <prvUnlockQueue+0x36>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     9a2:	89 89       	ldd	r24, Y+17	; 0x11
     9a4:	88 23       	and	r24, r24
     9a6:	51 f0       	breq	.+20     	; 0x9bc <prvUnlockQueue+0x36>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     9a8:	c8 01       	movw	r24, r16
     9aa:	0e 94 c4 0a 	call	0x1588	; 0x1588 <xTaskRemoveFromEventList>
     9ae:	81 11       	cpse	r24, r1
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     9b0:	0e 94 3f 0b 	call	0x167e	; 0x167e <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     9b4:	9e 8d       	ldd	r25, Y+30	; 0x1e
     9b6:	91 50       	subi	r25, 0x01	; 1
     9b8:	9e 8f       	std	Y+30, r25	; 0x1e
     9ba:	f0 cf       	rjmp	.-32     	; 0x99c <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     9bc:	8f ef       	ldi	r24, 0xFF	; 255
     9be:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     9c0:	0f 90       	pop	r0
     9c2:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     9c4:	0f b6       	in	r0, 0x3f	; 63
     9c6:	f8 94       	cli
     9c8:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     9ca:	8e 01       	movw	r16, r28
     9cc:	08 5f       	subi	r16, 0xF8	; 248
     9ce:	1f 4f       	sbci	r17, 0xFF	; 255
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     9d0:	9d 8d       	ldd	r25, Y+29	; 0x1d
     9d2:	19 16       	cp	r1, r25
     9d4:	6c f4       	brge	.+26     	; 0x9f0 <prvUnlockQueue+0x6a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     9d6:	88 85       	ldd	r24, Y+8	; 0x08
     9d8:	88 23       	and	r24, r24
     9da:	51 f0       	breq	.+20     	; 0x9f0 <prvUnlockQueue+0x6a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     9dc:	c8 01       	movw	r24, r16
     9de:	0e 94 c4 0a 	call	0x1588	; 0x1588 <xTaskRemoveFromEventList>
     9e2:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     9e4:	0e 94 3f 0b 	call	0x167e	; 0x167e <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     9e8:	9d 8d       	ldd	r25, Y+29	; 0x1d
     9ea:	91 50       	subi	r25, 0x01	; 1
     9ec:	9d 8f       	std	Y+29, r25	; 0x1d
     9ee:	f0 cf       	rjmp	.-32     	; 0x9d0 <prvUnlockQueue+0x4a>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     9f0:	8f ef       	ldi	r24, 0xFF	; 255
     9f2:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     9f4:	0f 90       	pop	r0
     9f6:	0f be       	out	0x3f, r0	; 63
}
     9f8:	df 91       	pop	r29
     9fa:	cf 91       	pop	r28
     9fc:	1f 91       	pop	r17
     9fe:	0f 91       	pop	r16
     a00:	08 95       	ret

00000a02 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
     a02:	cf 92       	push	r12
     a04:	df 92       	push	r13
     a06:	ef 92       	push	r14
     a08:	ff 92       	push	r15
     a0a:	0f 93       	push	r16
     a0c:	1f 93       	push	r17
     a0e:	cf 93       	push	r28
     a10:	df 93       	push	r29
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     a12:	88 23       	and	r24, r24
     a14:	a9 f1       	breq	.+106    	; 0xa80 <xQueueCreate+0x7e>
     a16:	f6 2e       	mov	r15, r22
     a18:	e8 2e       	mov	r14, r24
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     a1a:	8f e1       	ldi	r24, 0x1F	; 31
     a1c:	90 e0       	ldi	r25, 0x00	; 0
     a1e:	0e 94 4b 02 	call	0x496	; 0x496 <pvPortMalloc>
     a22:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     a24:	89 2b       	or	r24, r25
     a26:	61 f1       	breq	.+88     	; 0xa80 <xQueueCreate+0x7e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     a28:	cf 2c       	mov	r12, r15
     a2a:	d1 2c       	mov	r13, r1
     a2c:	ef 9c       	mul	r14, r15
     a2e:	80 01       	movw	r16, r0
     a30:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     a32:	c8 01       	movw	r24, r16
     a34:	01 96       	adiw	r24, 0x01	; 1
     a36:	0e 94 4b 02 	call	0x496	; 0x496 <pvPortMalloc>
     a3a:	99 83       	std	Y+1, r25	; 0x01
     a3c:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
     a3e:	00 97       	sbiw	r24, 0x00	; 0
     a40:	e1 f0       	breq	.+56     	; 0xa7a <xQueueCreate+0x78>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
     a42:	9c 01       	movw	r18, r24
     a44:	20 0f       	add	r18, r16
     a46:	31 1f       	adc	r19, r17
     a48:	3b 83       	std	Y+3, r19	; 0x03
     a4a:	2a 83       	std	Y+2, r18	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     a4c:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
     a4e:	9d 83       	std	Y+5, r25	; 0x05
     a50:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
     a52:	0c 19       	sub	r16, r12
     a54:	1d 09       	sbc	r17, r13
     a56:	08 0f       	add	r16, r24
     a58:	19 1f       	adc	r17, r25
     a5a:	1f 83       	std	Y+7, r17	; 0x07
     a5c:	0e 83       	std	Y+6, r16	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
     a5e:	eb 8e       	std	Y+27, r14	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     a60:	fc 8e       	std	Y+28, r15	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
     a62:	8f ef       	ldi	r24, 0xFF	; 255
     a64:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
     a66:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
     a68:	ce 01       	movw	r24, r28
     a6a:	08 96       	adiw	r24, 0x08	; 8
     a6c:	0e 94 80 02 	call	0x500	; 0x500 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
     a70:	ce 01       	movw	r24, r28
     a72:	41 96       	adiw	r24, 0x11	; 17
     a74:	0e 94 80 02 	call	0x500	; 0x500 <vListInitialise>
     a78:	05 c0       	rjmp	.+10     	; 0xa84 <xQueueCreate+0x82>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
     a7a:	ce 01       	movw	r24, r28
     a7c:	0e 94 71 02 	call	0x4e2	; 0x4e2 <vPortFree>

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     a80:	c0 e0       	ldi	r28, 0x00	; 0
     a82:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
     a84:	ce 01       	movw	r24, r28
     a86:	df 91       	pop	r29
     a88:	cf 91       	pop	r28
     a8a:	1f 91       	pop	r17
     a8c:	0f 91       	pop	r16
     a8e:	ff 90       	pop	r15
     a90:	ef 90       	pop	r14
     a92:	df 90       	pop	r13
     a94:	cf 90       	pop	r12
     a96:	08 95       	ret

00000a98 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     a98:	af 92       	push	r10
     a9a:	bf 92       	push	r11
     a9c:	df 92       	push	r13
     a9e:	ef 92       	push	r14
     aa0:	ff 92       	push	r15
     aa2:	0f 93       	push	r16
     aa4:	1f 93       	push	r17
     aa6:	cf 93       	push	r28
     aa8:	df 93       	push	r29
     aaa:	00 d0       	rcall	.+0      	; 0xaac <xQueueGenericSend+0x14>
     aac:	00 d0       	rcall	.+0      	; 0xaae <xQueueGenericSend+0x16>
     aae:	1f 92       	push	r1
     ab0:	cd b7       	in	r28, 0x3d	; 61
     ab2:	de b7       	in	r29, 0x3e	; 62
     ab4:	8c 01       	movw	r16, r24
     ab6:	7b 01       	movw	r14, r22
     ab8:	5d 83       	std	Y+5, r21	; 0x05
     aba:	4c 83       	std	Y+4, r20	; 0x04
     abc:	d2 2e       	mov	r13, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     abe:	90 e0       	ldi	r25, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     ac0:	58 01       	movw	r10, r16
     ac2:	88 e0       	ldi	r24, 0x08	; 8
     ac4:	a8 0e       	add	r10, r24
     ac6:	b1 1c       	adc	r11, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     ac8:	0f b6       	in	r0, 0x3f	; 63
     aca:	f8 94       	cli
     acc:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     ace:	f8 01       	movw	r30, r16
     ad0:	22 8d       	ldd	r18, Z+26	; 0x1a
     ad2:	83 8d       	ldd	r24, Z+27	; 0x1b
     ad4:	28 17       	cp	r18, r24
     ad6:	a8 f4       	brcc	.+42     	; 0xb02 <xQueueGenericSend+0x6a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     ad8:	4d 2d       	mov	r20, r13
     ada:	b7 01       	movw	r22, r14
     adc:	c8 01       	movw	r24, r16
     ade:	0e 94 69 04 	call	0x8d2	; 0x8d2 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ae2:	f8 01       	movw	r30, r16
     ae4:	81 89       	ldd	r24, Z+17	; 0x11
     ae6:	88 23       	and	r24, r24
     ae8:	41 f0       	breq	.+16     	; 0xafa <xQueueGenericSend+0x62>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     aea:	c8 01       	movw	r24, r16
     aec:	41 96       	adiw	r24, 0x11	; 17
     aee:	0e 94 c4 0a 	call	0x1588	; 0x1588 <xTaskRemoveFromEventList>
     af2:	81 30       	cpi	r24, 0x01	; 1
     af4:	11 f4       	brne	.+4      	; 0xafa <xQueueGenericSend+0x62>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
     af6:	0e 94 b2 03 	call	0x764	; 0x764 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
     afa:	0f 90       	pop	r0
     afc:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
     afe:	81 e0       	ldi	r24, 0x01	; 1
     b00:	50 c0       	rjmp	.+160    	; 0xba2 <xQueueGenericSend+0x10a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     b02:	2c 81       	ldd	r18, Y+4	; 0x04
     b04:	3d 81       	ldd	r19, Y+5	; 0x05
     b06:	23 2b       	or	r18, r19
     b08:	19 f4       	brne	.+6      	; 0xb10 <xQueueGenericSend+0x78>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     b0a:	0f 90       	pop	r0
     b0c:	0f be       	out	0x3f, r0	; 63
     b0e:	48 c0       	rjmp	.+144    	; 0xba0 <xQueueGenericSend+0x108>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
     b10:	91 11       	cpse	r25, r1
     b12:	04 c0       	rjmp	.+8      	; 0xb1c <xQueueGenericSend+0x84>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     b14:	ce 01       	movw	r24, r28
     b16:	01 96       	adiw	r24, 0x01	; 1
     b18:	0e 94 01 0b 	call	0x1602	; 0x1602 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
     b1c:	0f 90       	pop	r0
     b1e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     b20:	0e 94 a9 08 	call	0x1152	; 0x1152 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     b24:	0f b6       	in	r0, 0x3f	; 63
     b26:	f8 94       	cli
     b28:	0f 92       	push	r0
     b2a:	f8 01       	movw	r30, r16
     b2c:	85 8d       	ldd	r24, Z+29	; 0x1d
     b2e:	8f 3f       	cpi	r24, 0xFF	; 255
     b30:	09 f4       	brne	.+2      	; 0xb34 <xQueueGenericSend+0x9c>
     b32:	15 8e       	std	Z+29, r1	; 0x1d
     b34:	f8 01       	movw	r30, r16
     b36:	86 8d       	ldd	r24, Z+30	; 0x1e
     b38:	8f 3f       	cpi	r24, 0xFF	; 255
     b3a:	09 f4       	brne	.+2      	; 0xb3e <xQueueGenericSend+0xa6>
     b3c:	16 8e       	std	Z+30, r1	; 0x1e
     b3e:	0f 90       	pop	r0
     b40:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     b42:	be 01       	movw	r22, r28
     b44:	6c 5f       	subi	r22, 0xFC	; 252
     b46:	7f 4f       	sbci	r23, 0xFF	; 255
     b48:	ce 01       	movw	r24, r28
     b4a:	01 96       	adiw	r24, 0x01	; 1
     b4c:	0e 94 0c 0b 	call	0x1618	; 0x1618 <xTaskCheckForTimeOut>
     b50:	81 11       	cpse	r24, r1
     b52:	21 c0       	rjmp	.+66     	; 0xb96 <xQueueGenericSend+0xfe>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     b54:	0f b6       	in	r0, 0x3f	; 63
     b56:	f8 94       	cli
     b58:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     b5a:	f8 01       	movw	r30, r16
     b5c:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     b5e:	0f 90       	pop	r0
     b60:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     b62:	83 8d       	ldd	r24, Z+27	; 0x1b
     b64:	98 13       	cpse	r25, r24
     b66:	11 c0       	rjmp	.+34     	; 0xb8a <xQueueGenericSend+0xf2>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     b68:	6c 81       	ldd	r22, Y+4	; 0x04
     b6a:	7d 81       	ldd	r23, Y+5	; 0x05
     b6c:	c5 01       	movw	r24, r10
     b6e:	0e 94 a7 0a 	call	0x154e	; 0x154e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     b72:	c8 01       	movw	r24, r16
     b74:	0e 94 c3 04 	call	0x986	; 0x986 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     b78:	0e 94 60 09 	call	0x12c0	; 0x12c0 <xTaskResumeAll>
     b7c:	88 23       	and	r24, r24
     b7e:	11 f0       	breq	.+4      	; 0xb84 <xQueueGenericSend+0xec>
     b80:	91 e0       	ldi	r25, 0x01	; 1
     b82:	a2 cf       	rjmp	.-188    	; 0xac8 <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
     b84:	0e 94 b2 03 	call	0x764	; 0x764 <vPortYield>
     b88:	fb cf       	rjmp	.-10     	; 0xb80 <xQueueGenericSend+0xe8>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     b8a:	c8 01       	movw	r24, r16
     b8c:	0e 94 c3 04 	call	0x986	; 0x986 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     b90:	0e 94 60 09 	call	0x12c0	; 0x12c0 <xTaskResumeAll>
     b94:	f5 cf       	rjmp	.-22     	; 0xb80 <xQueueGenericSend+0xe8>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     b96:	c8 01       	movw	r24, r16
     b98:	0e 94 c3 04 	call	0x986	; 0x986 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     b9c:	0e 94 60 09 	call	0x12c0	; 0x12c0 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     ba0:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     ba2:	0f 90       	pop	r0
     ba4:	0f 90       	pop	r0
     ba6:	0f 90       	pop	r0
     ba8:	0f 90       	pop	r0
     baa:	0f 90       	pop	r0
     bac:	df 91       	pop	r29
     bae:	cf 91       	pop	r28
     bb0:	1f 91       	pop	r17
     bb2:	0f 91       	pop	r16
     bb4:	ff 90       	pop	r15
     bb6:	ef 90       	pop	r14
     bb8:	df 90       	pop	r13
     bba:	bf 90       	pop	r11
     bbc:	af 90       	pop	r10
     bbe:	08 95       	ret

00000bc0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     bc0:	0f 93       	push	r16
     bc2:	1f 93       	push	r17
     bc4:	cf 93       	push	r28
     bc6:	df 93       	push	r29
     bc8:	ec 01       	movw	r28, r24
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     bca:	9a 8d       	ldd	r25, Y+26	; 0x1a
     bcc:	8b 8d       	ldd	r24, Y+27	; 0x1b
     bce:	98 17       	cp	r25, r24
     bd0:	c8 f4       	brcc	.+50     	; 0xc04 <xQueueGenericSendFromISR+0x44>
     bd2:	8a 01       	movw	r16, r20
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     bd4:	42 2f       	mov	r20, r18
     bd6:	ce 01       	movw	r24, r28
     bd8:	0e 94 69 04 	call	0x8d2	; 0x8d2 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     bdc:	8e 8d       	ldd	r24, Y+30	; 0x1e
     bde:	8f 3f       	cpi	r24, 0xFF	; 255
     be0:	69 f4       	brne	.+26     	; 0xbfc <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     be2:	89 89       	ldd	r24, Y+17	; 0x11
     be4:	88 23       	and	r24, r24
     be6:	61 f0       	breq	.+24     	; 0xc00 <xQueueGenericSendFromISR+0x40>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     be8:	ce 01       	movw	r24, r28
     bea:	41 96       	adiw	r24, 0x11	; 17
     bec:	0e 94 c4 0a 	call	0x1588	; 0x1588 <xTaskRemoveFromEventList>
     bf0:	88 23       	and	r24, r24
     bf2:	31 f0       	breq	.+12     	; 0xc00 <xQueueGenericSendFromISR+0x40>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
     bf4:	81 e0       	ldi	r24, 0x01	; 1
     bf6:	f8 01       	movw	r30, r16
     bf8:	80 83       	st	Z, r24
     bfa:	05 c0       	rjmp	.+10     	; 0xc06 <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     bfc:	8f 5f       	subi	r24, 0xFF	; 255
     bfe:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
     c00:	81 e0       	ldi	r24, 0x01	; 1
     c02:	01 c0       	rjmp	.+2      	; 0xc06 <xQueueGenericSendFromISR+0x46>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     c04:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     c06:	df 91       	pop	r29
     c08:	cf 91       	pop	r28
     c0a:	1f 91       	pop	r17
     c0c:	0f 91       	pop	r16
     c0e:	08 95       	ret

00000c10 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     c10:	af 92       	push	r10
     c12:	bf 92       	push	r11
     c14:	df 92       	push	r13
     c16:	ef 92       	push	r14
     c18:	ff 92       	push	r15
     c1a:	0f 93       	push	r16
     c1c:	1f 93       	push	r17
     c1e:	cf 93       	push	r28
     c20:	df 93       	push	r29
     c22:	00 d0       	rcall	.+0      	; 0xc24 <xQueueGenericReceive+0x14>
     c24:	00 d0       	rcall	.+0      	; 0xc26 <xQueueGenericReceive+0x16>
     c26:	1f 92       	push	r1
     c28:	cd b7       	in	r28, 0x3d	; 61
     c2a:	de b7       	in	r29, 0x3e	; 62
     c2c:	8c 01       	movw	r16, r24
     c2e:	7b 01       	movw	r14, r22
     c30:	5d 83       	std	Y+5, r21	; 0x05
     c32:	4c 83       	std	Y+4, r20	; 0x04
     c34:	d2 2e       	mov	r13, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     c36:	90 e0       	ldi	r25, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     c38:	58 01       	movw	r10, r16
     c3a:	81 e1       	ldi	r24, 0x11	; 17
     c3c:	a8 0e       	add	r10, r24
     c3e:	b1 1c       	adc	r11, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     c40:	0f b6       	in	r0, 0x3f	; 63
     c42:	f8 94       	cli
     c44:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     c46:	f8 01       	movw	r30, r16
     c48:	82 8d       	ldd	r24, Z+26	; 0x1a
     c4a:	88 23       	and	r24, r24
     c4c:	39 f1       	breq	.+78     	; 0xc9c <xQueueGenericReceive+0x8c>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     c4e:	a6 80       	ldd	r10, Z+6	; 0x06
     c50:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     c52:	b7 01       	movw	r22, r14
     c54:	c8 01       	movw	r24, r16
     c56:	0e 94 a9 04 	call	0x952	; 0x952 <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     c5a:	f8 01       	movw	r30, r16
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
     c5c:	d1 10       	cpse	r13, r1
     c5e:	0f c0       	rjmp	.+30     	; 0xc7e <xQueueGenericReceive+0x6e>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     c60:	82 8d       	ldd	r24, Z+26	; 0x1a
     c62:	81 50       	subi	r24, 0x01	; 1
     c64:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     c66:	80 85       	ldd	r24, Z+8	; 0x08
     c68:	88 23       	and	r24, r24
     c6a:	a1 f0       	breq	.+40     	; 0xc94 <xQueueGenericReceive+0x84>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     c6c:	c8 01       	movw	r24, r16
     c6e:	08 96       	adiw	r24, 0x08	; 8
     c70:	0e 94 c4 0a 	call	0x1588	; 0x1588 <xTaskRemoveFromEventList>
     c74:	81 30       	cpi	r24, 0x01	; 1
     c76:	71 f4       	brne	.+28     	; 0xc94 <xQueueGenericReceive+0x84>
						{
							portYIELD_WITHIN_API();
     c78:	0e 94 b2 03 	call	0x764	; 0x764 <vPortYield>
     c7c:	0b c0       	rjmp	.+22     	; 0xc94 <xQueueGenericReceive+0x84>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     c7e:	b7 82       	std	Z+7, r11	; 0x07
     c80:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     c82:	81 89       	ldd	r24, Z+17	; 0x11
     c84:	88 23       	and	r24, r24
     c86:	31 f0       	breq	.+12     	; 0xc94 <xQueueGenericReceive+0x84>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     c88:	c8 01       	movw	r24, r16
     c8a:	41 96       	adiw	r24, 0x11	; 17
     c8c:	0e 94 c4 0a 	call	0x1588	; 0x1588 <xTaskRemoveFromEventList>
     c90:	81 11       	cpse	r24, r1
     c92:	f2 cf       	rjmp	.-28     	; 0xc78 <xQueueGenericReceive+0x68>
						}
					}

				}

				taskEXIT_CRITICAL();
     c94:	0f 90       	pop	r0
     c96:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     c98:	81 e0       	ldi	r24, 0x01	; 1
     c9a:	4f c0       	rjmp	.+158    	; 0xd3a <xQueueGenericReceive+0x12a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     c9c:	2c 81       	ldd	r18, Y+4	; 0x04
     c9e:	3d 81       	ldd	r19, Y+5	; 0x05
     ca0:	23 2b       	or	r18, r19
     ca2:	19 f4       	brne	.+6      	; 0xcaa <xQueueGenericReceive+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     ca4:	0f 90       	pop	r0
     ca6:	0f be       	out	0x3f, r0	; 63
     ca8:	47 c0       	rjmp	.+142    	; 0xd38 <xQueueGenericReceive+0x128>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
     caa:	91 11       	cpse	r25, r1
     cac:	04 c0       	rjmp	.+8      	; 0xcb6 <xQueueGenericReceive+0xa6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     cae:	ce 01       	movw	r24, r28
     cb0:	01 96       	adiw	r24, 0x01	; 1
     cb2:	0e 94 01 0b 	call	0x1602	; 0x1602 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
     cb6:	0f 90       	pop	r0
     cb8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     cba:	0e 94 a9 08 	call	0x1152	; 0x1152 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     cbe:	0f b6       	in	r0, 0x3f	; 63
     cc0:	f8 94       	cli
     cc2:	0f 92       	push	r0
     cc4:	f8 01       	movw	r30, r16
     cc6:	85 8d       	ldd	r24, Z+29	; 0x1d
     cc8:	8f 3f       	cpi	r24, 0xFF	; 255
     cca:	09 f4       	brne	.+2      	; 0xcce <xQueueGenericReceive+0xbe>
     ccc:	15 8e       	std	Z+29, r1	; 0x1d
     cce:	f8 01       	movw	r30, r16
     cd0:	86 8d       	ldd	r24, Z+30	; 0x1e
     cd2:	8f 3f       	cpi	r24, 0xFF	; 255
     cd4:	09 f4       	brne	.+2      	; 0xcd8 <xQueueGenericReceive+0xc8>
     cd6:	16 8e       	std	Z+30, r1	; 0x1e
     cd8:	0f 90       	pop	r0
     cda:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     cdc:	be 01       	movw	r22, r28
     cde:	6c 5f       	subi	r22, 0xFC	; 252
     ce0:	7f 4f       	sbci	r23, 0xFF	; 255
     ce2:	ce 01       	movw	r24, r28
     ce4:	01 96       	adiw	r24, 0x01	; 1
     ce6:	0e 94 0c 0b 	call	0x1618	; 0x1618 <xTaskCheckForTimeOut>
     cea:	81 11       	cpse	r24, r1
     cec:	20 c0       	rjmp	.+64     	; 0xd2e <xQueueGenericReceive+0x11e>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     cee:	0f b6       	in	r0, 0x3f	; 63
     cf0:	f8 94       	cli
     cf2:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     cf4:	f8 01       	movw	r30, r16
     cf6:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     cf8:	0f 90       	pop	r0
     cfa:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     cfc:	81 11       	cpse	r24, r1
     cfe:	11 c0       	rjmp	.+34     	; 0xd22 <xQueueGenericReceive+0x112>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     d00:	6c 81       	ldd	r22, Y+4	; 0x04
     d02:	7d 81       	ldd	r23, Y+5	; 0x05
     d04:	c5 01       	movw	r24, r10
     d06:	0e 94 a7 0a 	call	0x154e	; 0x154e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     d0a:	c8 01       	movw	r24, r16
     d0c:	0e 94 c3 04 	call	0x986	; 0x986 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     d10:	0e 94 60 09 	call	0x12c0	; 0x12c0 <xTaskResumeAll>
     d14:	88 23       	and	r24, r24
     d16:	11 f0       	breq	.+4      	; 0xd1c <xQueueGenericReceive+0x10c>
     d18:	91 e0       	ldi	r25, 0x01	; 1
     d1a:	92 cf       	rjmp	.-220    	; 0xc40 <xQueueGenericReceive+0x30>
				{
					portYIELD_WITHIN_API();
     d1c:	0e 94 b2 03 	call	0x764	; 0x764 <vPortYield>
     d20:	fb cf       	rjmp	.-10     	; 0xd18 <xQueueGenericReceive+0x108>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     d22:	c8 01       	movw	r24, r16
     d24:	0e 94 c3 04 	call	0x986	; 0x986 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     d28:	0e 94 60 09 	call	0x12c0	; 0x12c0 <xTaskResumeAll>
     d2c:	f5 cf       	rjmp	.-22     	; 0xd18 <xQueueGenericReceive+0x108>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     d2e:	c8 01       	movw	r24, r16
     d30:	0e 94 c3 04 	call	0x986	; 0x986 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     d34:	0e 94 60 09 	call	0x12c0	; 0x12c0 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     d38:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     d3a:	0f 90       	pop	r0
     d3c:	0f 90       	pop	r0
     d3e:	0f 90       	pop	r0
     d40:	0f 90       	pop	r0
     d42:	0f 90       	pop	r0
     d44:	df 91       	pop	r29
     d46:	cf 91       	pop	r28
     d48:	1f 91       	pop	r17
     d4a:	0f 91       	pop	r16
     d4c:	ff 90       	pop	r15
     d4e:	ef 90       	pop	r14
     d50:	df 90       	pop	r13
     d52:	bf 90       	pop	r11
     d54:	af 90       	pop	r10
     d56:	08 95       	ret

00000d58 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
     d58:	0f 93       	push	r16
     d5a:	1f 93       	push	r17
     d5c:	cf 93       	push	r28
     d5e:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     d60:	fc 01       	movw	r30, r24
     d62:	22 8d       	ldd	r18, Z+26	; 0x1a
     d64:	22 23       	and	r18, r18
     d66:	d9 f0       	breq	.+54     	; 0xd9e <xQueueReceiveFromISR+0x46>
     d68:	8a 01       	movw	r16, r20
     d6a:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
     d6c:	0e 94 a9 04 	call	0x952	; 0x952 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
     d70:	8a 8d       	ldd	r24, Y+26	; 0x1a
     d72:	81 50       	subi	r24, 0x01	; 1
     d74:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
     d76:	8d 8d       	ldd	r24, Y+29	; 0x1d
     d78:	8f 3f       	cpi	r24, 0xFF	; 255
     d7a:	69 f4       	brne	.+26     	; 0xd96 <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     d7c:	88 85       	ldd	r24, Y+8	; 0x08
     d7e:	88 23       	and	r24, r24
     d80:	61 f0       	breq	.+24     	; 0xd9a <xQueueReceiveFromISR+0x42>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     d82:	ce 01       	movw	r24, r28
     d84:	08 96       	adiw	r24, 0x08	; 8
     d86:	0e 94 c4 0a 	call	0x1588	; 0x1588 <xTaskRemoveFromEventList>
     d8a:	88 23       	and	r24, r24
     d8c:	31 f0       	breq	.+12     	; 0xd9a <xQueueReceiveFromISR+0x42>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
     d8e:	81 e0       	ldi	r24, 0x01	; 1
     d90:	f8 01       	movw	r30, r16
     d92:	80 83       	st	Z, r24
     d94:	05 c0       	rjmp	.+10     	; 0xda0 <xQueueReceiveFromISR+0x48>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
     d96:	8f 5f       	subi	r24, 0xFF	; 255
     d98:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
     d9a:	81 e0       	ldi	r24, 0x01	; 1
     d9c:	01 c0       	rjmp	.+2      	; 0xda0 <xQueueReceiveFromISR+0x48>
		}
		else
		{
			xReturn = pdFAIL;
     d9e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     da0:	df 91       	pop	r29
     da2:	cf 91       	pop	r28
     da4:	1f 91       	pop	r17
     da6:	0f 91       	pop	r16
     da8:	08 95       	ret

00000daa <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     daa:	0f b6       	in	r0, 0x3f	; 63
     dac:	f8 94       	cli
     dae:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
     db0:	fc 01       	movw	r30, r24
     db2:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     db4:	0f 90       	pop	r0
     db6:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     db8:	08 95       	ret

00000dba <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
     dba:	fc 01       	movw	r30, r24
     dbc:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
     dbe:	08 95       	ret

00000dc0 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
     dc0:	cf 93       	push	r28
     dc2:	df 93       	push	r29
     dc4:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
     dc6:	88 81       	ld	r24, Y
     dc8:	99 81       	ldd	r25, Y+1	; 0x01
     dca:	0e 94 71 02 	call	0x4e2	; 0x4e2 <vPortFree>
	vPortFree( pxQueue );
     dce:	ce 01       	movw	r24, r28
}
     dd0:	df 91       	pop	r29
     dd2:	cf 91       	pop	r28
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
	vPortFree( pxQueue );
     dd4:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <vPortFree>

00000dd8 <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     dd8:	fc 01       	movw	r30, r24
     dda:	92 8d       	ldd	r25, Z+26	; 0x1a
     ddc:	81 e0       	ldi	r24, 0x01	; 1
     dde:	91 11       	cpse	r25, r1
     de0:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
     de2:	08 95       	ret

00000de4 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
     de4:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     de6:	22 8d       	ldd	r18, Z+26	; 0x1a
     de8:	81 e0       	ldi	r24, 0x01	; 1
     dea:	93 8d       	ldd	r25, Z+27	; 0x1b
     dec:	29 13       	cpse	r18, r25
     dee:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
     df0:	08 95       	ret

00000df2 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
     df2:	cf 93       	push	r28
     df4:	df 93       	push	r29
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     df6:	e0 91 fc 02 	lds	r30, 0x02FC
     dfa:	f0 91 fd 02 	lds	r31, 0x02FD
     dfe:	93 83       	std	Z+3, r25	; 0x03
     e00:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
     e02:	20 91 06 03 	lds	r18, 0x0306
     e06:	30 91 07 03 	lds	r19, 0x0307
     e0a:	82 17       	cp	r24, r18
     e0c:	93 07       	cpc	r25, r19
     e0e:	70 f4       	brcc	.+28     	; 0xe2c <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
     e10:	60 91 fc 02 	lds	r22, 0x02FC
     e14:	70 91 fd 02 	lds	r23, 0x02FD
     e18:	80 91 1c 03 	lds	r24, 0x031C
     e1c:	90 91 1d 03 	lds	r25, 0x031D
     e20:	6e 5f       	subi	r22, 0xFE	; 254
     e22:	7f 4f       	sbci	r23, 0xFF	; 255
		if( xTimeToWake < xNextTaskUnblockTime )
		{
			xNextTaskUnblockTime = xTimeToWake;
		}
	}
}
     e24:	df 91       	pop	r29
     e26:	cf 91       	pop	r28
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
     e28:	0c 94 b5 02 	jmp	0x56a	; 0x56a <vListInsert>
     e2c:	ec 01       	movw	r28, r24
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
     e2e:	60 91 fc 02 	lds	r22, 0x02FC
     e32:	70 91 fd 02 	lds	r23, 0x02FD
     e36:	80 91 1e 03 	lds	r24, 0x031E
     e3a:	90 91 1f 03 	lds	r25, 0x031F
     e3e:	6e 5f       	subi	r22, 0xFE	; 254
     e40:	7f 4f       	sbci	r23, 0xFF	; 255
     e42:	0e 94 b5 02 	call	0x56a	; 0x56a <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
     e46:	80 91 60 00 	lds	r24, 0x0060
     e4a:	90 91 61 00 	lds	r25, 0x0061
     e4e:	c8 17       	cp	r28, r24
     e50:	d9 07       	cpc	r29, r25
     e52:	20 f4       	brcc	.+8      	; 0xe5c <prvAddCurrentTaskToDelayedList+0x6a>
		{
			xNextTaskUnblockTime = xTimeToWake;
     e54:	d0 93 61 00 	sts	0x0061, r29
     e58:	c0 93 60 00 	sts	0x0060, r28
		}
	}
}
     e5c:	df 91       	pop	r29
     e5e:	cf 91       	pop	r28
     e60:	08 95       	ret

00000e62 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
     e62:	4f 92       	push	r4
     e64:	5f 92       	push	r5
     e66:	6f 92       	push	r6
     e68:	7f 92       	push	r7
     e6a:	8f 92       	push	r8
     e6c:	9f 92       	push	r9
     e6e:	af 92       	push	r10
     e70:	bf 92       	push	r11
     e72:	cf 92       	push	r12
     e74:	df 92       	push	r13
     e76:	ef 92       	push	r14
     e78:	ff 92       	push	r15
     e7a:	0f 93       	push	r16
     e7c:	1f 93       	push	r17
     e7e:	cf 93       	push	r28
     e80:	df 93       	push	r29
     e82:	5c 01       	movw	r10, r24
     e84:	3b 01       	movw	r6, r22
     e86:	ea 01       	movw	r28, r20
     e88:	49 01       	movw	r8, r18
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
     e8a:	81 e2       	ldi	r24, 0x21	; 33
     e8c:	90 e0       	ldi	r25, 0x00	; 0
     e8e:	0e 94 4b 02 	call	0x496	; 0x496 <pvPortMalloc>
     e92:	2c 01       	movw	r4, r24

	if( pxNewTCB != NULL )
     e94:	89 2b       	or	r24, r25
     e96:	09 f4       	brne	.+2      	; 0xe9a <xTaskGenericCreate+0x38>
     e98:	c8 c0       	rjmp	.+400    	; 0x102a <xTaskGenericCreate+0x1c8>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
     e9a:	c1 14       	cp	r12, r1
     e9c:	d1 04       	cpc	r13, r1
     e9e:	21 f4       	brne	.+8      	; 0xea8 <xTaskGenericCreate+0x46>
     ea0:	ce 01       	movw	r24, r28
     ea2:	0e 94 4b 02 	call	0x496	; 0x496 <pvPortMalloc>
     ea6:	01 c0       	rjmp	.+2      	; 0xeaa <xTaskGenericCreate+0x48>
     ea8:	c6 01       	movw	r24, r12
     eaa:	f2 01       	movw	r30, r4
     eac:	90 8f       	std	Z+24, r25	; 0x18
     eae:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
     eb0:	00 97       	sbiw	r24, 0x00	; 0
     eb2:	21 f4       	brne	.+8      	; 0xebc <xTaskGenericCreate+0x5a>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
     eb4:	c2 01       	movw	r24, r4
     eb6:	0e 94 71 02 	call	0x4e2	; 0x4e2 <vPortFree>
     eba:	b7 c0       	rjmp	.+366    	; 0x102a <xTaskGenericCreate+0x1c8>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
     ebc:	ae 01       	movw	r20, r28
     ebe:	65 ea       	ldi	r22, 0xA5	; 165
     ec0:	70 e0       	ldi	r23, 0x00	; 0
     ec2:	0e 94 a6 0b 	call	0x174c	; 0x174c <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
     ec6:	21 97       	sbiw	r28, 0x01	; 1
     ec8:	f2 01       	movw	r30, r4
     eca:	c7 88       	ldd	r12, Z+23	; 0x17
     ecc:	d0 8c       	ldd	r13, Z+24	; 0x18
     ece:	cc 0e       	add	r12, r28
     ed0:	dd 1e       	adc	r13, r29
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
     ed2:	48 e0       	ldi	r20, 0x08	; 8
     ed4:	50 e0       	ldi	r21, 0x00	; 0
     ed6:	b3 01       	movw	r22, r6
     ed8:	c2 01       	movw	r24, r4
     eda:	49 96       	adiw	r24, 0x19	; 25
     edc:	0e 94 ad 0b 	call	0x175a	; 0x175a <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
     ee0:	f2 01       	movw	r30, r4
     ee2:	10 a2       	std	Z+32, r1	; 0x20
     ee4:	10 2f       	mov	r17, r16
     ee6:	03 30       	cpi	r16, 0x03	; 3
     ee8:	08 f0       	brcs	.+2      	; 0xeec <xTaskGenericCreate+0x8a>
     eea:	12 e0       	ldi	r17, 0x02	; 2
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
     eec:	f2 01       	movw	r30, r4
     eee:	16 8b       	std	Z+22, r17	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
     ef0:	e2 01       	movw	r28, r4
     ef2:	22 96       	adiw	r28, 0x02	; 2
     ef4:	ce 01       	movw	r24, r28
     ef6:	0e 94 8e 02 	call	0x51c	; 0x51c <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
     efa:	c2 01       	movw	r24, r4
     efc:	0c 96       	adiw	r24, 0x0c	; 12
     efe:	0e 94 8e 02 	call	0x51c	; 0x51c <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
     f02:	f2 01       	movw	r30, r4
     f04:	51 86       	std	Z+9, r5	; 0x09
     f06:	40 86       	std	Z+8, r4	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     f08:	83 e0       	ldi	r24, 0x03	; 3
     f0a:	90 e0       	ldi	r25, 0x00	; 0
     f0c:	81 1b       	sub	r24, r17
     f0e:	91 09       	sbc	r25, r1
     f10:	95 87       	std	Z+13, r25	; 0x0d
     f12:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
     f14:	53 8a       	std	Z+19, r5	; 0x13
     f16:	42 8a       	std	Z+18, r4	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     f18:	a4 01       	movw	r20, r8
     f1a:	b5 01       	movw	r22, r10
     f1c:	c6 01       	movw	r24, r12
     f1e:	0e 94 10 03 	call	0x620	; 0x620 <pxPortInitialiseStack>
     f22:	f2 01       	movw	r30, r4
     f24:	91 83       	std	Z+1, r25	; 0x01
     f26:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
     f28:	e1 14       	cp	r14, r1
     f2a:	f1 04       	cpc	r15, r1
     f2c:	19 f0       	breq	.+6      	; 0xf34 <xTaskGenericCreate+0xd2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
     f2e:	f7 01       	movw	r30, r14
     f30:	51 82       	std	Z+1, r5	; 0x01
     f32:	40 82       	st	Z, r4
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
     f34:	0f b6       	in	r0, 0x3f	; 63
     f36:	f8 94       	cli
     f38:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     f3a:	80 91 08 03 	lds	r24, 0x0308
     f3e:	8f 5f       	subi	r24, 0xFF	; 255
     f40:	80 93 08 03 	sts	0x0308, r24
			if( pxCurrentTCB == NULL )
     f44:	80 91 fc 02 	lds	r24, 0x02FC
     f48:	90 91 fd 02 	lds	r25, 0x02FD
     f4c:	89 2b       	or	r24, r25
     f4e:	89 f5       	brne	.+98     	; 0xfb2 <xTaskGenericCreate+0x150>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     f50:	50 92 fd 02 	sts	0x02FD, r5
     f54:	40 92 fc 02 	sts	0x02FC, r4

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
     f58:	80 91 08 03 	lds	r24, 0x0308
     f5c:	81 30       	cpi	r24, 0x01	; 1
     f5e:	c1 f5       	brne	.+112    	; 0xfd0 <xTaskGenericCreate+0x16e>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
     f60:	82 e3       	ldi	r24, 0x32	; 50
     f62:	93 e0       	ldi	r25, 0x03	; 3
     f64:	0e 94 80 02 	call	0x500	; 0x500 <vListInitialise>
     f68:	8b e3       	ldi	r24, 0x3B	; 59
     f6a:	93 e0       	ldi	r25, 0x03	; 3
     f6c:	0e 94 80 02 	call	0x500	; 0x500 <vListInitialise>
     f70:	84 e4       	ldi	r24, 0x44	; 68
     f72:	93 e0       	ldi	r25, 0x03	; 3
     f74:	0e 94 80 02 	call	0x500	; 0x500 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
     f78:	89 e2       	ldi	r24, 0x29	; 41
     f7a:	93 e0       	ldi	r25, 0x03	; 3
     f7c:	0e 94 80 02 	call	0x500	; 0x500 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
     f80:	80 e2       	ldi	r24, 0x20	; 32
     f82:	93 e0       	ldi	r25, 0x03	; 3
     f84:	0e 94 80 02 	call	0x500	; 0x500 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
     f88:	83 e1       	ldi	r24, 0x13	; 19
     f8a:	93 e0       	ldi	r25, 0x03	; 3
     f8c:	0e 94 80 02 	call	0x500	; 0x500 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
     f90:	8a e0       	ldi	r24, 0x0A	; 10
     f92:	93 e0       	ldi	r25, 0x03	; 3
     f94:	0e 94 80 02 	call	0x500	; 0x500 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     f98:	89 e2       	ldi	r24, 0x29	; 41
     f9a:	93 e0       	ldi	r25, 0x03	; 3
     f9c:	90 93 1f 03 	sts	0x031F, r25
     fa0:	80 93 1e 03 	sts	0x031E, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     fa4:	80 e2       	ldi	r24, 0x20	; 32
     fa6:	93 e0       	ldi	r25, 0x03	; 3
     fa8:	90 93 1d 03 	sts	0x031D, r25
     fac:	80 93 1c 03 	sts	0x031C, r24
     fb0:	0f c0       	rjmp	.+30     	; 0xfd0 <xTaskGenericCreate+0x16e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     fb2:	80 91 03 03 	lds	r24, 0x0303
     fb6:	81 11       	cpse	r24, r1
     fb8:	0b c0       	rjmp	.+22     	; 0xfd0 <xTaskGenericCreate+0x16e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     fba:	e0 91 fc 02 	lds	r30, 0x02FC
     fbe:	f0 91 fd 02 	lds	r31, 0x02FD
     fc2:	86 89       	ldd	r24, Z+22	; 0x16
     fc4:	08 17       	cp	r16, r24
     fc6:	20 f0       	brcs	.+8      	; 0xfd0 <xTaskGenericCreate+0x16e>
					{
						pxCurrentTCB = pxNewTCB;
     fc8:	50 92 fd 02 	sts	0x02FD, r5
     fcc:	40 92 fc 02 	sts	0x02FC, r4
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
     fd0:	f2 01       	movw	r30, r4
     fd2:	86 89       	ldd	r24, Z+22	; 0x16
     fd4:	90 91 05 03 	lds	r25, 0x0305
     fd8:	98 17       	cp	r25, r24
     fda:	10 f4       	brcc	.+4      	; 0xfe0 <xTaskGenericCreate+0x17e>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
     fdc:	80 93 05 03 	sts	0x0305, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
     fe0:	90 91 fe 02 	lds	r25, 0x02FE
     fe4:	9f 5f       	subi	r25, 0xFF	; 255
     fe6:	90 93 fe 02 	sts	0x02FE, r25

			prvAddTaskToReadyQueue( pxNewTCB );
     fea:	90 91 04 03 	lds	r25, 0x0304
     fee:	98 17       	cp	r25, r24
     ff0:	10 f4       	brcc	.+4      	; 0xff6 <xTaskGenericCreate+0x194>
     ff2:	80 93 04 03 	sts	0x0304, r24
     ff6:	f9 e0       	ldi	r31, 0x09	; 9
     ff8:	8f 9f       	mul	r24, r31
     ffa:	c0 01       	movw	r24, r0
     ffc:	11 24       	eor	r1, r1
     ffe:	be 01       	movw	r22, r28
    1000:	8e 5c       	subi	r24, 0xCE	; 206
    1002:	9c 4f       	sbci	r25, 0xFC	; 252
    1004:	0e 94 92 02 	call	0x524	; 0x524 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1008:	0f 90       	pop	r0
    100a:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    100c:	80 91 03 03 	lds	r24, 0x0303
    1010:	88 23       	and	r24, r24
    1012:	49 f0       	breq	.+18     	; 0x1026 <xTaskGenericCreate+0x1c4>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1014:	e0 91 fc 02 	lds	r30, 0x02FC
    1018:	f0 91 fd 02 	lds	r31, 0x02FD
    101c:	86 89       	ldd	r24, Z+22	; 0x16
    101e:	80 17       	cp	r24, r16
    1020:	10 f4       	brcc	.+4      	; 0x1026 <xTaskGenericCreate+0x1c4>
			{
				portYIELD_WITHIN_API();
    1022:	0e 94 b2 03 	call	0x764	; 0x764 <vPortYield>
    1026:	81 e0       	ldi	r24, 0x01	; 1
    1028:	01 c0       	rjmp	.+2      	; 0x102c <xTaskGenericCreate+0x1ca>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    102a:	8f ef       	ldi	r24, 0xFF	; 255
			}
		}
	}

	return xReturn;
}
    102c:	df 91       	pop	r29
    102e:	cf 91       	pop	r28
    1030:	1f 91       	pop	r17
    1032:	0f 91       	pop	r16
    1034:	ff 90       	pop	r15
    1036:	ef 90       	pop	r14
    1038:	df 90       	pop	r13
    103a:	cf 90       	pop	r12
    103c:	bf 90       	pop	r11
    103e:	af 90       	pop	r10
    1040:	9f 90       	pop	r9
    1042:	8f 90       	pop	r8
    1044:	7f 90       	pop	r7
    1046:	6f 90       	pop	r6
    1048:	5f 90       	pop	r5
    104a:	4f 90       	pop	r4
    104c:	08 95       	ret

0000104e <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    104e:	ef 92       	push	r14
    1050:	ff 92       	push	r15
    1052:	0f 93       	push	r16
    1054:	1f 93       	push	r17
    1056:	cf 93       	push	r28
    1058:	df 93       	push	r29
    105a:	ec 01       	movw	r28, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    105c:	0f b6       	in	r0, 0x3f	; 63
    105e:	f8 94       	cli
    1060:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1062:	80 91 fc 02 	lds	r24, 0x02FC
    1066:	90 91 fd 02 	lds	r25, 0x02FD
    106a:	c8 17       	cp	r28, r24
    106c:	d9 07       	cpc	r29, r25
    106e:	11 f0       	breq	.+4      	; 0x1074 <vTaskDelete+0x26>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1070:	20 97       	sbiw	r28, 0x00	; 0
    1072:	39 f4       	brne	.+14     	; 0x1082 <vTaskDelete+0x34>
    1074:	00 91 fc 02 	lds	r16, 0x02FC
    1078:	10 91 fd 02 	lds	r17, 0x02FD
    107c:	c0 e0       	ldi	r28, 0x00	; 0
    107e:	d0 e0       	ldi	r29, 0x00	; 0
    1080:	01 c0       	rjmp	.+2      	; 0x1084 <vTaskDelete+0x36>
    1082:	8e 01       	movw	r16, r28

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1084:	78 01       	movw	r14, r16
    1086:	82 e0       	ldi	r24, 0x02	; 2
    1088:	e8 0e       	add	r14, r24
    108a:	f1 1c       	adc	r15, r1
    108c:	c7 01       	movw	r24, r14
    108e:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1092:	f8 01       	movw	r30, r16
    1094:	84 89       	ldd	r24, Z+20	; 0x14
    1096:	95 89       	ldd	r25, Z+21	; 0x15
    1098:	89 2b       	or	r24, r25
    109a:	21 f0       	breq	.+8      	; 0x10a4 <vTaskDelete+0x56>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    109c:	c8 01       	movw	r24, r16
    109e:	0c 96       	adiw	r24, 0x0c	; 12
    10a0:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    10a4:	b7 01       	movw	r22, r14
    10a6:	8a e0       	ldi	r24, 0x0A	; 10
    10a8:	93 e0       	ldi	r25, 0x03	; 3
    10aa:	0e 94 92 02 	call	0x524	; 0x524 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    10ae:	80 91 09 03 	lds	r24, 0x0309
    10b2:	8f 5f       	subi	r24, 0xFF	; 255
    10b4:	80 93 09 03 	sts	0x0309, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    10b8:	80 91 fe 02 	lds	r24, 0x02FE
    10bc:	8f 5f       	subi	r24, 0xFF	; 255
    10be:	80 93 fe 02 	sts	0x02FE, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    10c2:	0f 90       	pop	r0
    10c4:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    10c6:	80 91 03 03 	lds	r24, 0x0303
    10ca:	88 23       	and	r24, r24
    10cc:	21 f0       	breq	.+8      	; 0x10d6 <vTaskDelete+0x88>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    10ce:	cd 2b       	or	r28, r29
    10d0:	11 f4       	brne	.+4      	; 0x10d6 <vTaskDelete+0x88>
			{
				portYIELD_WITHIN_API();
    10d2:	0e 94 b2 03 	call	0x764	; 0x764 <vPortYield>
			}
		}
	}
    10d6:	df 91       	pop	r29
    10d8:	cf 91       	pop	r28
    10da:	1f 91       	pop	r17
    10dc:	0f 91       	pop	r16
    10de:	ff 90       	pop	r15
    10e0:	ef 90       	pop	r14
    10e2:	08 95       	ret

000010e4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    10e4:	af 92       	push	r10
    10e6:	bf 92       	push	r11
    10e8:	cf 92       	push	r12
    10ea:	df 92       	push	r13
    10ec:	ef 92       	push	r14
    10ee:	ff 92       	push	r15
    10f0:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    10f2:	a1 2c       	mov	r10, r1
    10f4:	b1 2c       	mov	r11, r1
    10f6:	c1 2c       	mov	r12, r1
    10f8:	d1 2c       	mov	r13, r1
    10fa:	e1 2c       	mov	r14, r1
    10fc:	f1 2c       	mov	r15, r1
    10fe:	00 e0       	ldi	r16, 0x00	; 0
    1100:	20 e0       	ldi	r18, 0x00	; 0
    1102:	30 e0       	ldi	r19, 0x00	; 0
    1104:	45 e5       	ldi	r20, 0x55	; 85
    1106:	50 e0       	ldi	r21, 0x00	; 0
    1108:	62 e6       	ldi	r22, 0x62	; 98
    110a:	70 e0       	ldi	r23, 0x00	; 0
    110c:	80 e3       	ldi	r24, 0x30	; 48
    110e:	9a e0       	ldi	r25, 0x0A	; 10
    1110:	0e 94 31 07 	call	0xe62	; 0xe62 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1114:	81 30       	cpi	r24, 0x01	; 1
    1116:	81 f4       	brne	.+32     	; 0x1138 <vTaskStartScheduler+0x54>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1118:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    111a:	80 93 03 03 	sts	0x0303, r24
		xTickCount = ( portTickType ) 0U;
    111e:	10 92 07 03 	sts	0x0307, r1
    1122:	10 92 06 03 	sts	0x0306, r1
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1126:	0f 91       	pop	r16
    1128:	ff 90       	pop	r15
    112a:	ef 90       	pop	r14
    112c:	df 90       	pop	r13
    112e:	cf 90       	pop	r12
    1130:	bf 90       	pop	r11
    1132:	af 90       	pop	r10
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1134:	0c 94 7c 03 	jmp	0x6f8	; 0x6f8 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1138:	0f 91       	pop	r16
    113a:	ff 90       	pop	r15
    113c:	ef 90       	pop	r14
    113e:	df 90       	pop	r13
    1140:	cf 90       	pop	r12
    1142:	bf 90       	pop	r11
    1144:	af 90       	pop	r10
    1146:	08 95       	ret

00001148 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1148:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    114a:	10 92 03 03 	sts	0x0303, r1
	vPortEndScheduler();
    114e:	0c 94 b1 03 	jmp	0x762	; 0x762 <vPortEndScheduler>

00001152 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1152:	80 91 02 03 	lds	r24, 0x0302
    1156:	8f 5f       	subi	r24, 0xFF	; 255
    1158:	80 93 02 03 	sts	0x0302, r24
    115c:	08 95       	ret

0000115e <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    115e:	0f b6       	in	r0, 0x3f	; 63
    1160:	f8 94       	cli
    1162:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1164:	80 91 06 03 	lds	r24, 0x0306
    1168:	90 91 07 03 	lds	r25, 0x0307
	}
	taskEXIT_CRITICAL();
    116c:	0f 90       	pop	r0
    116e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1170:	08 95       	ret

00001172 <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    1172:	80 91 06 03 	lds	r24, 0x0306
    1176:	90 91 07 03 	lds	r25, 0x0307
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    117a:	08 95       	ret

0000117c <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    117c:	80 91 08 03 	lds	r24, 0x0308
}
    1180:	08 95       	ret

00001182 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1182:	ff 92       	push	r15
    1184:	0f 93       	push	r16
    1186:	1f 93       	push	r17
    1188:	cf 93       	push	r28
    118a:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    118c:	80 91 02 03 	lds	r24, 0x0302
    1190:	81 11       	cpse	r24, r1
    1192:	8b c0       	rjmp	.+278    	; 0x12aa <vTaskIncrementTick+0x128>
	{
		++xTickCount;
    1194:	80 91 06 03 	lds	r24, 0x0306
    1198:	90 91 07 03 	lds	r25, 0x0307
    119c:	01 96       	adiw	r24, 0x01	; 1
    119e:	90 93 07 03 	sts	0x0307, r25
    11a2:	80 93 06 03 	sts	0x0306, r24
		if( xTickCount == ( portTickType ) 0U )
    11a6:	80 91 06 03 	lds	r24, 0x0306
    11aa:	90 91 07 03 	lds	r25, 0x0307
    11ae:	89 2b       	or	r24, r25
    11b0:	79 f5       	brne	.+94     	; 0x1210 <vTaskIncrementTick+0x8e>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    11b2:	80 91 1e 03 	lds	r24, 0x031E
    11b6:	90 91 1f 03 	lds	r25, 0x031F
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    11ba:	20 91 1c 03 	lds	r18, 0x031C
    11be:	30 91 1d 03 	lds	r19, 0x031D
    11c2:	30 93 1f 03 	sts	0x031F, r19
    11c6:	20 93 1e 03 	sts	0x031E, r18
			pxOverflowDelayedTaskList = pxTemp;
    11ca:	90 93 1d 03 	sts	0x031D, r25
    11ce:	80 93 1c 03 	sts	0x031C, r24
			xNumOfOverflows++;
    11d2:	80 91 ff 02 	lds	r24, 0x02FF
    11d6:	8f 5f       	subi	r24, 0xFF	; 255
    11d8:	80 93 ff 02 	sts	0x02FF, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    11dc:	e0 91 1e 03 	lds	r30, 0x031E
    11e0:	f0 91 1f 03 	lds	r31, 0x031F
    11e4:	80 81       	ld	r24, Z
    11e6:	81 11       	cpse	r24, r1
    11e8:	03 c0       	rjmp	.+6      	; 0x11f0 <vTaskIncrementTick+0x6e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    11ea:	8f ef       	ldi	r24, 0xFF	; 255
    11ec:	9f ef       	ldi	r25, 0xFF	; 255
    11ee:	0c c0       	rjmp	.+24     	; 0x1208 <vTaskIncrementTick+0x86>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    11f0:	e0 91 1e 03 	lds	r30, 0x031E
    11f4:	f0 91 1f 03 	lds	r31, 0x031F
    11f8:	05 80       	ldd	r0, Z+5	; 0x05
    11fa:	f6 81       	ldd	r31, Z+6	; 0x06
    11fc:	e0 2d       	mov	r30, r0
    11fe:	06 80       	ldd	r0, Z+6	; 0x06
    1200:	f7 81       	ldd	r31, Z+7	; 0x07
    1202:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1204:	82 81       	ldd	r24, Z+2	; 0x02
    1206:	93 81       	ldd	r25, Z+3	; 0x03
    1208:	90 93 61 00 	sts	0x0061, r25
    120c:	80 93 60 00 	sts	0x0060, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1210:	20 91 06 03 	lds	r18, 0x0306
    1214:	30 91 07 03 	lds	r19, 0x0307
    1218:	80 91 60 00 	lds	r24, 0x0060
    121c:	90 91 61 00 	lds	r25, 0x0061
    1220:	28 17       	cp	r18, r24
    1222:	39 07       	cpc	r19, r25
    1224:	08 f4       	brcc	.+2      	; 0x1228 <vTaskIncrementTick+0xa6>
    1226:	46 c0       	rjmp	.+140    	; 0x12b4 <vTaskIncrementTick+0x132>
    1228:	89 e0       	ldi	r24, 0x09	; 9
    122a:	f8 2e       	mov	r15, r24
    122c:	e0 91 1e 03 	lds	r30, 0x031E
    1230:	f0 91 1f 03 	lds	r31, 0x031F
    1234:	80 81       	ld	r24, Z
    1236:	81 11       	cpse	r24, r1
    1238:	03 c0       	rjmp	.+6      	; 0x1240 <vTaskIncrementTick+0xbe>
    123a:	8f ef       	ldi	r24, 0xFF	; 255
    123c:	9f ef       	ldi	r25, 0xFF	; 255
    123e:	12 c0       	rjmp	.+36     	; 0x1264 <vTaskIncrementTick+0xe2>
    1240:	e0 91 1e 03 	lds	r30, 0x031E
    1244:	f0 91 1f 03 	lds	r31, 0x031F
    1248:	05 80       	ldd	r0, Z+5	; 0x05
    124a:	f6 81       	ldd	r31, Z+6	; 0x06
    124c:	e0 2d       	mov	r30, r0
    124e:	c6 81       	ldd	r28, Z+6	; 0x06
    1250:	d7 81       	ldd	r29, Z+7	; 0x07
    1252:	8a 81       	ldd	r24, Y+2	; 0x02
    1254:	9b 81       	ldd	r25, Y+3	; 0x03
    1256:	20 91 06 03 	lds	r18, 0x0306
    125a:	30 91 07 03 	lds	r19, 0x0307
    125e:	28 17       	cp	r18, r24
    1260:	39 07       	cpc	r19, r25
    1262:	28 f4       	brcc	.+10     	; 0x126e <vTaskIncrementTick+0xec>
    1264:	90 93 61 00 	sts	0x0061, r25
    1268:	80 93 60 00 	sts	0x0060, r24
    126c:	23 c0       	rjmp	.+70     	; 0x12b4 <vTaskIncrementTick+0x132>
    126e:	8e 01       	movw	r16, r28
    1270:	0e 5f       	subi	r16, 0xFE	; 254
    1272:	1f 4f       	sbci	r17, 0xFF	; 255
    1274:	c8 01       	movw	r24, r16
    1276:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListRemove>
    127a:	8c 89       	ldd	r24, Y+20	; 0x14
    127c:	9d 89       	ldd	r25, Y+21	; 0x15
    127e:	89 2b       	or	r24, r25
    1280:	21 f0       	breq	.+8      	; 0x128a <vTaskIncrementTick+0x108>
    1282:	ce 01       	movw	r24, r28
    1284:	0c 96       	adiw	r24, 0x0c	; 12
    1286:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListRemove>
    128a:	9e 89       	ldd	r25, Y+22	; 0x16
    128c:	80 91 04 03 	lds	r24, 0x0304
    1290:	89 17       	cp	r24, r25
    1292:	10 f4       	brcc	.+4      	; 0x1298 <vTaskIncrementTick+0x116>
    1294:	90 93 04 03 	sts	0x0304, r25
    1298:	f9 9e       	mul	r15, r25
    129a:	c0 01       	movw	r24, r0
    129c:	11 24       	eor	r1, r1
    129e:	b8 01       	movw	r22, r16
    12a0:	8e 5c       	subi	r24, 0xCE	; 206
    12a2:	9c 4f       	sbci	r25, 0xFC	; 252
    12a4:	0e 94 92 02 	call	0x524	; 0x524 <vListInsertEnd>
    12a8:	c1 cf       	rjmp	.-126    	; 0x122c <vTaskIncrementTick+0xaa>
	}
	else
	{
		++uxMissedTicks;
    12aa:	80 91 01 03 	lds	r24, 0x0301
    12ae:	8f 5f       	subi	r24, 0xFF	; 255
    12b0:	80 93 01 03 	sts	0x0301, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    12b4:	df 91       	pop	r29
    12b6:	cf 91       	pop	r28
    12b8:	1f 91       	pop	r17
    12ba:	0f 91       	pop	r16
    12bc:	ff 90       	pop	r15
    12be:	08 95       	ret

000012c0 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    12c0:	ef 92       	push	r14
    12c2:	ff 92       	push	r15
    12c4:	0f 93       	push	r16
    12c6:	1f 93       	push	r17
    12c8:	cf 93       	push	r28
    12ca:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    12cc:	0f b6       	in	r0, 0x3f	; 63
    12ce:	f8 94       	cli
    12d0:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    12d2:	80 91 02 03 	lds	r24, 0x0302
    12d6:	81 50       	subi	r24, 0x01	; 1
    12d8:	80 93 02 03 	sts	0x0302, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    12dc:	80 91 02 03 	lds	r24, 0x0302
    12e0:	88 23       	and	r24, r24
    12e2:	11 f0       	breq	.+4      	; 0x12e8 <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    12e4:	80 e0       	ldi	r24, 0x00	; 0
    12e6:	52 c0       	rjmp	.+164    	; 0x138c <xTaskResumeAll+0xcc>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    12e8:	80 91 08 03 	lds	r24, 0x0308
    12ec:	88 23       	and	r24, r24
    12ee:	d1 f3       	breq	.-12     	; 0x12e4 <xTaskResumeAll+0x24>
    12f0:	10 e0       	ldi	r17, 0x00	; 0
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    12f2:	09 e0       	ldi	r16, 0x09	; 9
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    12f4:	80 91 13 03 	lds	r24, 0x0313
    12f8:	88 23       	and	r24, r24
    12fa:	51 f1       	breq	.+84     	; 0x1350 <xTaskResumeAll+0x90>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    12fc:	e0 91 18 03 	lds	r30, 0x0318
    1300:	f0 91 19 03 	lds	r31, 0x0319
    1304:	c6 81       	ldd	r28, Z+6	; 0x06
    1306:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xEventListItem ) );
    1308:	ce 01       	movw	r24, r28
    130a:	0c 96       	adiw	r24, 0x0c	; 12
    130c:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1310:	7e 01       	movw	r14, r28
    1312:	82 e0       	ldi	r24, 0x02	; 2
    1314:	e8 0e       	add	r14, r24
    1316:	f1 1c       	adc	r15, r1
    1318:	c7 01       	movw	r24, r14
    131a:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    131e:	9e 89       	ldd	r25, Y+22	; 0x16
    1320:	80 91 04 03 	lds	r24, 0x0304
    1324:	89 17       	cp	r24, r25
    1326:	10 f4       	brcc	.+4      	; 0x132c <xTaskResumeAll+0x6c>
    1328:	90 93 04 03 	sts	0x0304, r25
    132c:	09 9f       	mul	r16, r25
    132e:	c0 01       	movw	r24, r0
    1330:	11 24       	eor	r1, r1
    1332:	b7 01       	movw	r22, r14
    1334:	8e 5c       	subi	r24, 0xCE	; 206
    1336:	9c 4f       	sbci	r25, 0xFC	; 252
    1338:	0e 94 92 02 	call	0x524	; 0x524 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    133c:	e0 91 fc 02 	lds	r30, 0x02FC
    1340:	f0 91 fd 02 	lds	r31, 0x02FD
    1344:	9e 89       	ldd	r25, Y+22	; 0x16
    1346:	86 89       	ldd	r24, Z+22	; 0x16
    1348:	98 17       	cp	r25, r24
    134a:	a0 f2       	brcs	.-88     	; 0x12f4 <xTaskResumeAll+0x34>
					{
						xYieldRequired = pdTRUE;
    134c:	11 e0       	ldi	r17, 0x01	; 1
    134e:	d2 cf       	rjmp	.-92     	; 0x12f4 <xTaskResumeAll+0x34>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1350:	80 91 01 03 	lds	r24, 0x0301
    1354:	88 23       	and	r24, r24
    1356:	61 f0       	breq	.+24     	; 0x1370 <xTaskResumeAll+0xb0>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1358:	80 91 01 03 	lds	r24, 0x0301
    135c:	88 23       	and	r24, r24
    135e:	51 f0       	breq	.+20     	; 0x1374 <xTaskResumeAll+0xb4>
					{
						vTaskIncrementTick();
    1360:	0e 94 c1 08 	call	0x1182	; 0x1182 <vTaskIncrementTick>
						--uxMissedTicks;
    1364:	80 91 01 03 	lds	r24, 0x0301
    1368:	81 50       	subi	r24, 0x01	; 1
    136a:	80 93 01 03 	sts	0x0301, r24
    136e:	f4 cf       	rjmp	.-24     	; 0x1358 <xTaskResumeAll+0x98>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1370:	11 30       	cpi	r17, 0x01	; 1
    1372:	31 f4       	brne	.+12     	; 0x1380 <xTaskResumeAll+0xc0>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    1374:	10 92 00 03 	sts	0x0300, r1
					portYIELD_WITHIN_API();
    1378:	0e 94 b2 03 	call	0x764	; 0x764 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    137c:	81 e0       	ldi	r24, 0x01	; 1
    137e:	06 c0       	rjmp	.+12     	; 0x138c <xTaskResumeAll+0xcc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1380:	80 91 00 03 	lds	r24, 0x0300
    1384:	81 30       	cpi	r24, 0x01	; 1
    1386:	09 f0       	breq	.+2      	; 0x138a <xTaskResumeAll+0xca>
    1388:	ad cf       	rjmp	.-166    	; 0x12e4 <xTaskResumeAll+0x24>
    138a:	f4 cf       	rjmp	.-24     	; 0x1374 <xTaskResumeAll+0xb4>
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    138c:	0f 90       	pop	r0
    138e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1390:	df 91       	pop	r29
    1392:	cf 91       	pop	r28
    1394:	1f 91       	pop	r17
    1396:	0f 91       	pop	r16
    1398:	ff 90       	pop	r15
    139a:	ef 90       	pop	r14
    139c:	08 95       	ret

0000139e <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    139e:	0f 93       	push	r16
    13a0:	1f 93       	push	r17
    13a2:	cf 93       	push	r28
    13a4:	df 93       	push	r29
    13a6:	8c 01       	movw	r16, r24
    13a8:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    13aa:	0e 94 a9 08 	call	0x1152	; 0x1152 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    13ae:	f8 01       	movw	r30, r16
    13b0:	20 81       	ld	r18, Z
    13b2:	31 81       	ldd	r19, Z+1	; 0x01
    13b4:	c2 0f       	add	r28, r18
    13b6:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    13b8:	80 91 06 03 	lds	r24, 0x0306
    13bc:	90 91 07 03 	lds	r25, 0x0307
    13c0:	82 17       	cp	r24, r18
    13c2:	93 07       	cpc	r25, r19
    13c4:	20 f4       	brcc	.+8      	; 0x13ce <vTaskDelayUntil+0x30>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    13c6:	c2 17       	cp	r28, r18
    13c8:	d3 07       	cpc	r29, r19
    13ca:	60 f4       	brcc	.+24     	; 0x13e4 <vTaskDelayUntil+0x46>
    13cc:	03 c0       	rjmp	.+6      	; 0x13d4 <vTaskDelayUntil+0x36>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    13ce:	c2 17       	cp	r28, r18
    13d0:	d3 07       	cpc	r29, r19
    13d2:	50 f0       	brcs	.+20     	; 0x13e8 <vTaskDelayUntil+0x4a>
    13d4:	20 91 06 03 	lds	r18, 0x0306
    13d8:	30 91 07 03 	lds	r19, 0x0307
    13dc:	91 e0       	ldi	r25, 0x01	; 1
    13de:	2c 17       	cp	r18, r28
    13e0:	3d 07       	cpc	r19, r29
    13e2:	18 f0       	brcs	.+6      	; 0x13ea <vTaskDelayUntil+0x4c>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    13e4:	90 e0       	ldi	r25, 0x00	; 0
    13e6:	01 c0       	rjmp	.+2      	; 0x13ea <vTaskDelayUntil+0x4c>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
				{
					xShouldDelay = pdTRUE;
    13e8:	91 e0       	ldi	r25, 0x01	; 1
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    13ea:	f8 01       	movw	r30, r16
    13ec:	d1 83       	std	Z+1, r29	; 0x01
    13ee:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    13f0:	99 23       	and	r25, r25
    13f2:	51 f0       	breq	.+20     	; 0x1408 <vTaskDelayUntil+0x6a>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    13f4:	80 91 fc 02 	lds	r24, 0x02FC
    13f8:	90 91 fd 02 	lds	r25, 0x02FD
    13fc:	02 96       	adiw	r24, 0x02	; 2
    13fe:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1402:	ce 01       	movw	r24, r28
    1404:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1408:	0e 94 60 09 	call	0x12c0	; 0x12c0 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    140c:	81 11       	cpse	r24, r1
    140e:	02 c0       	rjmp	.+4      	; 0x1414 <vTaskDelayUntil+0x76>
		{
			portYIELD_WITHIN_API();
    1410:	0e 94 b2 03 	call	0x764	; 0x764 <vPortYield>
		}
	}
    1414:	df 91       	pop	r29
    1416:	cf 91       	pop	r28
    1418:	1f 91       	pop	r17
    141a:	0f 91       	pop	r16
    141c:	08 95       	ret

0000141e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    141e:	cf 93       	push	r28
    1420:	df 93       	push	r29
    1422:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1424:	89 2b       	or	r24, r25
    1426:	19 f4       	brne	.+6      	; 0x142e <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
    1428:	0e 94 b2 03 	call	0x764	; 0x764 <vPortYield>
    142c:	16 c0       	rjmp	.+44     	; 0x145a <vTaskDelay+0x3c>
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
		{
			vTaskSuspendAll();
    142e:	0e 94 a9 08 	call	0x1152	; 0x1152 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1432:	20 91 06 03 	lds	r18, 0x0306
    1436:	30 91 07 03 	lds	r19, 0x0307
    143a:	c2 0f       	add	r28, r18
    143c:	d3 1f       	adc	r29, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    143e:	80 91 fc 02 	lds	r24, 0x02FC
    1442:	90 91 fd 02 	lds	r25, 0x02FD
    1446:	02 96       	adiw	r24, 0x02	; 2
    1448:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    144c:	ce 01       	movw	r24, r28
    144e:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1452:	0e 94 60 09 	call	0x12c0	; 0x12c0 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1456:	88 23       	and	r24, r24
    1458:	39 f3       	breq	.-50     	; 0x1428 <vTaskDelay+0xa>
		{
			portYIELD_WITHIN_API();
		}
	}
    145a:	df 91       	pop	r29
    145c:	cf 91       	pop	r28
    145e:	08 95       	ret

00001460 <prvIdleTask>:
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    1460:	80 91 09 03 	lds	r24, 0x0309
    1464:	88 23       	and	r24, r24
    1466:	e1 f3       	breq	.-8      	; 0x1460 <prvIdleTask>
		{
			vTaskSuspendAll();
    1468:	0e 94 a9 08 	call	0x1152	; 0x1152 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    146c:	c0 91 0a 03 	lds	r28, 0x030A
			xTaskResumeAll();
    1470:	0e 94 60 09 	call	0x12c0	; 0x12c0 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1474:	cc 23       	and	r28, r28
    1476:	a1 f3       	breq	.-24     	; 0x1460 <prvIdleTask>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    1478:	0f b6       	in	r0, 0x3f	; 63
    147a:	f8 94       	cli
    147c:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    147e:	e0 91 0f 03 	lds	r30, 0x030F
    1482:	f0 91 10 03 	lds	r31, 0x0310
    1486:	c6 81       	ldd	r28, Z+6	; 0x06
    1488:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    148a:	ce 01       	movw	r24, r28
    148c:	02 96       	adiw	r24, 0x02	; 2
    148e:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListRemove>
					--uxCurrentNumberOfTasks;
    1492:	80 91 08 03 	lds	r24, 0x0308
    1496:	81 50       	subi	r24, 0x01	; 1
    1498:	80 93 08 03 	sts	0x0308, r24
					--uxTasksDeleted;
    149c:	80 91 09 03 	lds	r24, 0x0309
    14a0:	81 50       	subi	r24, 0x01	; 1
    14a2:	80 93 09 03 	sts	0x0309, r24
				}
				taskEXIT_CRITICAL();
    14a6:	0f 90       	pop	r0
    14a8:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    14aa:	8f 89       	ldd	r24, Y+23	; 0x17
    14ac:	98 8d       	ldd	r25, Y+24	; 0x18
    14ae:	0e 94 71 02 	call	0x4e2	; 0x4e2 <vPortFree>
		vPortFree( pxTCB );
    14b2:	ce 01       	movw	r24, r28
    14b4:	0e 94 71 02 	call	0x4e2	; 0x4e2 <vPortFree>
    14b8:	d3 cf       	rjmp	.-90     	; 0x1460 <prvIdleTask>

000014ba <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    14ba:	80 91 02 03 	lds	r24, 0x0302
    14be:	88 23       	and	r24, r24
    14c0:	21 f0       	breq	.+8      	; 0x14ca <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    14c2:	81 e0       	ldi	r24, 0x01	; 1
    14c4:	80 93 00 03 	sts	0x0300, r24
    14c8:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    14ca:	99 e0       	ldi	r25, 0x09	; 9
    14cc:	e0 91 04 03 	lds	r30, 0x0304
    14d0:	9e 9f       	mul	r25, r30
    14d2:	f0 01       	movw	r30, r0
    14d4:	11 24       	eor	r1, r1
    14d6:	ee 5c       	subi	r30, 0xCE	; 206
    14d8:	fc 4f       	sbci	r31, 0xFC	; 252
    14da:	80 81       	ld	r24, Z
    14dc:	81 11       	cpse	r24, r1
    14de:	06 c0       	rjmp	.+12     	; 0x14ec <vTaskSwitchContext+0x32>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    14e0:	80 91 04 03 	lds	r24, 0x0304
    14e4:	81 50       	subi	r24, 0x01	; 1
    14e6:	80 93 04 03 	sts	0x0304, r24
    14ea:	f0 cf       	rjmp	.-32     	; 0x14cc <vTaskSwitchContext+0x12>
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    14ec:	80 91 04 03 	lds	r24, 0x0304
    14f0:	90 e0       	ldi	r25, 0x00	; 0
    14f2:	49 e0       	ldi	r20, 0x09	; 9
    14f4:	48 9f       	mul	r20, r24
    14f6:	90 01       	movw	r18, r0
    14f8:	49 9f       	mul	r20, r25
    14fa:	30 0d       	add	r19, r0
    14fc:	11 24       	eor	r1, r1
    14fe:	f9 01       	movw	r30, r18
    1500:	ee 5c       	subi	r30, 0xCE	; 206
    1502:	fc 4f       	sbci	r31, 0xFC	; 252
    1504:	a1 81       	ldd	r26, Z+1	; 0x01
    1506:	b2 81       	ldd	r27, Z+2	; 0x02
    1508:	12 96       	adiw	r26, 0x02	; 2
    150a:	0d 90       	ld	r0, X+
    150c:	bc 91       	ld	r27, X
    150e:	a0 2d       	mov	r26, r0
    1510:	b2 83       	std	Z+2, r27	; 0x02
    1512:	a1 83       	std	Z+1, r26	; 0x01
    1514:	2b 5c       	subi	r18, 0xCB	; 203
    1516:	3c 4f       	sbci	r19, 0xFC	; 252
    1518:	a2 17       	cp	r26, r18
    151a:	b3 07       	cpc	r27, r19
    151c:	31 f4       	brne	.+12     	; 0x152a <vTaskSwitchContext+0x70>
    151e:	12 96       	adiw	r26, 0x02	; 2
    1520:	2d 91       	ld	r18, X+
    1522:	3c 91       	ld	r19, X
    1524:	13 97       	sbiw	r26, 0x03	; 3
    1526:	32 83       	std	Z+2, r19	; 0x02
    1528:	21 83       	std	Z+1, r18	; 0x01
    152a:	29 e0       	ldi	r18, 0x09	; 9
    152c:	28 9f       	mul	r18, r24
    152e:	f0 01       	movw	r30, r0
    1530:	29 9f       	mul	r18, r25
    1532:	f0 0d       	add	r31, r0
    1534:	11 24       	eor	r1, r1
    1536:	ee 5c       	subi	r30, 0xCE	; 206
    1538:	fc 4f       	sbci	r31, 0xFC	; 252
    153a:	01 80       	ldd	r0, Z+1	; 0x01
    153c:	f2 81       	ldd	r31, Z+2	; 0x02
    153e:	e0 2d       	mov	r30, r0
    1540:	86 81       	ldd	r24, Z+6	; 0x06
    1542:	97 81       	ldd	r25, Z+7	; 0x07
    1544:	90 93 fd 02 	sts	0x02FD, r25
    1548:	80 93 fc 02 	sts	0x02FC, r24
    154c:	08 95       	ret

0000154e <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    154e:	cf 93       	push	r28
    1550:	df 93       	push	r29
    1552:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1554:	20 91 fc 02 	lds	r18, 0x02FC
    1558:	30 91 fd 02 	lds	r19, 0x02FD
    155c:	b9 01       	movw	r22, r18
    155e:	64 5f       	subi	r22, 0xF4	; 244
    1560:	7f 4f       	sbci	r23, 0xFF	; 255
    1562:	0e 94 b5 02 	call	0x56a	; 0x56a <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1566:	80 91 fc 02 	lds	r24, 0x02FC
    156a:	90 91 fd 02 	lds	r25, 0x02FD
    156e:	02 96       	adiw	r24, 0x02	; 2
    1570:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1574:	80 91 06 03 	lds	r24, 0x0306
    1578:	90 91 07 03 	lds	r25, 0x0307
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    157c:	8c 0f       	add	r24, r28
    157e:	9d 1f       	adc	r25, r29
	}
	#endif
}
    1580:	df 91       	pop	r29
    1582:	cf 91       	pop	r28
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1584:	0c 94 f9 06 	jmp	0xdf2	; 0xdf2 <prvAddCurrentTaskToDelayedList>

00001588 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1588:	0f 93       	push	r16
    158a:	1f 93       	push	r17
    158c:	cf 93       	push	r28
    158e:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1590:	dc 01       	movw	r26, r24
    1592:	15 96       	adiw	r26, 0x05	; 5
    1594:	ed 91       	ld	r30, X+
    1596:	fc 91       	ld	r31, X
    1598:	16 97       	sbiw	r26, 0x06	; 6
    159a:	c6 81       	ldd	r28, Z+6	; 0x06
    159c:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    159e:	8e 01       	movw	r16, r28
    15a0:	04 5f       	subi	r16, 0xF4	; 244
    15a2:	1f 4f       	sbci	r17, 0xFF	; 255
    15a4:	c8 01       	movw	r24, r16
    15a6:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    15aa:	80 91 02 03 	lds	r24, 0x0302
    15ae:	81 11       	cpse	r24, r1
    15b0:	14 c0       	rjmp	.+40     	; 0x15da <xTaskRemoveFromEventList+0x52>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    15b2:	0a 50       	subi	r16, 0x0A	; 10
    15b4:	11 09       	sbc	r17, r1
    15b6:	c8 01       	movw	r24, r16
    15b8:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    15bc:	9e 89       	ldd	r25, Y+22	; 0x16
    15be:	80 91 04 03 	lds	r24, 0x0304
    15c2:	89 17       	cp	r24, r25
    15c4:	10 f4       	brcc	.+4      	; 0x15ca <xTaskRemoveFromEventList+0x42>
    15c6:	90 93 04 03 	sts	0x0304, r25
    15ca:	b9 e0       	ldi	r27, 0x09	; 9
    15cc:	9b 9f       	mul	r25, r27
    15ce:	c0 01       	movw	r24, r0
    15d0:	11 24       	eor	r1, r1
    15d2:	b8 01       	movw	r22, r16
    15d4:	8e 5c       	subi	r24, 0xCE	; 206
    15d6:	9c 4f       	sbci	r25, 0xFC	; 252
    15d8:	03 c0       	rjmp	.+6      	; 0x15e0 <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    15da:	b8 01       	movw	r22, r16
    15dc:	83 e1       	ldi	r24, 0x13	; 19
    15de:	93 e0       	ldi	r25, 0x03	; 3
    15e0:	0e 94 92 02 	call	0x524	; 0x524 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    15e4:	e0 91 fc 02 	lds	r30, 0x02FC
    15e8:	f0 91 fd 02 	lds	r31, 0x02FD
    15ec:	81 e0       	ldi	r24, 0x01	; 1
    15ee:	2e 89       	ldd	r18, Y+22	; 0x16
    15f0:	96 89       	ldd	r25, Z+22	; 0x16
    15f2:	29 17       	cp	r18, r25
    15f4:	08 f4       	brcc	.+2      	; 0x15f8 <xTaskRemoveFromEventList+0x70>
    15f6:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    15f8:	df 91       	pop	r29
    15fa:	cf 91       	pop	r28
    15fc:	1f 91       	pop	r17
    15fe:	0f 91       	pop	r16
    1600:	08 95       	ret

00001602 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1602:	20 91 ff 02 	lds	r18, 0x02FF
    1606:	fc 01       	movw	r30, r24
    1608:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    160a:	20 91 06 03 	lds	r18, 0x0306
    160e:	30 91 07 03 	lds	r19, 0x0307
    1612:	32 83       	std	Z+2, r19	; 0x02
    1614:	21 83       	std	Z+1, r18	; 0x01
    1616:	08 95       	ret

00001618 <xTaskCheckForTimeOut>:
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1618:	0f b6       	in	r0, 0x3f	; 63
    161a:	f8 94       	cli
    161c:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    161e:	30 91 ff 02 	lds	r19, 0x02FF
    1622:	dc 01       	movw	r26, r24
    1624:	2c 91       	ld	r18, X
    1626:	11 96       	adiw	r26, 0x01	; 1
    1628:	ed 91       	ld	r30, X+
    162a:	fc 91       	ld	r31, X
    162c:	12 97       	sbiw	r26, 0x02	; 2
    162e:	32 17       	cp	r19, r18
    1630:	39 f0       	breq	.+14     	; 0x1640 <xTaskCheckForTimeOut+0x28>
    1632:	20 91 06 03 	lds	r18, 0x0306
    1636:	30 91 07 03 	lds	r19, 0x0307
    163a:	2e 17       	cp	r18, r30
    163c:	3f 07       	cpc	r19, r31
    163e:	d8 f4       	brcc	.+54     	; 0x1676 <xTaskCheckForTimeOut+0x5e>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1640:	40 91 06 03 	lds	r20, 0x0306
    1644:	50 91 07 03 	lds	r21, 0x0307
    1648:	db 01       	movw	r26, r22
    164a:	2d 91       	ld	r18, X+
    164c:	3c 91       	ld	r19, X
    164e:	11 97       	sbiw	r26, 0x01	; 1
    1650:	4e 1b       	sub	r20, r30
    1652:	5f 0b       	sbc	r21, r31
    1654:	42 17       	cp	r20, r18
    1656:	53 07       	cpc	r21, r19
    1658:	70 f4       	brcc	.+28     	; 0x1676 <xTaskCheckForTimeOut+0x5e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    165a:	40 91 06 03 	lds	r20, 0x0306
    165e:	50 91 07 03 	lds	r21, 0x0307
    1662:	4e 1b       	sub	r20, r30
    1664:	5f 0b       	sbc	r21, r31
    1666:	24 1b       	sub	r18, r20
    1668:	35 0b       	sbc	r19, r21
    166a:	2d 93       	st	X+, r18
    166c:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    166e:	0e 94 01 0b 	call	0x1602	; 0x1602 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1672:	80 e0       	ldi	r24, 0x00	; 0
    1674:	01 c0       	rjmp	.+2      	; 0x1678 <xTaskCheckForTimeOut+0x60>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1676:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    1678:	0f 90       	pop	r0
    167a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    167c:	08 95       	ret

0000167e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    167e:	81 e0       	ldi	r24, 0x01	; 1
    1680:	80 93 00 03 	sts	0x0300, r24
    1684:	08 95       	ret

00001686 <uart_init>:
#include "UART_int.h"



void uart_init(void){
DDRD|=(1<<DDD1);
    1686:	89 9a       	sbi	0x11, 1	; 17
DDRD&=~(1<<DDD0);
    1688:	88 98       	cbi	0x11, 0	; 17
UBRRL = 0x33;//set baudrate 9600
    168a:	83 e3       	ldi	r24, 0x33	; 51
    168c:	89 b9       	out	0x09, r24	; 9
UBRRH = 0;
    168e:	10 bc       	out	0x20, r1	; 32
UCSRC=(1<<UCSZ0)|(1<<UCSZ1)|(1<<URSEL);  // Set Frame Format -> 8 data, 1 stop, No Parity
    1690:	86 e8       	ldi	r24, 0x86	; 134
    1692:	80 bd       	out	0x20, r24	; 32
UCSRB=(1<<RXEN)|(1<<TXEN);// Enable RX and TX
    1694:	88 e1       	ldi	r24, 0x18	; 24
    1696:	8a b9       	out	0x0a, r24	; 10
    1698:	08 95       	ret

0000169a <uart_send_char>:


}

void uart_send_char(u8 c){
while(!(UCSRA & (1<<UDRE)));
    169a:	5d 9b       	sbis	0x0b, 5	; 11
    169c:	fe cf       	rjmp	.-4      	; 0x169a <uart_send_char>

      UDR=c;
    169e:	8c b9       	out	0x0c, r24	; 12
    16a0:	08 95       	ret

000016a2 <uart_receive_char>:
    16a2:	5f 9b       	sbis	0x0b, 7	; 11
    16a4:	fe cf       	rjmp	.-4      	; 0x16a2 <uart_receive_char>
    16a6:	8c b1       	in	r24, 0x0c	; 12
    16a8:	08 95       	ret

000016aa <main>:


//================= [Main] ====================
//#include <avr/io.h>
int main(void)
{//DDRA =0xff;
    16aa:	af 92       	push	r10
    16ac:	bf 92       	push	r11
    16ae:	cf 92       	push	r12
    16b0:	df 92       	push	r13
    16b2:	ef 92       	push	r14
    16b4:	ff 92       	push	r15
    16b6:	0f 93       	push	r16
 //PORTA=0xff;	
	uart_init();
    16b8:	0e 94 43 0b 	call	0x1686	; 0x1686 <uart_init>
    //void uart_send_char(u8 c);
    //u8 uart_receive_char(void);
	xQueue = xQueueCreate( 5, sizeof(u8) );
    16bc:	61 e0       	ldi	r22, 0x01	; 1
    16be:	85 e0       	ldi	r24, 0x05	; 5
    16c0:	0e 94 01 05 	call	0xa02	; 0xa02 <xQueueCreate>
    16c4:	90 93 50 03 	sts	0x0350, r25
    16c8:	80 93 4f 03 	sts	0x034F, r24
	
	// Create Tasks
	//xTaskCreate( Blink_500ms_task,NULL, configMINIMAL_STACK_SIZE, NULL, 2, NULL );
	//xTaskCreate( Blink_1000ms_task,NULL, configMINIMAL_STACK_SIZE, NULL, 2, NULL );
	xTaskCreate( Blink_1500ms_task,NULL, configMINIMAL_STACK_SIZE, NULL, 2, NULL );
    16cc:	a1 2c       	mov	r10, r1
    16ce:	b1 2c       	mov	r11, r1
    16d0:	c1 2c       	mov	r12, r1
    16d2:	d1 2c       	mov	r13, r1
    16d4:	e1 2c       	mov	r14, r1
    16d6:	f1 2c       	mov	r15, r1
    16d8:	02 e0       	ldi	r16, 0x02	; 2
    16da:	20 e0       	ldi	r18, 0x00	; 0
    16dc:	30 e0       	ldi	r19, 0x00	; 0
    16de:	45 e5       	ldi	r20, 0x55	; 85
    16e0:	50 e0       	ldi	r21, 0x00	; 0
    16e2:	60 e0       	ldi	r22, 0x00	; 0
    16e4:	70 e0       	ldi	r23, 0x00	; 0
    16e6:	89 e4       	ldi	r24, 0x49	; 73
    16e8:	90 e0       	ldi	r25, 0x00	; 0
    16ea:	0e 94 31 07 	call	0xe62	; 0xe62 <xTaskGenericCreate>
	xTaskCreate( Blink_2000ms_task,NULL, configMINIMAL_STACK_SIZE, NULL, 3, NULL );
    16ee:	03 e0       	ldi	r16, 0x03	; 3
    16f0:	20 e0       	ldi	r18, 0x00	; 0
    16f2:	30 e0       	ldi	r19, 0x00	; 0
    16f4:	45 e5       	ldi	r20, 0x55	; 85
    16f6:	50 e0       	ldi	r21, 0x00	; 0
    16f8:	60 e0       	ldi	r22, 0x00	; 0
    16fa:	70 e0       	ldi	r23, 0x00	; 0
    16fc:	88 e6       	ldi	r24, 0x68	; 104
    16fe:	90 e0       	ldi	r25, 0x00	; 0
    1700:	0e 94 31 07 	call	0xe62	; 0xe62 <xTaskGenericCreate>

	vSemaphoreCreateBinary(Push_Semaphore);
    1704:	60 e0       	ldi	r22, 0x00	; 0
    1706:	81 e0       	ldi	r24, 0x01	; 1
    1708:	0e 94 01 05 	call	0xa02	; 0xa02 <xQueueCreate>
    170c:	90 93 4e 03 	sts	0x034E, r25
    1710:	80 93 4d 03 	sts	0x034D, r24
    1714:	00 97       	sbiw	r24, 0x00	; 0
    1716:	39 f0       	breq	.+14     	; 0x1726 <main+0x7c>
    1718:	20 e0       	ldi	r18, 0x00	; 0
    171a:	40 e0       	ldi	r20, 0x00	; 0
    171c:	50 e0       	ldi	r21, 0x00	; 0
    171e:	60 e0       	ldi	r22, 0x00	; 0
    1720:	70 e0       	ldi	r23, 0x00	; 0
    1722:	0e 94 4c 05 	call	0xa98	; 0xa98 <xQueueGenericSend>

	// Start FreeRTOS
	vTaskStartScheduler();
    1726:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vTaskStartScheduler>
	
}
    172a:	0f 91       	pop	r16
    172c:	ff 90       	pop	r15
    172e:	ef 90       	pop	r14
    1730:	df 90       	pop	r13
    1732:	cf 90       	pop	r12
    1734:	bf 90       	pop	r11
    1736:	af 90       	pop	r10
    1738:	08 95       	ret

0000173a <memcpy>:
    173a:	fb 01       	movw	r30, r22
    173c:	dc 01       	movw	r26, r24
    173e:	02 c0       	rjmp	.+4      	; 0x1744 <memcpy+0xa>
    1740:	01 90       	ld	r0, Z+
    1742:	0d 92       	st	X+, r0
    1744:	41 50       	subi	r20, 0x01	; 1
    1746:	50 40       	sbci	r21, 0x00	; 0
    1748:	d8 f7       	brcc	.-10     	; 0x1740 <memcpy+0x6>
    174a:	08 95       	ret

0000174c <memset>:
    174c:	dc 01       	movw	r26, r24
    174e:	01 c0       	rjmp	.+2      	; 0x1752 <memset+0x6>
    1750:	6d 93       	st	X+, r22
    1752:	41 50       	subi	r20, 0x01	; 1
    1754:	50 40       	sbci	r21, 0x00	; 0
    1756:	e0 f7       	brcc	.-8      	; 0x1750 <memset+0x4>
    1758:	08 95       	ret

0000175a <strncpy>:
    175a:	fb 01       	movw	r30, r22
    175c:	dc 01       	movw	r26, r24
    175e:	41 50       	subi	r20, 0x01	; 1
    1760:	50 40       	sbci	r21, 0x00	; 0
    1762:	48 f0       	brcs	.+18     	; 0x1776 <strncpy+0x1c>
    1764:	01 90       	ld	r0, Z+
    1766:	0d 92       	st	X+, r0
    1768:	00 20       	and	r0, r0
    176a:	c9 f7       	brne	.-14     	; 0x175e <strncpy+0x4>
    176c:	01 c0       	rjmp	.+2      	; 0x1770 <strncpy+0x16>
    176e:	1d 92       	st	X+, r1
    1770:	41 50       	subi	r20, 0x01	; 1
    1772:	50 40       	sbci	r21, 0x00	; 0
    1774:	e0 f7       	brcc	.-8      	; 0x176e <strncpy+0x14>
    1776:	08 95       	ret

00001778 <_exit>:
    1778:	f8 94       	cli

0000177a <__stop_program>:
    177a:	ff cf       	rjmp	.-2      	; 0x177a <__stop_program>
